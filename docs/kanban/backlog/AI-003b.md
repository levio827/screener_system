# AI-003b: Chart Pattern Recognition - Service & UI

## Metadata

| Field | Value |
|-------|-------|
| **ID** | AI-003b |
| **Title** | Chart Pattern Recognition - Serving & Frontend |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P1 (High) |
| **Estimate** | 8 hours |
| **Sprint** | Sprint 6 |
| **Epic** | AI/Machine Learning Features |
| **Assignee** | TBD |
| **Depends On** | AI-003a |
| **Created** | 2025-11-29 |
| **Tags** | `ai`, `pattern-recognition`, `visualization`, `real-time`, `websocket` |
| **Blocks** | None |

## Description

Implement real-time pattern recognition service and interactive chart overlay UI for visualizing detected technical patterns (Head & Shoulders, Double Top/Bottom, Triangles, etc.) with confidence scores and alert notifications.

## Progress

**0% - Not started**

---

## Acceptance Criteria

- [ ] Real-time pattern detection service with WebSocket support
- [ ] API endpoint `/v1/ai/patterns/{stock_code}` with query parameters
- [ ] Display pattern overlay on frontend charts with annotations
- [ ] Show pattern confidence score with visual indicators
- [ ] Pattern alert configuration and notification system
- [ ] Pattern history tracking and statistics
- [ ] Mobile-responsive pattern visualization

---

## Subtasks

### 1. Backend Pattern Service Implementation
- [ ] Create pattern recognition service module
  - [ ] Implement pattern detection scheduler (every 5 minutes for active stocks)
  - [ ] Add pattern caching layer (Redis) with 5-minute TTL
  - [ ] Implement WebSocket notification system for new patterns
- [ ] Design REST API endpoints
  - [ ] GET `/v1/ai/patterns/{stock_code}` - Retrieve detected patterns
  - [ ] GET `/v1/ai/patterns/{stock_code}/history` - Pattern history
  - [ ] POST `/v1/ai/patterns/alerts` - Configure pattern alerts
  - [ ] DELETE `/v1/ai/patterns/alerts/{alert_id}` - Remove alert
- [ ] Integrate with trained ML model from AI-003a
  - [ ] Load model artifacts from model registry
  - [ ] Implement batch inference for multiple timeframes
  - [ ] Add model version tracking and A/B testing support

### 2. Pattern Visualization Frontend
- [ ] Create chart overlay component
  - [ ] Implement SVG-based pattern annotations
  - [ ] Add pattern highlight zones with gradient fills
  - [ ] Support zoom and pan interactions
- [ ] Design pattern detail panel
  - [ ] Show pattern type, confidence, and expected movement
  - [ ] Display historical accuracy for this pattern type
  - [ ] Add "Similar Past Patterns" comparison view
- [ ] Implement real-time updates
  - [ ] WebSocket connection management
  - [ ] Optimistic UI updates with rollback support
  - [ ] Connection recovery and reconnection logic

### 3. Alert System Integration
- [ ] Pattern alert configuration UI
  - [ ] Multi-condition alert builder (pattern type + confidence threshold)
  - [ ] Alert delivery method selection (email, push, in-app)
  - [ ] Alert frequency management (once, daily digest, real-time)
- [ ] Backend alert processor
  - [ ] Alert matching engine with pattern detection
  - [ ] Notification dispatcher with rate limiting
  - [ ] Alert history and audit log

### 4. Testing & Quality Assurance
- [ ] Unit tests for pattern service (>80% coverage)
  - [ ] Test pattern detection accuracy
  - [ ] Test caching behavior
  - [ ] Test WebSocket message handling
- [ ] Integration tests for API endpoints
  - [ ] Test end-to-end pattern retrieval flow
  - [ ] Test alert configuration and triggering
  - [ ] Test concurrent user scenarios
- [ ] E2E tests for frontend visualization
  - [ ] Test pattern overlay rendering
  - [ ] Test real-time update behavior
  - [ ] Test mobile responsiveness

---

## Implementation Details

### Backend Service Architecture

```python
# src/services/pattern_recognition_service.py
from typing import List, Dict, Optional
from datetime import datetime, timedelta
import asyncio
from redis import Redis
from src.models.pattern_detector import PatternDetector
from src.core.websocket_manager import WebSocketManager
from src.core.cache import CacheManager

class PatternRecognitionService:
    """Real-time pattern detection and serving service"""

    def __init__(
        self,
        model_registry: ModelRegistry,
        cache: CacheManager,
        ws_manager: WebSocketManager
    ):
        self.detector = PatternDetector(model_registry)
        self.cache = cache
        self.ws_manager = ws_manager
        self._running = False

    async def start_detection_loop(self):
        """Start background pattern detection for active stocks"""
        self._running = True
        while self._running:
            try:
                active_stocks = await self._get_active_stocks()
                await self._detect_patterns_batch(active_stocks)
                await asyncio.sleep(300)  # 5-minute interval
            except Exception as e:
                logger.error(f"Pattern detection error: {e}", exc_info=True)
                await asyncio.sleep(60)  # Retry after 1 minute

    async def get_patterns(
        self,
        stock_code: str,
        timeframe: str = "1D",
        min_confidence: float = 0.7
    ) -> List[Dict]:
        """Retrieve detected patterns for a stock"""
        cache_key = f"patterns:{stock_code}:{timeframe}"

        # Check cache first
        cached = await self.cache.get(cache_key)
        if cached:
            return self._filter_by_confidence(cached, min_confidence)

        # Detect patterns if not cached
        patterns = await self.detector.detect(
            stock_code=stock_code,
            timeframe=timeframe
        )

        # Cache for 5 minutes
        await self.cache.set(cache_key, patterns, ttl=300)

        return self._filter_by_confidence(patterns, min_confidence)

    async def _detect_patterns_batch(self, stock_codes: List[str]):
        """Batch pattern detection with WebSocket notification"""
        for stock_code in stock_codes:
            old_patterns = await self.cache.get(f"patterns:{stock_code}:1D")
            new_patterns = await self.get_patterns(stock_code)

            # Notify if new patterns detected
            if self._has_new_patterns(old_patterns, new_patterns):
                await self.ws_manager.broadcast(
                    topic=f"patterns.{stock_code}",
                    data={
                        "stock_code": stock_code,
                        "patterns": new_patterns,
                        "timestamp": datetime.utcnow().isoformat()
                    }
                )

    def _filter_by_confidence(
        self,
        patterns: List[Dict],
        min_confidence: float
    ) -> List[Dict]:
        """Filter patterns by confidence threshold"""
        return [
            p for p in patterns
            if p.get("confidence", 0) >= min_confidence
        ]

    def _has_new_patterns(
        self,
        old: Optional[List[Dict]],
        new: List[Dict]
    ) -> bool:
        """Check if new patterns have been detected"""
        if not old:
            return len(new) > 0

        old_ids = {p["pattern_id"] for p in old}
        new_ids = {p["pattern_id"] for p in new}
        return len(new_ids - old_ids) > 0
```

### REST API Endpoints

```python
# src/api/routes/patterns.py
from fastapi import APIRouter, Depends, Query, HTTPException
from typing import List, Optional
from src.services.pattern_recognition_service import PatternRecognitionService
from src.api.schemas.pattern import PatternResponse, AlertConfigRequest

router = APIRouter(prefix="/v1/ai/patterns", tags=["patterns"])

@router.get("/{stock_code}", response_model=List[PatternResponse])
async def get_patterns(
    stock_code: str,
    timeframe: str = Query("1D", regex="^(1D|1W|1M)$"),
    min_confidence: float = Query(0.7, ge=0.0, le=1.0),
    service: PatternRecognitionService = Depends()
):
    """
    Retrieve detected chart patterns for a stock

    Args:
        stock_code: Stock ticker symbol
        timeframe: Chart timeframe (1D, 1W, 1M)
        min_confidence: Minimum confidence score threshold

    Returns:
        List of detected patterns with metadata
    """
    try:
        patterns = await service.get_patterns(
            stock_code=stock_code,
            timeframe=timeframe,
            min_confidence=min_confidence
        )
        return patterns
    except Exception as e:
        logger.error(f"Failed to get patterns: {e}")
        raise HTTPException(status_code=500, detail="Pattern retrieval failed")

@router.get("/{stock_code}/history")
async def get_pattern_history(
    stock_code: str,
    days: int = Query(30, ge=1, le=365),
    service: PatternRecognitionService = Depends()
):
    """Retrieve historical pattern detection data"""
    end_date = datetime.utcnow()
    start_date = end_date - timedelta(days=days)

    history = await service.get_pattern_history(
        stock_code=stock_code,
        start_date=start_date,
        end_date=end_date
    )

    return {
        "stock_code": stock_code,
        "period": {"start": start_date, "end": end_date},
        "patterns": history,
        "statistics": await service.calculate_pattern_stats(history)
    }

@router.post("/alerts")
async def create_pattern_alert(
    request: AlertConfigRequest,
    service: PatternRecognitionService = Depends()
):
    """Configure pattern detection alert"""
    alert_id = await service.create_alert(
        user_id=request.user_id,
        stock_code=request.stock_code,
        pattern_types=request.pattern_types,
        min_confidence=request.min_confidence,
        notification_methods=request.notification_methods
    )

    return {"alert_id": alert_id, "status": "active"}
```

### Frontend Pattern Visualization

```typescript
// src/components/charts/PatternOverlay.tsx
import React, { useEffect, useState } from 'react';
import { Layer, Line, Circle, Text, Group } from 'react-konva';
import { useWebSocket } from '@/hooks/useWebSocket';
import { PatternAnnotation } from './PatternAnnotation';

interface Pattern {
  pattern_id: string;
  pattern_type: string;
  confidence: number;
  coordinates: { x: number; y: number }[];
  expected_movement: 'bullish' | 'bearish';
  breakout_level?: number;
}

interface PatternOverlayProps {
  stockCode: string;
  timeframe: string;
  chartDimensions: { width: number; height: number };
  priceScale: (price: number) => number;
  timeScale: (timestamp: number) => number;
}

export const PatternOverlay: React.FC<PatternOverlayProps> = ({
  stockCode,
  timeframe,
  chartDimensions,
  priceScale,
  timeScale,
}) => {
  const [patterns, setPatterns] = useState<Pattern[]>([]);
  const [selectedPattern, setSelectedPattern] = useState<string | null>(null);

  // WebSocket for real-time pattern updates
  const { data: wsData } = useWebSocket({
    url: `wss://api.example.com/ws/patterns/${stockCode}`,
    reconnect: true,
  });

  useEffect(() => {
    // Fetch initial patterns
    const fetchPatterns = async () => {
      try {
        const response = await fetch(
          `/v1/ai/patterns/${stockCode}?timeframe=${timeframe}&min_confidence=0.7`
        );
        const data = await response.json();
        setPatterns(data);
      } catch (error) {
        console.error('Failed to fetch patterns:', error);
      }
    };

    fetchPatterns();
  }, [stockCode, timeframe]);

  useEffect(() => {
    // Handle WebSocket updates
    if (wsData?.patterns) {
      setPatterns(wsData.patterns);

      // Show notification for new patterns
      if (wsData.is_new) {
        showNotification({
          title: 'New Pattern Detected',
          message: `${wsData.patterns[0].pattern_type} detected on ${stockCode}`,
          type: 'info',
        });
      }
    }
  }, [wsData, stockCode]);

  const renderPatternShape = (pattern: Pattern) => {
    const points = pattern.coordinates.flatMap(coord => [
      timeScale(coord.x),
      priceScale(coord.y),
    ]);

    const color = pattern.expected_movement === 'bullish' ? '#22c55e' : '#ef4444';
    const opacity = pattern.confidence;

    return (
      <Group key={pattern.pattern_id}>
        {/* Pattern outline */}
        <Line
          points={points}
          stroke={color}
          strokeWidth={2}
          opacity={opacity}
          dash={[5, 5]}
          onClick={() => setSelectedPattern(pattern.pattern_id)}
          onTap={() => setSelectedPattern(pattern.pattern_id)}
        />

        {/* Highlight zone */}
        <Line
          points={points}
          stroke={color}
          strokeWidth={20}
          opacity={opacity * 0.2}
          lineCap="round"
          lineJoin="round"
        />

        {/* Key points */}
        {pattern.coordinates.map((coord, idx) => (
          <Circle
            key={idx}
            x={timeScale(coord.x)}
            y={priceScale(coord.y)}
            radius={4}
            fill={color}
            opacity={opacity}
          />
        ))}

        {/* Breakout level indicator */}
        {pattern.breakout_level && (
          <Line
            points={[
              0,
              priceScale(pattern.breakout_level),
              chartDimensions.width,
              priceScale(pattern.breakout_level),
            ]}
            stroke={color}
            strokeWidth={1}
            dash={[10, 5]}
            opacity={0.5}
          />
        )}
      </Group>
    );
  };

  return (
    <Layer>
      {patterns.map(renderPatternShape)}

      {/* Pattern detail popup */}
      {selectedPattern && (
        <PatternAnnotation
          pattern={patterns.find(p => p.pattern_id === selectedPattern)!}
          onClose={() => setSelectedPattern(null)}
          chartDimensions={chartDimensions}
        />
      )}
    </Layer>
  );
};
```

### Pattern Detail Component

```typescript
// src/components/charts/PatternDetail.tsx
import React from 'react';
import { Card, Badge, Progress, Tooltip } from '@/components/ui';
import { TrendingUp, TrendingDown, Info } from 'lucide-react';

interface PatternDetailProps {
  pattern: Pattern;
  historicalAccuracy?: number;
}

export const PatternDetail: React.FC<PatternDetailProps> = ({
  pattern,
  historicalAccuracy = 0.75,
}) => {
  const confidenceColor =
    pattern.confidence >= 0.8 ? 'green' :
    pattern.confidence >= 0.6 ? 'yellow' : 'red';

  const movementIcon = pattern.expected_movement === 'bullish'
    ? <TrendingUp className="text-green-500" />
    : <TrendingDown className="text-red-500" />;

  return (
    <Card className="p-4 space-y-3">
      <div className="flex items-center justify-between">
        <h3 className="font-semibold flex items-center gap-2">
          {movementIcon}
          {pattern.pattern_type}
        </h3>
        <Badge variant={confidenceColor}>
          {(pattern.confidence * 100).toFixed(0)}% confidence
        </Badge>
      </div>

      <div className="space-y-2">
        <div className="flex justify-between text-sm">
          <span className="text-gray-600">Confidence Score</span>
          <span className="font-medium">{(pattern.confidence * 100).toFixed(1)}%</span>
        </div>
        <Progress value={pattern.confidence * 100} className="h-2" />
      </div>

      <div className="space-y-2">
        <div className="flex justify-between text-sm">
          <span className="text-gray-600 flex items-center gap-1">
            Historical Accuracy
            <Tooltip content="Based on past 90 days of similar patterns">
              <Info size={14} />
            </Tooltip>
          </span>
          <span className="font-medium">{(historicalAccuracy * 100).toFixed(0)}%</span>
        </div>
        <Progress value={historicalAccuracy * 100} className="h-2" />
      </div>

      {pattern.breakout_level && (
        <div className="border-t pt-2">
          <div className="flex justify-between text-sm">
            <span className="text-gray-600">Expected Breakout</span>
            <span className="font-medium">${pattern.breakout_level.toFixed(2)}</span>
          </div>
        </div>
      )}

      <div className="text-xs text-gray-500 border-t pt-2">
        Detected: {new Date(pattern.detected_at).toLocaleString()}
      </div>
    </Card>
  );
};
```

---

## Testing Strategy

### Unit Tests

```python
# tests/services/test_pattern_recognition_service.py
import pytest
from unittest.mock import Mock, AsyncMock, patch
from src.services.pattern_recognition_service import PatternRecognitionService

@pytest.fixture
def mock_dependencies():
    return {
        'model_registry': Mock(),
        'cache': AsyncMock(),
        'ws_manager': AsyncMock(),
    }

@pytest.mark.asyncio
async def test_get_patterns_returns_cached_data(mock_dependencies):
    """Test that cached patterns are returned when available"""
    service = PatternRecognitionService(**mock_dependencies)

    cached_patterns = [
        {"pattern_id": "1", "pattern_type": "Head and Shoulders", "confidence": 0.85}
    ]
    mock_dependencies['cache'].get.return_value = cached_patterns

    result = await service.get_patterns("AAPL", timeframe="1D")

    assert result == cached_patterns
    mock_dependencies['cache'].get.assert_called_once_with("patterns:AAPL:1D")

@pytest.mark.asyncio
async def test_get_patterns_filters_by_confidence(mock_dependencies):
    """Test confidence filtering works correctly"""
    service = PatternRecognitionService(**mock_dependencies)

    patterns = [
        {"pattern_id": "1", "confidence": 0.9},
        {"pattern_id": "2", "confidence": 0.6},
        {"pattern_id": "3", "confidence": 0.4},
    ]
    mock_dependencies['cache'].get.return_value = patterns

    result = await service.get_patterns("AAPL", min_confidence=0.7)

    assert len(result) == 1
    assert result[0]["confidence"] == 0.9

@pytest.mark.asyncio
async def test_websocket_notification_on_new_pattern(mock_dependencies):
    """Test WebSocket broadcast when new pattern detected"""
    service = PatternRecognitionService(**mock_dependencies)

    old_patterns = [{"pattern_id": "1"}]
    new_patterns = [{"pattern_id": "1"}, {"pattern_id": "2"}]

    with patch.object(service, 'get_patterns', return_value=new_patterns):
        mock_dependencies['cache'].get.return_value = old_patterns
        await service._detect_patterns_batch(["AAPL"])

    mock_dependencies['ws_manager'].broadcast.assert_called_once()
```

### Integration Tests

```python
# tests/api/test_pattern_endpoints.py
import pytest
from httpx import AsyncClient
from src.main import app

@pytest.mark.asyncio
async def test_get_patterns_endpoint_success():
    """Test successful pattern retrieval"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.get("/v1/ai/patterns/AAPL?timeframe=1D&min_confidence=0.7")

    assert response.status_code == 200
    data = response.json()
    assert isinstance(data, list)
    if len(data) > 0:
        assert "pattern_type" in data[0]
        assert "confidence" in data[0]
        assert data[0]["confidence"] >= 0.7

@pytest.mark.asyncio
async def test_get_patterns_invalid_timeframe():
    """Test validation for invalid timeframe"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.get("/v1/ai/patterns/AAPL?timeframe=5M")

    assert response.status_code == 422  # Validation error

@pytest.mark.asyncio
async def test_create_alert_endpoint():
    """Test pattern alert creation"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post("/v1/ai/patterns/alerts", json={
            "user_id": "user123",
            "stock_code": "AAPL",
            "pattern_types": ["Head and Shoulders", "Double Top"],
            "min_confidence": 0.8,
            "notification_methods": ["email", "push"]
        })

    assert response.status_code == 200
    data = response.json()
    assert "alert_id" in data
    assert data["status"] == "active"
```

### End-to-End Tests

```typescript
// e2e/pattern-visualization.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Pattern Visualization', () => {
  test('should display pattern overlay on chart', async ({ page }) => {
    await page.goto('/stocks/AAPL');

    // Wait for chart to load
    await page.waitForSelector('[data-testid="stock-chart"]');

    // Verify pattern overlay is rendered
    const patternLayer = await page.locator('[data-testid="pattern-overlay"]');
    await expect(patternLayer).toBeVisible();

    // Check for pattern annotations
    const patterns = await page.locator('[data-testid^="pattern-"]').count();
    expect(patterns).toBeGreaterThan(0);
  });

  test('should show pattern details on click', async ({ page }) => {
    await page.goto('/stocks/AAPL');
    await page.waitForSelector('[data-testid="stock-chart"]');

    // Click on a pattern
    await page.click('[data-testid="pattern-1"]');

    // Verify detail panel appears
    const detailPanel = await page.locator('[data-testid="pattern-detail"]');
    await expect(detailPanel).toBeVisible();
    await expect(detailPanel).toContainText('confidence');
    await expect(detailPanel).toContainText('Historical Accuracy');
  });

  test('should receive real-time pattern updates', async ({ page }) => {
    await page.goto('/stocks/AAPL');

    // Mock WebSocket message
    await page.evaluate(() => {
      const ws = new WebSocket('ws://localhost:8000/ws/patterns/AAPL');
      ws.onopen = () => {
        ws.send(JSON.stringify({
          patterns: [{
            pattern_id: 'new-1',
            pattern_type: 'Triangle',
            confidence: 0.88,
          }],
          is_new: true,
        }));
      };
    });

    // Verify notification appears
    await expect(page.locator('.notification')).toContainText('New Pattern Detected');
  });
});
```

---

## Risk Assessment

| Risk | Severity | Probability | Mitigation |
|------|----------|-------------|------------|
| Model inference latency exceeds 500ms | High | Medium | Implement aggressive caching, use model optimization (quantization, pruning), batch inference |
| WebSocket connection instability | Medium | Medium | Add connection pooling, exponential backoff retry, fallback to polling |
| False positive pattern detections | High | High | Implement confidence threshold filtering, add user feedback loop, A/B test model versions |
| Memory leak from real-time updates | Medium | Low | Use WeakMap for component state, implement cleanup in useEffect, monitor memory usage |
| API rate limiting from external services | Low | Medium | Implement request queuing, use circuit breaker pattern, add rate limit headers |
| Visualization performance degradation with many patterns | Medium | Medium | Implement canvas virtualization, limit max rendered patterns, use progressive rendering |
| Browser compatibility issues (Safari, mobile) | Low | Medium | Use polyfills for WebSocket, test on multiple browsers, graceful degradation |

---

## Performance Requirements

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| Pattern detection API response time | < 200ms (p95) | APM monitoring (Datadog/New Relic) |
| WebSocket message delivery latency | < 100ms | Custom WebSocket middleware logging |
| Chart rendering with patterns | < 500ms for 10 patterns | Chrome DevTools Performance profiling |
| Cache hit rate | > 85% | Redis monitoring dashboard |
| Model inference time | < 100ms per stock | ML model performance metrics |
| Frontend bundle size impact | < 50KB gzipped | Webpack bundle analyzer |
| Concurrent WebSocket connections | Support 10,000+ users | Load testing with k6/Locust |
| Memory usage per chart instance | < 50MB | Chrome DevTools Memory profiler |

---

## Security Considerations

### Authentication & Authorization
- All API endpoints require valid JWT authentication
- Pattern alert creation limited to authenticated users
- WebSocket connections validate token on connect
- Rate limiting: 100 requests/minute per user

### Input Validation
```python
from pydantic import BaseModel, Field, validator

class PatternQueryParams(BaseModel):
    stock_code: str = Field(..., regex="^[A-Z0-9]{1,10}$")
    timeframe: str = Field("1D", regex="^(1D|1W|1M)$")
    min_confidence: float = Field(0.7, ge=0.0, le=1.0)

    @validator('stock_code')
    def validate_stock_code(cls, v):
        # Prevent SQL injection, validate against known symbols
        if not v.isalnum():
            raise ValueError("Invalid stock code format")
        return v.upper()
```

### Data Privacy
- Pattern detection data cached without user PII
- Alert configurations stored encrypted at rest
- WebSocket messages do not contain sensitive user data
- Audit logging for all alert configurations

### API Security
- CORS restricted to known frontend domains
- WebSocket origin validation
- SQL injection prevention via parameterized queries
- XSS prevention via output sanitization

---

## Error Handling

### Backend Error Handling

```python
# src/services/pattern_recognition_service.py
from src.core.exceptions import (
    PatternDetectionError,
    ModelLoadError,
    CacheError
)
from src.core.logging import get_logger

logger = get_logger(__name__)

class PatternRecognitionService:
    async def get_patterns(
        self,
        stock_code: str,
        timeframe: str = "1D",
        min_confidence: float = 0.7
    ) -> List[Dict]:
        """Retrieve detected patterns with comprehensive error handling"""
        try:
            cache_key = f"patterns:{stock_code}:{timeframe}"

            # Try cache first
            try:
                cached = await self.cache.get(cache_key)
                if cached:
                    return self._filter_by_confidence(cached, min_confidence)
            except CacheError as e:
                logger.warning(f"Cache retrieval failed, continuing without cache: {e}")
                # Continue without cache

            # Detect patterns
            try:
                patterns = await self.detector.detect(
                    stock_code=stock_code,
                    timeframe=timeframe
                )
            except ModelLoadError as e:
                logger.error(f"Model loading failed: {e}", exc_info=True)
                raise PatternDetectionError(
                    f"Pattern detection unavailable for {stock_code}"
                ) from e
            except Exception as e:
                logger.error(f"Pattern detection failed: {e}", exc_info=True)
                # Return empty list instead of failing
                return []

            # Cache result (best effort)
            try:
                await self.cache.set(cache_key, patterns, ttl=300)
            except CacheError as e:
                logger.warning(f"Cache storage failed: {e}")

            return self._filter_by_confidence(patterns, min_confidence)

        except PatternDetectionError:
            raise  # Re-raise known errors
        except Exception as e:
            logger.error(f"Unexpected error in get_patterns: {e}", exc_info=True)
            raise PatternDetectionError(
                f"Failed to retrieve patterns for {stock_code}"
            ) from e
```

### Frontend Error Handling

```typescript
// src/hooks/usePatternData.ts
import { useState, useEffect } from 'react';
import { useToast } from '@/hooks/useToast';

interface UsePatternDataOptions {
  stockCode: string;
  timeframe: string;
  retryCount?: number;
  retryDelay?: number;
}

export const usePatternData = ({
  stockCode,
  timeframe,
  retryCount = 3,
  retryDelay = 1000,
}: UsePatternDataOptions) => {
  const [patterns, setPatterns] = useState<Pattern[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const { showToast } = useToast();

  useEffect(() => {
    let isMounted = true;
    let retries = 0;

    const fetchPatterns = async () => {
      try {
        setLoading(true);
        setError(null);

        const response = await fetch(
          `/v1/ai/patterns/${stockCode}?timeframe=${timeframe}`,
          {
            headers: {
              'Authorization': `Bearer ${getAuthToken()}`,
            },
            signal: AbortSignal.timeout(5000), // 5s timeout
          }
        );

        if (!response.ok) {
          if (response.status === 429) {
            throw new Error('Rate limit exceeded. Please try again later.');
          } else if (response.status === 503) {
            throw new Error('Pattern detection service temporarily unavailable.');
          } else {
            throw new Error(`Failed to fetch patterns: ${response.statusText}`);
          }
        }

        const data = await response.json();

        if (isMounted) {
          setPatterns(data);
          setLoading(false);
        }
      } catch (err) {
        if (!isMounted) return;

        const error = err as Error;
        console.error('Pattern fetch error:', error);

        // Retry logic
        if (retries < retryCount && error.name !== 'AbortError') {
          retries++;
          console.log(`Retrying... (${retries}/${retryCount})`);
          setTimeout(fetchPatterns, retryDelay * retries);
          return;
        }

        setError(error);
        setLoading(false);

        showToast({
          title: 'Pattern Detection Error',
          message: error.message,
          type: 'error',
          duration: 5000,
        });

        // Fallback to empty patterns
        setPatterns([]);
      }
    };

    fetchPatterns();

    return () => {
      isMounted = false;
    };
  }, [stockCode, timeframe, retryCount, retryDelay]);

  return { patterns, loading, error, refetch: () => {} };
};
```

### WebSocket Error Handling

```typescript
// src/hooks/useWebSocket.ts
import { useEffect, useRef, useState } from 'react';

interface UseWebSocketOptions {
  url: string;
  reconnect?: boolean;
  maxReconnectAttempts?: number;
  reconnectInterval?: number;
}

export const useWebSocket = ({
  url,
  reconnect = true,
  maxReconnectAttempts = 5,
  reconnectInterval = 3000,
}: UseWebSocketOptions) => {
  const [data, setData] = useState<any>(null);
  const [error, setError] = useState<Event | null>(null);
  const [connected, setConnected] = useState(false);
  const wsRef = useRef<WebSocket | null>(null);
  const reconnectAttemptsRef = useRef(0);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();

  useEffect(() => {
    const connect = () => {
      try {
        const ws = new WebSocket(url);

        ws.onopen = () => {
          console.log('WebSocket connected');
          setConnected(true);
          setError(null);
          reconnectAttemptsRef.current = 0;
        };

        ws.onmessage = (event) => {
          try {
            const parsedData = JSON.parse(event.data);
            setData(parsedData);
          } catch (err) {
            console.error('Failed to parse WebSocket message:', err);
          }
        };

        ws.onerror = (event) => {
          console.error('WebSocket error:', event);
          setError(event);
        };

        ws.onclose = (event) => {
          console.log('WebSocket closed:', event.code, event.reason);
          setConnected(false);
          wsRef.current = null;

          // Reconnect logic
          if (reconnect && reconnectAttemptsRef.current < maxReconnectAttempts) {
            reconnectAttemptsRef.current++;
            const delay = reconnectInterval * reconnectAttemptsRef.current;
            console.log(`Reconnecting in ${delay}ms... (${reconnectAttemptsRef.current}/${maxReconnectAttempts})`);

            reconnectTimeoutRef.current = setTimeout(() => {
              connect();
            }, delay);
          } else if (reconnectAttemptsRef.current >= maxReconnectAttempts) {
            console.error('Max reconnect attempts reached');
            setError(new Event('Max reconnection attempts exceeded'));
          }
        };

        wsRef.current = ws;
      } catch (err) {
        console.error('Failed to create WebSocket:', err);
        setError(err as Event);
      }
    };

    connect();

    return () => {
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
      }
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, [url, reconnect, maxReconnectAttempts, reconnectInterval]);

  return { data, error, connected };
};
```

---

## Notes

### Technical Decisions
- **WebSocket vs Polling**: Chose WebSocket for real-time updates due to lower latency and reduced server load
- **Canvas vs SVG**: Using SVG for pattern overlays for better scalability and easier interaction handling
- **Caching Strategy**: Redis for distributed caching with 5-minute TTL balances freshness and performance
- **Model Serving**: Load model once at service startup, use batch inference for efficiency

### Future Enhancements
- Add pattern backtesting tool to validate historical accuracy
- Implement pattern combination detection (e.g., "Head and Shoulders + RSI divergence")
- Add machine learning-based pattern confidence calibration
- Support custom pattern definition via UI
- Multi-timeframe pattern correlation analysis
- Pattern performance leaderboard

### Dependencies
- **Backend**: FastAPI, Redis, WebSocket library (websockets/python-socketio), ML model from AI-003a
- **Frontend**: React, Konva.js for canvas rendering, SWR for data fetching, WebSocket client
- **Infrastructure**: Redis for caching, Message queue for alert processing

### Open Questions
- [ ] Should we support pattern detection on intraday timeframes (5min, 15min)?
- [ ] How to handle pattern detection for low-volume stocks with sparse data?
- [ ] Should alerts support complex conditions (e.g., "Pattern A AND Volume > X")?
- [ ] What's the retention policy for historical pattern data?

---

## Dependencies

- **AI-003a**: Chart Pattern Recognition - Data & Model (MUST be completed first)

## References

- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 1: AI/Machine Learning Features
- [Technical Analysis Patterns Documentation](https://school.stockcharts.com/doku.php?id=chart_analysis:chart_patterns)
- [WebSocket API Best Practices](https://ably.com/topic/websocket-best-practices)
