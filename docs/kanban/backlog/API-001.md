# API-001: Public API Infrastructure

## Metadata

| Field | Value |
|-------|-------|
| **ID** | API-001 |
| **Title** | Setup Public API Infrastructure |
| **Type** | Infrastructure |
| **Status** | BACKLOG |
| **Priority** | P1 (High) |
| **Estimate** | 12 hours |
| **Sprint** | Sprint 7 |
| **Epic** | Developer API |
| **Assignee** | TBD |
| **Created** | 2025-11-29 |
| **Tags** | `api`, `oauth`, `rate-limiting`, `api-gateway`, `authentication` |
| **Blocks** | API-002, API-003, API-004, API-005 |

## Description

Build a comprehensive Public API infrastructure to enable external developers to integrate with the screener system. This includes API key management, tiered rate limiting, request/response logging, usage monitoring, and optional API gateway integration.

The infrastructure will support three service tiers (Free, Pro, Enterprise) with different rate limits and features, providing a foundation for the developer ecosystem and potential revenue stream.

## Subtasks

- [ ] **API Key Management System**
  - [ ] Design API key schema (key, secret, tier, created_at, expires_at)
  - [ ] Implement API key generation with cryptographically secure random strings
  - [ ] Create API key CRUD endpoints for user dashboard
  - [ ] Add API key rotation functionality
  - [ ] Implement key expiration and automatic renewal
  - [ ] Add support for multiple keys per user (dev, staging, prod)
- [ ] **Authentication Middleware**
  - [ ] Implement API key validation middleware
  - [ ] Add support for Bearer token authentication
  - [ ] Create OAuth 2.0 integration for third-party apps
  - [ ] Implement HMAC signature verification for sensitive operations
  - [ ] Add IP whitelist functionality for enterprise tier
- [ ] **Rate Limiting System**
  - [ ] Implement tiered rate limiting (per-minute and per-day)
  - [ ] Create Redis-based rate limit counters
  - [ ] Add rate limit headers (X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset)
  - [ ] Implement burst allowance for short spikes
  - [ ] Create rate limit exceeded error responses (429 Too Many Requests)
  - [ ] Add rate limit bypass for internal services
- [ ] **Request/Response Logging**
  - [ ] Design logging schema (endpoint, method, status, latency, user_id, api_key_id)
  - [ ] Implement structured logging with correlation IDs
  - [ ] Add request/response body logging (configurable, exclude sensitive data)
  - [ ] Create log rotation and archival strategy
  - [ ] Implement PII redaction in logs
- [ ] **Usage Monitoring Dashboard**
  - [ ] Create API usage analytics database tables
  - [ ] Implement real-time usage tracking
  - [ ] Build dashboard UI showing requests, errors, latency
  - [ ] Add graphs for daily/weekly/monthly usage trends
  - [ ] Create alerts for approaching rate limits
  - [ ] Implement usage export for billing purposes
- [ ] **API Gateway (Optional)**
  - [ ] Evaluate API Gateway solutions (Kong, AWS API Gateway, Tyk)
  - [ ] Configure gateway routing rules
  - [ ] Setup gateway-level rate limiting
  - [ ] Implement request transformation
  - [ ] Add gateway monitoring and analytics
- [ ] **Documentation & Testing**
  - [ ] Document API key management flows
  - [ ] Create onboarding guide for developers
  - [ ] Write integration tests for authentication
  - [ ] Load test rate limiting system
  - [ ] Document security best practices

## Implementation Details

### API Key Schema (PostgreSQL)

```sql
-- API Keys table
CREATE TABLE api_keys (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,  -- User-defined name (e.g., "Production Key")
    key_prefix VARCHAR(20) NOT NULL,  -- First 8 chars for identification (e.g., "sk_live_")
    key_hash VARCHAR(255) NOT NULL,  -- Bcrypt hash of full key
    tier VARCHAR(20) NOT NULL CHECK (tier IN ('free', 'pro', 'enterprise')),
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW(),
    last_used_at TIMESTAMP,
    expires_at TIMESTAMP,
    metadata JSONB DEFAULT '{}',  -- Custom metadata, IP whitelist, etc.
    UNIQUE(key_hash),
    INDEX idx_api_keys_user_id (user_id),
    INDEX idx_api_keys_key_prefix (key_prefix)
);

-- API Usage Logs table
CREATE TABLE api_usage_logs (
    id BIGSERIAL PRIMARY KEY,
    api_key_id UUID REFERENCES api_keys(id) ON DELETE SET NULL,
    user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
    endpoint VARCHAR(255) NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    latency_ms INTEGER NOT NULL,
    request_size INTEGER,
    response_size INTEGER,
    ip_address INET,
    user_agent TEXT,
    correlation_id UUID,
    error_message TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    INDEX idx_api_usage_logs_api_key_id (api_key_id),
    INDEX idx_api_usage_logs_created_at (created_at)
) PARTITION BY RANGE (created_at);

-- Create monthly partitions for logs
CREATE TABLE api_usage_logs_2025_12 PARTITION OF api_usage_logs
FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');
```

### API Key Management (Python/FastAPI)

```python
import secrets
import hashlib
import bcrypt
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from typing import List, Optional
from pydantic import BaseModel

router = APIRouter(prefix="/api/v1/api-keys", tags=["API Keys"])

class APIKeyCreate(BaseModel):
    name: str
    tier: str = "free"
    expires_in_days: Optional[int] = 365

class APIKeyResponse(BaseModel):
    id: str
    name: str
    key_prefix: str
    tier: str
    is_active: bool
    created_at: datetime
    expires_at: Optional[datetime]
    last_used_at: Optional[datetime]

class APIKeyWithSecret(APIKeyResponse):
    api_key: str  # Only returned on creation

class APIKeyManager:
    """Manage API key lifecycle"""

    @staticmethod
    def generate_api_key(prefix: str = "sk_live_") -> tuple[str, str]:
        """
        Generate a new API key with prefix and random secure string

        Returns:
            Tuple of (full_key, key_hash)
        """
        # Generate 32-byte random string
        random_part = secrets.token_urlsafe(32)
        full_key = f"{prefix}{random_part}"

        # Hash the key for storage
        key_hash = bcrypt.hashpw(full_key.encode(), bcrypt.gensalt()).decode()

        return full_key, key_hash

    @staticmethod
    def verify_api_key(provided_key: str, stored_hash: str) -> bool:
        """Verify provided API key against stored hash"""
        return bcrypt.checkpw(provided_key.encode(), stored_hash.encode())

    @staticmethod
    def extract_prefix(api_key: str) -> str:
        """Extract first 8 characters for identification"""
        return api_key[:16] if len(api_key) > 16 else api_key

@router.post("/", response_model=APIKeyWithSecret, status_code=status.HTTP_201_CREATED)
async def create_api_key(
    key_data: APIKeyCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new API key for the authenticated user"""

    # Check tier limits
    existing_keys = db.query(APIKey).filter(
        APIKey.user_id == current_user.id,
        APIKey.is_active == True
    ).count()

    max_keys = {"free": 1, "pro": 3, "enterprise": 10}
    if existing_keys >= max_keys.get(key_data.tier, 1):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Maximum {max_keys[key_data.tier]} active keys allowed for {key_data.tier} tier"
        )

    # Generate API key
    prefix = f"sk_{key_data.tier[:4]}_"
    full_key, key_hash = APIKeyManager.generate_api_key(prefix)
    key_prefix = APIKeyManager.extract_prefix(full_key)

    # Calculate expiration
    expires_at = None
    if key_data.expires_in_days:
        expires_at = datetime.utcnow() + timedelta(days=key_data.expires_in_days)

    # Create database record
    api_key = APIKey(
        user_id=current_user.id,
        name=key_data.name,
        key_prefix=key_prefix,
        key_hash=key_hash,
        tier=key_data.tier,
        expires_at=expires_at
    )
    db.add(api_key)
    db.commit()
    db.refresh(api_key)

    # Return key only once (never stored in plain text)
    return APIKeyWithSecret(
        **api_key.__dict__,
        api_key=full_key
    )

@router.get("/", response_model=List[APIKeyResponse])
async def list_api_keys(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """List all API keys for the authenticated user"""
    keys = db.query(APIKey).filter(APIKey.user_id == current_user.id).all()
    return keys

@router.delete("/{key_id}")
async def revoke_api_key(
    key_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Revoke (deactivate) an API key"""
    api_key = db.query(APIKey).filter(
        APIKey.id == key_id,
        APIKey.user_id == current_user.id
    ).first()

    if not api_key:
        raise HTTPException(status_code=404, detail="API key not found")

    api_key.is_active = False
    db.commit()

    return {"message": "API key revoked successfully"}

@router.post("/{key_id}/rotate", response_model=APIKeyWithSecret)
async def rotate_api_key(
    key_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Rotate an existing API key (generate new key, revoke old)"""
    old_key = db.query(APIKey).filter(
        APIKey.id == key_id,
        APIKey.user_id == current_user.id
    ).first()

    if not old_key:
        raise HTTPException(status_code=404, detail="API key not found")

    # Generate new key
    prefix = f"sk_{old_key.tier[:4]}_"
    full_key, key_hash = APIKeyManager.generate_api_key(prefix)
    key_prefix = APIKeyManager.extract_prefix(full_key)

    # Update existing record
    old_key.key_prefix = key_prefix
    old_key.key_hash = key_hash
    old_key.created_at = datetime.utcnow()
    old_key.last_used_at = None

    db.commit()
    db.refresh(old_key)

    return APIKeyWithSecret(
        **old_key.__dict__,
        api_key=full_key
    )
```

### Rate Limiting Middleware (Python/FastAPI + Redis)

```python
import redis
from fastapi import Request, HTTPException, status
from starlette.middleware.base import BaseHTTPMiddleware
from datetime import datetime
from typing import Dict

# Rate limits by tier
RATE_LIMITS: Dict[str, Dict[str, int]] = {
    "free": {
        "requests_per_minute": 10,
        "requests_per_day": 100
    },
    "pro": {
        "requests_per_minute": 100,
        "requests_per_day": 10000
    },
    "enterprise": {
        "requests_per_minute": 1000,
        "requests_per_day": -1  # Unlimited
    }
}

class RateLimitMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, redis_client: redis.Redis):
        super().__init__(app)
        self.redis = redis_client

    async def dispatch(self, request: Request, call_next):
        # Skip rate limiting for public endpoints
        if request.url.path.startswith("/api/v1/public"):
            # Extract API key from header
            api_key = request.headers.get("X-API-Key") or \
                     request.headers.get("Authorization", "").replace("Bearer ", "")

            if not api_key:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="API key required"
                )

            # Verify and get tier
            api_key_data = await self.verify_api_key(api_key, request.app.state.db)
            if not api_key_data:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Invalid API key"
                )

            tier = api_key_data["tier"]
            limits = RATE_LIMITS.get(tier, RATE_LIMITS["free"])

            # Check rate limits
            await self.check_rate_limit(
                api_key_data["id"],
                limits,
                request
            )

            # Add user info to request state
            request.state.api_key_id = api_key_data["id"]
            request.state.user_id = api_key_data["user_id"]
            request.state.tier = tier

        response = await call_next(request)
        return response

    async def check_rate_limit(
        self,
        api_key_id: str,
        limits: Dict[str, int],
        request: Request
    ):
        """Check if request exceeds rate limits"""
        now = datetime.utcnow()
        minute_key = f"ratelimit:{api_key_id}:minute:{now.strftime('%Y%m%d%H%M')}"
        day_key = f"ratelimit:{api_key_id}:day:{now.strftime('%Y%m%d')}"

        # Increment counters
        minute_count = self.redis.incr(minute_key)
        day_count = self.redis.incr(day_key)

        # Set expiration on first request
        if minute_count == 1:
            self.redis.expire(minute_key, 60)  # Expire after 60 seconds
        if day_count == 1:
            self.redis.expire(day_key, 86400)  # Expire after 24 hours

        # Check limits
        minute_limit = limits["requests_per_minute"]
        day_limit = limits["requests_per_day"]

        if minute_count > minute_limit:
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail="Rate limit exceeded (per minute)",
                headers={
                    "X-RateLimit-Limit": str(minute_limit),
                    "X-RateLimit-Remaining": "0",
                    "X-RateLimit-Reset": str(int(now.timestamp()) + 60)
                }
            )

        if day_limit > 0 and day_count > day_limit:
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail="Rate limit exceeded (per day)",
                headers={
                    "X-RateLimit-Limit": str(day_limit),
                    "X-RateLimit-Remaining": "0",
                    "X-RateLimit-Reset": str(int(now.timestamp()) + 86400)
                }
            )

        # Add rate limit headers to response
        request.state.rate_limit_headers = {
            "X-RateLimit-Limit-Minute": str(minute_limit),
            "X-RateLimit-Remaining-Minute": str(minute_limit - minute_count),
            "X-RateLimit-Limit-Day": str(day_limit) if day_limit > 0 else "unlimited",
            "X-RateLimit-Remaining-Day": str(day_limit - day_count) if day_limit > 0 else "unlimited"
        }

    async def verify_api_key(self, api_key: str, db: Session) -> Optional[Dict]:
        """Verify API key and return key data"""
        # Extract prefix for quick lookup
        prefix = api_key[:16]

        # Query database
        db_key = db.query(APIKey).filter(
            APIKey.key_prefix == prefix,
            APIKey.is_active == True
        ).first()

        if not db_key:
            return None

        # Verify full key
        if not APIKeyManager.verify_api_key(api_key, db_key.key_hash):
            return None

        # Check expiration
        if db_key.expires_at and db_key.expires_at < datetime.utcnow():
            return None

        # Update last used
        db_key.last_used_at = datetime.utcnow()
        db.commit()

        return {
            "id": str(db_key.id),
            "user_id": db_key.user_id,
            "tier": db_key.tier
        }
```

### Usage Monitoring Dashboard (React)

```typescript
import React, { useEffect, useState } from 'react';
import { Line, Bar } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  Title,
  Tooltip,
  Legend
} from 'chart.js';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  Title,
  Tooltip,
  Legend
);

interface UsageStats {
  total_requests: number;
  successful_requests: number;
  failed_requests: number;
  avg_latency_ms: number;
  requests_by_hour: Array<{ hour: string; count: number }>;
  requests_by_endpoint: Array<{ endpoint: string; count: number }>;
  rate_limit_hits: number;
}

const APIUsageDashboard: React.FC = () => {
  const [stats, setStats] = useState<UsageStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [period, setPeriod] = useState<'24h' | '7d' | '30d'>('24h');

  useEffect(() => {
    fetchUsageStats();
  }, [period]);

  const fetchUsageStats = async () => {
    setLoading(true);
    try {
      const response = await fetch(`/api/v1/api-keys/usage?period=${period}`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });
      const data = await response.json();
      setStats(data);
    } catch (error) {
      console.error('Failed to fetch usage stats:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading || !stats) {
    return <div>Loading...</div>;
  }

  const requestsOverTimeData = {
    labels: stats.requests_by_hour.map(d => d.hour),
    datasets: [
      {
        label: 'Requests',
        data: stats.requests_by_hour.map(d => d.count),
        borderColor: 'rgb(75, 192, 192)',
        backgroundColor: 'rgba(75, 192, 192, 0.2)',
      }
    ]
  };

  const requestsByEndpointData = {
    labels: stats.requests_by_endpoint.map(d => d.endpoint),
    datasets: [
      {
        label: 'Requests by Endpoint',
        data: stats.requests_by_endpoint.map(d => d.count),
        backgroundColor: 'rgba(54, 162, 235, 0.6)',
      }
    ]
  };

  return (
    <div className="api-usage-dashboard">
      <h2>API Usage Dashboard</h2>

      <div className="period-selector">
        <button onClick={() => setPeriod('24h')} className={period === '24h' ? 'active' : ''}>
          Last 24 Hours
        </button>
        <button onClick={() => setPeriod('7d')} className={period === '7d' ? 'active' : ''}>
          Last 7 Days
        </button>
        <button onClick={() => setPeriod('30d')} className={period === '30d' ? 'active' : ''}>
          Last 30 Days
        </button>
      </div>

      <div className="stats-grid">
        <div className="stat-card">
          <h3>Total Requests</h3>
          <p className="stat-value">{stats.total_requests.toLocaleString()}</p>
        </div>
        <div className="stat-card">
          <h3>Success Rate</h3>
          <p className="stat-value">
            {((stats.successful_requests / stats.total_requests) * 100).toFixed(2)}%
          </p>
        </div>
        <div className="stat-card">
          <h3>Avg Latency</h3>
          <p className="stat-value">{stats.avg_latency_ms}ms</p>
        </div>
        <div className="stat-card">
          <h3>Rate Limit Hits</h3>
          <p className="stat-value">{stats.rate_limit_hits}</p>
        </div>
      </div>

      <div className="charts">
        <div className="chart-container">
          <h3>Requests Over Time</h3>
          <Line data={requestsOverTimeData} />
        </div>

        <div className="chart-container">
          <h3>Requests by Endpoint</h3>
          <Bar data={requestsByEndpointData} />
        </div>
      </div>
    </div>
  );
};

export default APIUsageDashboard;
```

## Rate Limits by Tier

| Tier | Requests/Day | Requests/Minute | Price | Features |
|------|--------------|-----------------|-------|----------|
| Free | 100 | 10 | $0 | Basic endpoints, standard support |
| Pro | 10,000 | 100 | $29/month | All endpoints, priority support, webhooks |
| Enterprise | Unlimited | 1,000 | $299/month | All features, dedicated support, SLA, IP whitelist |

## Testing Strategy

### Unit Tests

```python
import pytest
from fastapi.testclient import TestClient
from unittest.mock import Mock, patch

def test_api_key_generation():
    """Test API key generation produces valid format"""
    full_key, key_hash = APIKeyManager.generate_api_key("sk_test_")

    assert full_key.startswith("sk_test_")
    assert len(full_key) > 40  # Prefix + 32 bytes base64
    assert key_hash.startswith("$2b$")  # Bcrypt hash

def test_api_key_verification():
    """Test API key verification works correctly"""
    full_key, key_hash = APIKeyManager.generate_api_key()

    # Valid key should verify
    assert APIKeyManager.verify_api_key(full_key, key_hash) is True

    # Invalid key should not verify
    assert APIKeyManager.verify_api_key("invalid_key", key_hash) is False

def test_rate_limit_enforcement(client: TestClient, redis_mock):
    """Test rate limiting blocks excessive requests"""
    api_key = "sk_free_test123"

    # Make requests up to limit
    for i in range(10):
        response = client.get(
            "/api/v1/public/stocks",
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 200

    # 11th request should be rate limited
    response = client.get(
        "/api/v1/public/stocks",
        headers={"X-API-Key": api_key}
    )
    assert response.status_code == 429
    assert "Rate limit exceeded" in response.json()["detail"]

def test_api_key_expiration():
    """Test expired API keys are rejected"""
    # Create expired key
    expired_key = APIKey(
        user_id=1,
        name="Expired Key",
        tier="free",
        expires_at=datetime.utcnow() - timedelta(days=1)
    )

    # Should not verify
    assert await verify_api_key(expired_key.full_key, db) is None
```

### Integration Tests

```python
def test_full_api_key_lifecycle(client: TestClient, db: Session):
    """Test complete API key creation, usage, rotation, and revocation"""
    # Create API key
    response = client.post(
        "/api/v1/api-keys/",
        json={"name": "Test Key", "tier": "pro"},
        headers={"Authorization": f"Bearer {auth_token}"}
    )
    assert response.status_code == 201
    api_key = response.json()["api_key"]

    # Use API key
    response = client.get(
        "/api/v1/public/stocks",
        headers={"X-API-Key": api_key}
    )
    assert response.status_code == 200

    # Rotate API key
    response = client.post(
        f"/api/v1/api-keys/{api_key_id}/rotate",
        headers={"Authorization": f"Bearer {auth_token}"}
    )
    assert response.status_code == 200
    new_api_key = response.json()["api_key"]

    # Old key should not work
    response = client.get(
        "/api/v1/public/stocks",
        headers={"X-API-Key": api_key}
    )
    assert response.status_code == 401

    # New key should work
    response = client.get(
        "/api/v1/public/stocks",
        headers={"X-API-Key": new_api_key}
    )
    assert response.status_code == 200

    # Revoke key
    response = client.delete(
        f"/api/v1/api-keys/{api_key_id}",
        headers={"Authorization": f"Bearer {auth_token}"}
    )
    assert response.status_code == 200

    # Revoked key should not work
    response = client.get(
        "/api/v1/public/stocks",
        headers={"X-API-Key": new_api_key}
    )
    assert response.status_code == 401
```

## Acceptance Criteria

- [ ] API Key issuance system with secure generation and storage
- [ ] API Key management dashboard with create, list, rotate, revoke
- [ ] Rate limiting implemented for all three tiers (tiered)
- [ ] API version management (v1) with proper routing
- [ ] Request/response logging with correlation IDs
- [ ] Usage monitoring dashboard with real-time analytics
- [ ] API Gateway configuration completed (if selected)
- [ ] OAuth 2.0 support for third-party integrations
- [ ] IP whitelist functionality for enterprise customers
- [ ] Comprehensive documentation for developers

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Rate limiting bypass attempts | Medium | High | Implement multiple rate limit strategies (IP + key), add anomaly detection, use Redis distributed locks |
| API key leakage | Medium | High | Implement key rotation, add usage alerts, provide key scanning tools, educate users on security |
| Database performance with logging | High | Medium | Use partitioned tables, implement async logging, add retention policy, consider separate logging DB |
| Redis failure affecting rate limits | Low | High | Implement Redis cluster, add fallback to in-memory limits, monitor Redis health |
| Tier upgrade/downgrade edge cases | Medium | Low | Implement graceful tier transitions, add buffer period, clear communication |
| DDoS attacks via free tier | Medium | Medium | Add CAPTCHA for signups, implement IP-based rate limits, monitor for abuse patterns |

## Performance Requirements

- **API Key Verification**: < 10ms per request
- **Rate Limit Check**: < 5ms per request (Redis lookup)
- **Dashboard Load Time**: < 2 seconds for 30-day data
- **Log Insertion**: < 1ms (async, non-blocking)
- **Usage Query**: < 500ms for aggregated statistics
- **API Key Generation**: < 100ms

## Security Considerations

- **Key Storage**: Never store API keys in plain text; use bcrypt hashing
- **Key Transmission**: Only show full key once upon creation; use HTTPS only
- **Key Rotation**: Implement automated rotation reminders and easy rotation flow
- **Access Control**: Ensure users can only manage their own API keys
- **Audit Logging**: Log all API key operations (create, rotate, revoke)
- **Rate Limiting**: Prevent abuse and ensure fair usage across tiers
- **CORS Configuration**: Properly configure CORS for browser-based API calls
- **SQL Injection**: Use parameterized queries for all database operations
- **PII Protection**: Redact sensitive data from logs and monitoring

## Error Handling

```python
class APIKeyError(Exception):
    """Base exception for API key errors"""
    pass

class InvalidAPIKeyError(APIKeyError):
    """Raised when API key is invalid or malformed"""
    pass

class ExpiredAPIKeyError(APIKeyError):
    """Raised when API key has expired"""
    pass

class RateLimitExceededError(APIKeyError):
    """Raised when rate limit is exceeded"""
    pass

@app.exception_handler(InvalidAPIKeyError)
async def invalid_api_key_handler(request: Request, exc: InvalidAPIKeyError):
    return JSONResponse(
        status_code=status.HTTP_401_UNAUTHORIZED,
        content={
            "error": "invalid_api_key",
            "message": str(exc),
            "documentation": "https://docs.thescreener.com/api/authentication"
        }
    )

@app.exception_handler(RateLimitExceededError)
async def rate_limit_handler(request: Request, exc: RateLimitExceededError):
    return JSONResponse(
        status_code=status.HTTP_429_TOO_MANY_REQUESTS,
        content={
            "error": "rate_limit_exceeded",
            "message": str(exc),
            "retry_after": 60,
            "upgrade_url": "https://thescreener.com/pricing"
        },
        headers={
            "Retry-After": "60",
            "X-RateLimit-Limit": request.state.rate_limit_limit,
            "X-RateLimit-Remaining": "0",
            "X-RateLimit-Reset": str(int(datetime.utcnow().timestamp()) + 60)
        }
    )
```

## Dependencies

- **Technical**: FastAPI >= 0.104.0, redis >= 4.5.0, bcrypt >= 4.0.0, SQLAlchemy >= 2.0.0
- **Infrastructure**: Redis for rate limiting, PostgreSQL for key storage
- **External**: None (optional: OAuth provider for third-party auth)
- **Blocked By**: None
- **Blocks**: API-002 (Public API Endpoints), API-003 (Documentation Portal), API-004 (Python SDK), API-005 (JavaScript SDK)

## Notes

- Consider implementing API key scopes for fine-grained permissions
- Plan for webhook delivery system (retry logic, failure handling)
- Add support for test mode API keys that don't count towards quotas
- Consider implementing GraphQL introspection limits for security
- Document common error scenarios and resolutions
- Plan for future features: API key IP restrictions, custom rate limits
- Implement usage-based billing integration for pro/enterprise tiers
- Add API health status page for transparency

## Progress

**Status**: 0% - Not started

**Next Steps**:
1. Design and implement API key database schema
2. Create API key generation and verification logic with bcrypt
3. Implement API key management endpoints (CRUD)
4. Setup Redis for rate limiting counters

## References

- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 6: Developer API
- [FastAPI Security Documentation](https://fastapi.tiangolo.com/tutorial/security/)
- [OAuth 2.0 Specification](https://oauth.net/2/)
- [API Rate Limiting Best Practices](https://cloud.google.com/architecture/rate-limiting-strategies-techniques)
- [OWASP API Security Top 10](https://owasp.org/www-project-api-security/)
