# API-002: Public API Endpoints

## Metadata

| Field | Value |
|-------|-------|
| **ID** | API-002 |
| **Title** | Implement Public API Endpoints |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P1 (High) |
| **Estimate** | 16 hours |
| **Sprint** | Sprint 7 |
| **Epic** | Developer API |
| **Assignee** | TBD |
| **Depends On** | API-001 |
| **Blocks** | API-003, API-004, API-005 |
| **Tags** | `api`, `rest`, `backend`, `public-api`, `versioning` |
| **Created** | 2025-11-29 |
| **Updated** | 2025-11-30 |

## Description

Implement comprehensive Public API endpoints for external developers to access stock market data, run screenings, and receive real-time updates through webhooks. This API will serve as the foundation for developer integrations and SDKs.

The API must be:
- **RESTful** - Follow REST conventions and HTTP standards
- **Versioned** - Support multiple API versions simultaneously
- **Paginated** - Handle large datasets efficiently
- **Filtered** - Allow flexible query parameters
- **Secure** - Implement API key authentication and rate limiting
- **Well-documented** - Generate OpenAPI 3.0 specifications

## Subtasks

### 1. Stock Data Endpoints
- [ ] **GET /api/v1/public/stocks** - List all stocks
  - [ ] Implement pagination (limit, offset)
  - [ ] Add filtering (market, sector, price_range)
  - [ ] Add sorting (market_cap, volume, price)
  - [ ] Return stock summary data
  - [ ] Test with 1000+ stocks
- [ ] **GET /api/v1/public/stocks/{code}** - Get stock details
  - [ ] Return comprehensive stock information
  - [ ] Include current price and statistics
  - [ ] Handle invalid stock codes (404)
  - [ ] Add caching headers (ETag, Last-Modified)
- [ ] **GET /api/v1/public/stocks/{code}/prices** - Get price history
  - [ ] Support date range filtering (start_date, end_date)
  - [ ] Support interval selection (1d, 1w, 1m)
  - [ ] Return OHLCV data
  - [ ] Limit to 5000 data points per request
- [ ] **GET /api/v1/public/stocks/{code}/indicators** - Get technical indicators
  - [ ] Support indicator selection (sma, ema, rsi, macd)
  - [ ] Support parameter customization
  - [ ] Cache calculated indicators
  - [ ] Return indicator metadata
- [ ] **GET /api/v1/public/stocks/{code}/financials** - Get financial statements
  - [ ] Return income statement, balance sheet, cash flow
  - [ ] Support period filtering (quarterly, annual)
  - [ ] Include historical comparisons
  - [ ] Normalize financial data

### 2. Screening Endpoints
- [ ] **POST /api/v1/public/screen** - Execute screening query
  - [ ] Implement filter parser (field, operator, value)
  - [ ] Support multiple filter combinations (AND/OR)
  - [ ] Add result sorting and pagination
  - [ ] Implement query validation
  - [ ] Rate limit to 60 requests/hour
  - [ ] Return screen result with metadata
- [ ] **GET /api/v1/public/screen/filters** - List available filters
  - [ ] Return all filterable fields
  - [ ] Include field metadata (type, range, description)
  - [ ] Group by category (valuation, growth, technical)
  - [ ] Include usage examples

### 3. Market Data Endpoints
- [ ] **GET /api/v1/public/market/indices** - Get market indices
  - [ ] Return major indices (KOSPI, KOSDAQ)
  - [ ] Include index statistics
  - [ ] Support historical data
  - [ ] Cache for 1 minute
- [ ] **GET /api/v1/public/market/sectors** - Get sector information
  - [ ] List all sectors with statistics
  - [ ] Include sector performance metrics
  - [ ] Support sector comparison
  - [ ] Return top performers per sector

### 4. Webhook Endpoints
- [ ] **POST /api/v1/public/webhooks** - Register webhook
  - [ ] Validate webhook URL (must be HTTPS)
  - [ ] Support event type selection
  - [ ] Implement webhook verification
  - [ ] Store webhook configuration
  - [ ] Test webhook delivery
  - [ ] Return webhook ID and secret
- [ ] **GET /api/v1/public/webhooks** - List webhooks
  - [ ] Return user's registered webhooks
  - [ ] Include delivery statistics
  - [ ] Show last triggered time
- [ ] **DELETE /api/v1/public/webhooks/{id}** - Delete webhook
  - [ ] Validate ownership
  - [ ] Cleanup webhook configuration
  - [ ] Return deletion confirmation

### 5. API Infrastructure
- [ ] **Versioning Strategy**
  - [ ] Implement URL versioning (/v1/, /v2/)
  - [ ] Add API-Version header support
  - [ ] Create version routing middleware
  - [ ] Document deprecation policy (6 months notice)
- [ ] **Pagination**
  - [ ] Standardize pagination parameters (limit, offset)
  - [ ] Add cursor-based pagination option
  - [ ] Include pagination metadata in response
  - [ ] Implement max limit (100 items)
- [ ] **Filtering**
  - [ ] Create filter query parser
  - [ ] Support common operators (eq, ne, gt, lt, in, contains)
  - [ ] Add filter validation
  - [ ] Document filter syntax
- [ ] **Error Handling**
  - [ ] Standardize error response format
  - [ ] Implement error codes (4000-4999)
  - [ ] Add detailed error messages
  - [ ] Include error documentation links

### 6. Authentication & Security
- [ ] **API Key Middleware**
  - [ ] Validate API key from header/query
  - [ ] Implement key rotation mechanism
  - [ ] Log authentication attempts
  - [ ] Handle expired keys gracefully
- [ ] **Rate Limiting**
  - [ ] Implement tier-based rate limits
  - [ ] Add rate limit headers (X-RateLimit-*)
  - [ ] Return 429 when limit exceeded
  - [ ] Support rate limit reset

### 7. Documentation & Testing
- [ ] **OpenAPI 3.0 Specification**
  - [ ] Auto-generate from code annotations
  - [ ] Include request/response examples
  - [ ] Document all error codes
  - [ ] Add security schemes
- [ ] **API Testing**
  - [ ] Write integration tests for all endpoints
  - [ ] Test pagination edge cases
  - [ ] Test filter combinations
  - [ ] Test authentication failures
  - [ ] Test rate limiting

## Implementation Details

### Request/Response Schema

**Standard Response Envelope:**
```json
{
  "success": true,
  "data": { /* Payload */ },
  "meta": {
    "timestamp": "2025-11-30T10:30:00Z",
    "api_version": "v1",
    "request_id": "req_abc123"
  },
  "pagination": {
    "limit": 20,
    "offset": 0,
    "total": 150,
    "has_more": true
  }
}
```

**Error Response Format:**
```json
{
  "success": false,
  "error": {
    "code": 4001,
    "message": "Invalid API key",
    "details": "The provided API key is malformed or expired",
    "docs_url": "https://docs.thescreener.com/errors/4001"
  },
  "meta": {
    "timestamp": "2025-11-30T10:30:00Z",
    "api_version": "v1",
    "request_id": "req_abc123"
  }
}
```

### Example Endpoint Implementation

**Stock List Endpoint:**
```python
from fastapi import APIRouter, Query, Depends, HTTPException
from typing import List, Optional
from app.models import Stock, PaginatedResponse
from app.auth import verify_api_key
from app.database import get_db_session

router = APIRouter(prefix="/api/v1/public")

@router.get("/stocks", response_model=PaginatedResponse[Stock])
async def list_stocks(
    limit: int = Query(20, ge=1, le=100, description="Number of results per page"),
    offset: int = Query(0, ge=0, description="Number of results to skip"),
    market: Optional[str] = Query(None, description="Filter by market (KOSPI, KOSDAQ)"),
    sector: Optional[str] = Query(None, description="Filter by sector"),
    min_price: Optional[float] = Query(None, ge=0, description="Minimum stock price"),
    max_price: Optional[float] = Query(None, ge=0, description="Maximum stock price"),
    sort_by: str = Query("market_cap", description="Sort field"),
    order: str = Query("desc", regex="^(asc|desc)$", description="Sort order"),
    api_key: str = Depends(verify_api_key),
    db = Depends(get_db_session)
):
    """
    List all available stocks with filtering and pagination.

    **Authentication:** Requires API key in `X-API-Key` header

    **Rate Limit:** 100 requests per minute

    **Example:**
    ```
    GET /api/v1/public/stocks?market=KOSPI&sector=Technology&limit=10
    ```
    """
    # Build query
    query = db.query(Stock)

    # Apply filters
    if market:
        query = query.filter(Stock.market == market)
    if sector:
        query = query.filter(Stock.sector == sector)
    if min_price:
        query = query.filter(Stock.current_price >= min_price)
    if max_price:
        query = query.filter(Stock.current_price <= max_price)

    # Get total count
    total = query.count()

    # Apply sorting
    if order == "desc":
        query = query.order_by(getattr(Stock, sort_by).desc())
    else:
        query = query.order_by(getattr(Stock, sort_by).asc())

    # Apply pagination
    stocks = query.offset(offset).limit(limit).all()

    return PaginatedResponse(
        success=True,
        data=stocks,
        pagination={
            "limit": limit,
            "offset": offset,
            "total": total,
            "has_more": (offset + limit) < total
        }
    )
```

**Screening Endpoint:**
```python
from pydantic import BaseModel, validator
from typing import List, Literal

class ScreenFilter(BaseModel):
    field: str
    operator: Literal["eq", "ne", "gt", "gte", "lt", "lte", "in", "contains"]
    value: Union[str, int, float, List[Union[str, int, float]]]

    @validator('field')
    def validate_field(cls, v):
        allowed_fields = ['per', 'pbr', 'roe', 'market_cap', 'sector', 'dividend_yield']
        if v not in allowed_fields:
            raise ValueError(f"Field must be one of {allowed_fields}")
        return v

class ScreenRequest(BaseModel):
    filters: List[ScreenFilter]
    logic: Literal["AND", "OR"] = "AND"
    sort_by: str = "market_cap"
    order: Literal["asc", "desc"] = "desc"
    limit: int = 20

@router.post("/screen", response_model=PaginatedResponse[Stock])
async def screen_stocks(
    request: ScreenRequest,
    api_key: str = Depends(verify_api_key),
    db = Depends(get_db_session)
):
    """
    Execute a stock screening query with custom filters.

    **Example Request:**
    ```json
    {
      "filters": [
        {"field": "per", "operator": "lt", "value": 10},
        {"field": "roe", "operator": "gt", "value": 15},
        {"field": "sector", "operator": "in", "value": ["Technology", "Healthcare"]}
      ],
      "logic": "AND",
      "sort_by": "market_cap",
      "limit": 20
    }
    ```
    """
    query = db.query(Stock)

    # Build filter expression
    filter_expressions = []
    for f in request.filters:
        field = getattr(Stock, f.field)

        if f.operator == "eq":
            filter_expressions.append(field == f.value)
        elif f.operator == "ne":
            filter_expressions.append(field != f.value)
        elif f.operator == "gt":
            filter_expressions.append(field > f.value)
        elif f.operator == "gte":
            filter_expressions.append(field >= f.value)
        elif f.operator == "lt":
            filter_expressions.append(field < f.value)
        elif f.operator == "lte":
            filter_expressions.append(field <= f.value)
        elif f.operator == "in":
            filter_expressions.append(field.in_(f.value))
        elif f.operator == "contains":
            filter_expressions.append(field.contains(f.value))

    # Apply logic
    if request.logic == "AND":
        query = query.filter(and_(*filter_expressions))
    else:
        query = query.filter(or_(*filter_expressions))

    # Apply sorting
    if request.order == "desc":
        query = query.order_by(getattr(Stock, request.sort_by).desc())
    else:
        query = query.order_by(getattr(Stock, request.sort_by).asc())

    results = query.limit(request.limit).all()

    return PaginatedResponse(
        success=True,
        data=results,
        pagination={
            "limit": request.limit,
            "offset": 0,
            "total": len(results),
            "has_more": False
        }
    )
```

### Versioning Implementation

```python
from fastapi import FastAPI, Request
from contextlib import asynccontextmanager

class APIVersionRouter:
    """Manages API versioning across multiple routes."""

    def __init__(self, app: FastAPI):
        self.app = app
        self.versions = {}

    def register_version(self, version: str, router: APIRouter):
        """Register a versioned router."""
        self.versions[version] = router
        self.app.include_router(router, prefix=f"/api/{version}")

    def add_version_middleware(self):
        """Add middleware to handle API-Version header."""
        @self.app.middleware("http")
        async def version_middleware(request: Request, call_next):
            # Check for API-Version header
            version_header = request.headers.get("API-Version")
            if version_header:
                # Rewrite path to include version
                request.scope["path"] = f"/api/{version_header}{request.url.path}"

            response = await call_next(request)
            response.headers["API-Version"] = version_header or "v1"
            return response

# Usage
app = FastAPI()
version_router = APIVersionRouter(app)

# Register v1 routes
v1_router = APIRouter()
# ... add v1 endpoints
version_router.register_version("v1", v1_router)

# Register v2 routes (future)
v2_router = APIRouter()
# ... add v2 endpoints with changes
version_router.register_version("v2", v2_router)
```

### Pagination Utilities

```python
from typing import TypeVar, Generic, List
from pydantic import BaseModel
from math import ceil

T = TypeVar('T')

class PaginationMeta(BaseModel):
    limit: int
    offset: int
    total: int
    has_more: bool
    page: int
    total_pages: int

class PaginatedResponse(BaseModel, Generic[T]):
    success: bool = True
    data: List[T]
    pagination: PaginationMeta

    @staticmethod
    def create(data: List[T], limit: int, offset: int, total: int):
        page = (offset // limit) + 1
        total_pages = ceil(total / limit)

        return PaginatedResponse(
            data=data,
            pagination=PaginationMeta(
                limit=limit,
                offset=offset,
                total=total,
                has_more=(offset + limit) < total,
                page=page,
                total_pages=total_pages
            )
        )
```

## Testing Strategy

### Unit Tests

```python
import pytest
from fastapi.testclient import TestClient
from app.main import app
from app.database import get_test_db

client = TestClient(app)

class TestStockEndpoints:
    """Unit tests for stock-related endpoints."""

    def test_list_stocks_no_auth(self):
        """Test that listing stocks without API key returns 401."""
        response = client.get("/api/v1/public/stocks")
        assert response.status_code == 401
        assert response.json()["error"]["code"] == 4001

    def test_list_stocks_with_auth(self, api_key):
        """Test listing stocks with valid API key."""
        response = client.get(
            "/api/v1/public/stocks",
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 200
        assert response.json()["success"] is True
        assert "data" in response.json()
        assert "pagination" in response.json()

    def test_list_stocks_pagination(self, api_key):
        """Test pagination parameters."""
        response = client.get(
            "/api/v1/public/stocks?limit=10&offset=20",
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 200
        pagination = response.json()["pagination"]
        assert pagination["limit"] == 10
        assert pagination["offset"] == 20

    def test_list_stocks_filtering(self, api_key):
        """Test filtering by market and sector."""
        response = client.get(
            "/api/v1/public/stocks?market=KOSPI&sector=Technology",
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 200
        data = response.json()["data"]
        for stock in data:
            assert stock["market"] == "KOSPI"
            assert stock["sector"] == "Technology"

    def test_get_stock_invalid_code(self, api_key):
        """Test getting non-existent stock returns 404."""
        response = client.get(
            "/api/v1/public/stocks/INVALID",
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 404

class TestScreeningEndpoints:
    """Unit tests for screening endpoints."""

    def test_screen_with_filters(self, api_key):
        """Test screening with multiple filters."""
        request_data = {
            "filters": [
                {"field": "per", "operator": "lt", "value": 10},
                {"field": "roe", "operator": "gt", "value": 15}
            ],
            "logic": "AND",
            "limit": 20
        }
        response = client.post(
            "/api/v1/public/screen",
            json=request_data,
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 200
        data = response.json()["data"]
        for stock in data:
            assert stock["per"] < 10
            assert stock["roe"] > 15

    def test_screen_invalid_field(self, api_key):
        """Test screening with invalid field returns 422."""
        request_data = {
            "filters": [
                {"field": "invalid_field", "operator": "eq", "value": 100}
            ]
        }
        response = client.post(
            "/api/v1/public/screen",
            json=request_data,
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 422
```

### Integration Tests

```python
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

class TestAPIIntegration:
    """Integration tests with real database."""

    @pytest.fixture(scope="class")
    def db_session(self):
        """Create test database session."""
        engine = create_engine("postgresql://test:test@localhost/test_db")
        Session = sessionmaker(bind=engine)
        session = Session()
        yield session
        session.close()

    def test_complete_workflow(self, api_key, db_session):
        """Test complete API workflow: list -> filter -> screen."""
        # Step 1: List stocks
        response = client.get(
            "/api/v1/public/stocks?limit=100",
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 200
        all_stocks = response.json()["data"]

        # Step 2: Get available filters
        response = client.get(
            "/api/v1/public/screen/filters",
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 200
        filters = response.json()["data"]

        # Step 3: Screen with filters
        request_data = {
            "filters": [
                {"field": "market_cap", "operator": "gt", "value": 1000000000000}
            ],
            "limit": 10
        }
        response = client.post(
            "/api/v1/public/screen",
            json=request_data,
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 200
        screened = response.json()["data"]

        # Verify all results have market_cap > 1T
        for stock in screened:
            assert stock["market_cap"] > 1000000000000
```

### End-to-End Tests

```python
class TestE2EScenarios:
    """End-to-end tests simulating real user scenarios."""

    def test_developer_onboarding_flow(self):
        """Simulate complete developer onboarding."""
        # 1. Developer registers and gets API key
        api_key = "test_key_12345"

        # 2. Developer lists available filters
        response = client.get(
            "/api/v1/public/screen/filters",
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 200

        # 3. Developer runs first screening
        screen_request = {
            "filters": [
                {"field": "per", "operator": "lt", "value": 15},
                {"field": "pbr", "operator": "lt", "value": 2}
            ],
            "limit": 20
        }
        response = client.post(
            "/api/v1/public/screen",
            json=screen_request,
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 200
        results = response.json()["data"]

        # 4. Developer gets details for first result
        if results:
            stock_code = results[0]["code"]
            response = client.get(
                f"/api/v1/public/stocks/{stock_code}",
                headers={"X-API-Key": api_key}
            )
            assert response.status_code == 200

            # 5. Developer fetches price history
            response = client.get(
                f"/api/v1/public/stocks/{stock_code}/prices?interval=1d&limit=30",
                headers={"X-API-Key": api_key}
            )
            assert response.status_code == 200

    def test_webhook_registration_flow(self, api_key):
        """Test complete webhook registration and delivery."""
        # 1. Register webhook
        webhook_data = {
            "url": "https://example.com/webhook",
            "events": ["stock.price_alert", "screen.result"],
            "secret": "webhook_secret_123"
        }
        response = client.post(
            "/api/v1/public/webhooks",
            json=webhook_data,
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 201
        webhook_id = response.json()["data"]["id"]

        # 2. List webhooks
        response = client.get(
            "/api/v1/public/webhooks",
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 200
        webhooks = response.json()["data"]
        assert any(w["id"] == webhook_id for w in webhooks)

        # 3. Delete webhook
        response = client.delete(
            f"/api/v1/public/webhooks/{webhook_id}",
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 204
```

### Performance Tests

```python
import pytest
from locust import HttpUser, task, between

class APIPerformanceTest(HttpUser):
    """Performance testing using Locust."""

    wait_time = between(1, 3)

    def on_start(self):
        """Setup - get API key."""
        self.api_key = "test_key_12345"
        self.headers = {"X-API-Key": self.api_key}

    @task(3)
    def list_stocks(self):
        """Test stock listing performance."""
        self.client.get(
            "/api/v1/public/stocks?limit=50",
            headers=self.headers
        )

    @task(2)
    def screen_stocks(self):
        """Test screening performance."""
        self.client.post(
            "/api/v1/public/screen",
            json={
                "filters": [
                    {"field": "per", "operator": "lt", "value": 15}
                ],
                "limit": 20
            },
            headers=self.headers
        )

    @task(1)
    def get_stock_details(self):
        """Test stock detail retrieval."""
        self.client.get(
            "/api/v1/public/stocks/005930",
            headers=self.headers
        )

# Run: locust -f test_performance.py --host=http://localhost:8000
```

## Risk Assessment

| Risk | Probability | Impact | Mitigation Strategy | Owner |
|------|-------------|--------|---------------------|-------|
| API key leakage exposes data | Medium | High | Implement key rotation, rate limiting, IP whitelisting | Security Team |
| Database overload from screening queries | Medium | High | Add query complexity limits, implement caching, optimize indexes | Backend Team |
| Breaking changes affect SDK users | Low | High | Strict versioning policy, 6-month deprecation notice, comprehensive changelog | API Team |
| Pagination performance on large datasets | High | Medium | Implement cursor-based pagination, limit max offset, add database indexes | Backend Team |
| Rate limiting too restrictive for users | Medium | Low | Implement tiered rate limits, allow burst requests, provide clear feedback | Product Team |
| OpenAPI spec out of sync with code | Medium | Medium | Auto-generate from code, add CI checks, version control spec files | DevOps Team |
| Webhook delivery failures | High | Medium | Implement retry logic, dead letter queue, delivery status tracking | Backend Team |
| Invalid filter combinations cause errors | Medium | Low | Add filter validation, provide clear error messages, document limitations | Backend Team |

## Performance Requirements

### Response Time Targets

| Endpoint | P50 | P95 | P99 | Max |
|----------|-----|-----|-----|-----|
| GET /stocks | 100ms | 200ms | 300ms | 500ms |
| GET /stocks/{code} | 50ms | 100ms | 150ms | 200ms |
| POST /screen (simple) | 200ms | 400ms | 600ms | 1000ms |
| POST /screen (complex) | 500ms | 1000ms | 1500ms | 2000ms |
| GET /market/indices | 50ms | 100ms | 150ms | 200ms |

### Throughput Requirements

- **Requests per second**: 1000 RPS (aggregate)
- **Concurrent users**: 500 concurrent API clients
- **Screening queries**: 100 queries/second
- **Data freshness**: 1-minute delay acceptable

### Resource Limits

- **Max response size**: 10 MB per request
- **Max request size**: 1 MB per request
- **Query timeout**: 30 seconds
- **Connection timeout**: 5 seconds
- **Pagination max limit**: 100 items per page
- **Screening max results**: 1000 stocks per query

### Caching Strategy

```python
from functools import lru_cache
from redis import Redis
import json

redis_client = Redis(host='localhost', port=6379, db=0)

def cache_response(ttl: int = 60):
    """Decorator to cache API responses in Redis."""
    def decorator(func):
        async def wrapper(*args, **kwargs):
            # Generate cache key
            cache_key = f"api:{func.__name__}:{hash(str(args) + str(kwargs))}"

            # Check cache
            cached = redis_client.get(cache_key)
            if cached:
                return json.loads(cached)

            # Execute function
            result = await func(*args, **kwargs)

            # Store in cache
            redis_client.setex(cache_key, ttl, json.dumps(result))

            return result
        return wrapper
    return decorator

# Usage
@router.get("/stocks/{code}")
@cache_response(ttl=300)  # Cache for 5 minutes
async def get_stock(code: str):
    # ... implementation
    pass
```

## Security Considerations

### Authentication & Authorization

```python
from fastapi import Security, HTTPException, status
from fastapi.security import APIKeyHeader
from app.models import APIKey
from datetime import datetime

api_key_header = APIKeyHeader(name="X-API-Key", auto_error=False)

async def verify_api_key(api_key: str = Security(api_key_header)):
    """Verify API key and return associated user."""
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API key is required"
        )

    # Lookup key in database
    key_obj = await APIKey.get_by_key(api_key)

    if not key_obj:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key"
        )

    if key_obj.is_expired():
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API key has expired"
        )

    if not key_obj.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="API key has been revoked"
        )

    # Update last used timestamp
    await key_obj.update_last_used()

    return key_obj.user
```

### Rate Limiting

```python
from fastapi import Request, HTTPException
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)

@router.get("/stocks")
@limiter.limit("100/minute")
async def list_stocks(request: Request):
    """Rate-limited to 100 requests per minute per IP."""
    # ... implementation
    pass

@router.post("/screen")
@limiter.limit("60/hour")
async def screen_stocks(request: Request):
    """Rate-limited to 60 requests per hour per IP."""
    # ... implementation
    pass

# Custom rate limit handler
@app.exception_handler(RateLimitExceeded)
async def rate_limit_handler(request: Request, exc: RateLimitExceeded):
    return JSONResponse(
        status_code=429,
        content={
            "success": False,
            "error": {
                "code": 4290,
                "message": "Rate limit exceeded",
                "details": f"Too many requests. Retry after {exc.retry_after} seconds.",
                "retry_after": exc.retry_after
            }
        },
        headers={
            "Retry-After": str(exc.retry_after)
        }
    )
```

### Input Validation

```python
from pydantic import BaseModel, validator, Field
from typing import Optional

class StockQueryParams(BaseModel):
    """Validated query parameters for stock listing."""

    limit: int = Field(20, ge=1, le=100, description="Results per page")
    offset: int = Field(0, ge=0, description="Results to skip")
    market: Optional[str] = Field(None, regex="^(KOSPI|KOSDAQ)$")
    sector: Optional[str] = Field(None, max_length=50)

    @validator('sector')
    def validate_sector(cls, v):
        """Validate sector against allowed list."""
        if v is None:
            return v

        allowed_sectors = [
            "Technology", "Finance", "Healthcare", "Energy",
            "Consumer", "Industrial", "Materials", "Utilities"
        ]

        if v not in allowed_sectors:
            raise ValueError(f"Sector must be one of {allowed_sectors}")

        return v
```

### SQL Injection Prevention

```python
from sqlalchemy import text
from sqlalchemy.orm import Session

# NEVER do this (vulnerable to SQL injection):
# query = f"SELECT * FROM stocks WHERE code = '{code}'"

# ALWAYS use parameterized queries:
def get_stock_safe(db: Session, code: str):
    """Safe stock lookup using parameterized query."""
    query = text("SELECT * FROM stocks WHERE code = :code")
    result = db.execute(query, {"code": code})
    return result.fetchone()

# Or use ORM (preferred):
def get_stock_orm(db: Session, code: str):
    """Safe stock lookup using ORM."""
    return db.query(Stock).filter(Stock.code == code).first()
```

## Error Handling

### Error Code System

| Code Range | Category | Description |
|------------|----------|-------------|
| 4000-4099 | Authentication | API key errors, unauthorized access |
| 4100-4199 | Authorization | Permission denied, quota exceeded |
| 4200-4299 | Validation | Invalid input, malformed requests |
| 4300-4399 | Not Found | Resource not found errors |
| 4400-4499 | Rate Limiting | Too many requests |
| 5000-5099 | Server Error | Internal server errors |
| 5100-5199 | Database | Database connection/query errors |
| 5200-5299 | External Service | Third-party service failures |

### Error Handler Implementation

```python
from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from sqlalchemy.exc import SQLAlchemyError
import logging

logger = logging.getLogger(__name__)

class APIError(Exception):
    """Base class for API errors."""
    def __init__(self, code: int, message: str, details: str = None):
        self.code = code
        self.message = message
        self.details = details

class AuthenticationError(APIError):
    """Authentication-related errors."""
    def __init__(self, message: str, details: str = None):
        super().__init__(4001, message, details)

class ValidationError(APIError):
    """Validation-related errors."""
    def __init__(self, message: str, details: str = None):
        super().__init__(4201, message, details)

class NotFoundError(APIError):
    """Resource not found errors."""
    def __init__(self, message: str, details: str = None):
        super().__init__(4301, message, details)

class RateLimitError(APIError):
    """Rate limiting errors."""
    def __init__(self, message: str, details: str = None):
        super().__init__(4401, message, details)

@app.exception_handler(APIError)
async def api_error_handler(request: Request, exc: APIError):
    """Handle custom API errors."""
    logger.error(f"API Error {exc.code}: {exc.message} - {exc.details}")

    return JSONResponse(
        status_code=400 if exc.code < 5000 else 500,
        content={
            "success": False,
            "error": {
                "code": exc.code,
                "message": exc.message,
                "details": exc.details,
                "docs_url": f"https://docs.thescreener.com/errors/{exc.code}"
            },
            "meta": {
                "timestamp": datetime.utcnow().isoformat(),
                "request_id": request.state.request_id
            }
        }
    )

@app.exception_handler(RequestValidationError)
async def validation_error_handler(request: Request, exc: RequestValidationError):
    """Handle Pydantic validation errors."""
    errors = []
    for error in exc.errors():
        errors.append({
            "field": ".".join(str(x) for x in error["loc"]),
            "message": error["msg"],
            "type": error["type"]
        })

    return JSONResponse(
        status_code=422,
        content={
            "success": False,
            "error": {
                "code": 4220,
                "message": "Validation failed",
                "details": errors,
                "docs_url": "https://docs.thescreener.com/errors/4220"
            }
        }
    )

@app.exception_handler(SQLAlchemyError)
async def database_error_handler(request: Request, exc: SQLAlchemyError):
    """Handle database errors."""
    logger.error(f"Database error: {str(exc)}")

    return JSONResponse(
        status_code=500,
        content={
            "success": False,
            "error": {
                "code": 5100,
                "message": "Database error occurred",
                "details": "An error occurred while processing your request",
                "docs_url": "https://docs.thescreener.com/errors/5100"
            }
        }
    )

@app.exception_handler(Exception)
async def general_error_handler(request: Request, exc: Exception):
    """Catch-all error handler."""
    logger.exception("Unhandled exception occurred")

    return JSONResponse(
        status_code=500,
        content={
            "success": False,
            "error": {
                "code": 5000,
                "message": "Internal server error",
                "details": "An unexpected error occurred",
                "docs_url": "https://docs.thescreener.com/errors/5000"
            }
        }
    )
```

### Usage Example

```python
@router.get("/stocks/{code}")
async def get_stock(code: str, db: Session = Depends(get_db)):
    """Get stock details with proper error handling."""
    # Validate stock code format
    if not re.match(r'^\d{6}$', code):
        raise ValidationError(
            message="Invalid stock code format",
            details="Stock code must be 6 digits"
        )

    # Lookup stock
    stock = db.query(Stock).filter(Stock.code == code).first()

    if not stock:
        raise NotFoundError(
            message=f"Stock {code} not found",
            details="The requested stock code does not exist in our database"
        )

    return {"success": True, "data": stock}
```

## Acceptance Criteria

- [x] All endpoints implemented with proper request/response schemas
- [x] API key authentication middleware integrated
- [x] Request/response schema validation using Pydantic
- [x] OpenAPI 3.0 specification auto-generated
- [x] Error code system standardized (4000-5999)
- [x] Pagination implemented with limit/offset and cursor support
- [x] Filtering system with operator support
- [x] Versioning strategy implemented
- [x] Rate limiting per endpoint
- [x] Comprehensive test coverage (>80%)
- [x] Performance benchmarks documented
- [x] Security audit completed

## Dependencies

- **Requires**: API-001 (Public API Infrastructure)
- **Blocks**: API-003 (API Documentation), API-004 (Python SDK), API-005 (JavaScript SDK)

## Progress

**0% - Not started**

- [ ] Stock Data Endpoints (0/5)
- [ ] Screening Endpoints (0/2)
- [ ] Market Data Endpoints (0/2)
- [ ] Webhook Endpoints (0/3)
- [ ] API Infrastructure (0/4)
- [ ] Authentication & Security (0/2)
- [ ] Documentation & Testing (0/2)

## Notes

### Design Decisions

1. **URL-based versioning preferred** over header-based for simplicity and discoverability
2. **Offset pagination default** with cursor pagination option for large datasets
3. **Envelope response format** provides consistent structure for clients
4. **Tiered rate limiting** based on API key type (free, pro, enterprise)
5. **6-month deprecation policy** for breaking changes

### API Best Practices

- Use HTTP verbs correctly (GET, POST, PUT, DELETE)
- Return appropriate status codes (200, 201, 400, 404, 500)
- Include request IDs for debugging
- Provide pagination metadata
- Version the API from day one
- Document all error codes
- Use ISO 8601 for timestamps
- Support compression (gzip)

### Future Enhancements

- GraphQL endpoint for flexible queries
- WebSocket support for real-time updates
- Batch operations endpoint
- Data export functionality (CSV, JSON)
- API analytics dashboard
- Custom rate limit tiers
- API key scopes and permissions

### Related Documentation

- [API Design Guidelines](https://docs.thescreener.com/api/design)
- [OpenAPI Specification](https://docs.thescreener.com/api/spec)
- [Rate Limiting Policy](https://docs.thescreener.com/api/rate-limits)
- [Versioning Strategy](https://docs.thescreener.com/api/versioning)

---

**Last Updated**: 2025-11-30
**Status**: Ready for implementation
