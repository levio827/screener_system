# API-004: Python SDK

## Metadata

| Field | Value |
|-------|-------|
| **ID** | API-004 |
| **Title** | Develop Python SDK |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P2 (Medium) |
| **Estimate** | 8 hours |
| **Sprint** | Sprint 8 |
| **Epic** | Developer API |
| **Assignee** | TBD |
| **Depends On** | API-002 |
| **Blocks** | - |
| **Tags** | `python`, `sdk`, `pypi`, `client-library`, `type-hints` |
| **Created** | 2025-11-29 |
| **Updated** | 2025-11-30 |

## Description

Develop an official Python SDK that provides a pythonic interface to TheScreener API. The SDK should simplify API integration, handle authentication, provide type hints, support async operations, and include comprehensive error handling.

The SDK must be:
- **Pythonic** - Follow PEP 8 and Python conventions
- **Type-Safe** - Full type hints for IDE autocomplete
- **Async-Ready** - Support both sync and async operations
- **Well-Tested** - >90% code coverage
- **Well-Documented** - Docstrings and usage examples
- **Easy to Install** - Available on PyPI

## Subtasks

### 1. Project Structure & Setup
- [ ] **Package Structure**
  - [ ] Create standard Python package layout
  - [ ] Setup pyproject.toml with dependencies
  - [ ] Configure setup.py for PyPI distribution
  - [ ] Add README.md with installation guide
  - [ ] Create CHANGELOG.md
  - [ ] Add LICENSE file (MIT or Apache 2.0)
- [ ] **Development Environment**
  - [ ] Setup virtual environment
  - [ ] Configure pytest for testing
  - [ ] Setup mypy for type checking
  - [ ] Add black for code formatting
  - [ ] Configure flake8 for linting
  - [ ] Setup pre-commit hooks
- [ ] **CI/CD Pipeline**
  - [ ] GitHub Actions for testing
  - [ ] Automated PyPI publishing
  - [ ] Code coverage reporting
  - [ ] Type checking in CI
  - [ ] Documentation building

### 2. Core Client Implementation
- [ ] **Base Client**
  - [ ] Implement HTTP client with requests
  - [ ] Add authentication handling
  - [ ] Implement retry logic with exponential backoff
  - [ ] Add request/response logging
  - [ ] Implement rate limit handling
  - [ ] Add timeout configuration
- [ ] **Async Client**
  - [ ] Implement async client with aiohttp
  - [ ] Mirror sync client functionality
  - [ ] Add asyncio retry logic
  - [ ] Support async context manager
- [ ] **Configuration**
  - [ ] Support API key via constructor
  - [ ] Support environment variables
  - [ ] Add base URL configuration
  - [ ] Configure request timeouts
  - [ ] Add custom headers support

### 3. API Resource Modules
- [ ] **Stocks Module**
  - [ ] Implement stocks.list() method
  - [ ] Implement stocks.get(code) method
  - [ ] Implement stocks.prices(code) method
  - [ ] Implement stocks.indicators(code) method
  - [ ] Implement stocks.financials(code) method
  - [ ] Add type hints for all methods
- [ ] **Screening Module**
  - [ ] Implement screen() method
  - [ ] Implement filters.list() method
  - [ ] Add filter builder utilities
  - [ ] Support complex filter logic
- [ ] **Market Module**
  - [ ] Implement market.indices() method
  - [ ] Implement market.sectors() method
  - [ ] Add market statistics methods
- [ ] **Webhooks Module**
  - [ ] Implement webhooks.create() method
  - [ ] Implement webhooks.list() method
  - [ ] Implement webhooks.delete() method
  - [ ] Add webhook verification utilities

### 4. Data Models & Types
- [ ] **Pydantic Models**
  - [ ] Define Stock model with validation
  - [ ] Define Price model (OHLCV)
  - [ ] Define Indicator models
  - [ ] Define Financial statement models
  - [ ] Define ScreenResult model
  - [ ] Define Market models
  - [ ] Define Webhook models
- [ ] **Type Definitions**
  - [ ] Create type aliases for common types
  - [ ] Add Literal types for enums
  - [ ] Define Protocol types for interfaces
  - [ ] Export types in __init__.py
- [ ] **Validation**
  - [ ] Validate stock codes (6 digits)
  - [ ] Validate date formats
  - [ ] Validate filter expressions
  - [ ] Provide helpful error messages

### 5. Error Handling
- [ ] **Custom Exceptions**
  - [ ] Create ScreenerError base class
  - [ ] Create AuthenticationError class
  - [ ] Create RateLimitError class
  - [ ] Create ValidationError class
  - [ ] Create NotFoundError class
  - [ ] Create ServerError class
- [ ] **Error Context**
  - [ ] Include request ID in errors
  - [ ] Preserve HTTP status codes
  - [ ] Add retry_after for rate limits
  - [ ] Include error documentation URLs
- [ ] **Error Recovery**
  - [ ] Auto-retry on transient errors
  - [ ] Exponential backoff strategy
  - [ ] Max retry configuration
  - [ ] Circuit breaker pattern (optional)

### 6. Utilities & Helpers
- [ ] **Pagination**
  - [ ] Create pagination iterator
  - [ ] Support auto-pagination
  - [ ] Add page size configuration
  - [ ] Implement cursor-based pagination
- [ ] **Filter Builder**
  - [ ] Fluent API for building filters
  - [ ] Validate filter combinations
  - [ ] Generate filter JSON
  - [ ] Add common filter presets
- [ ] **Data Export**
  - [ ] Export to pandas DataFrame
  - [ ] Export to CSV
  - [ ] Export to JSON
  - [ ] Support custom serialization

### 7. Testing & Quality
- [ ] **Unit Tests**
  - [ ] Test all client methods
  - [ ] Test error handling
  - [ ] Test retry logic
  - [ ] Test authentication
  - [ ] Test data models
  - [ ] Mock HTTP responses
- [ ] **Integration Tests**
  - [ ] Test against live API
  - [ ] Test pagination
  - [ ] Test rate limiting
  - [ ] Test async operations
- [ ] **Type Checking**
  - [ ] Run mypy on all code
  - [ ] Ensure 100% type coverage
  - [ ] Test type stubs
- [ ] **Code Coverage**
  - [ ] Achieve >90% coverage
  - [ ] Generate coverage reports
  - [ ] Upload to Codecov

### 8. Documentation
- [ ] **README**
  - [ ] Installation instructions
  - [ ] Quick start guide
  - [ ] Usage examples
  - [ ] Link to full documentation
- [ ] **API Reference**
  - [ ] Docstrings for all public methods
  - [ ] Parameter descriptions
  - [ ] Return type documentation
  - [ ] Usage examples in docstrings
- [ ] **User Guide**
  - [ ] Authentication guide
  - [ ] Error handling guide
  - [ ] Pagination guide
  - [ ] Async usage guide
  - [ ] Best practices

## Implementation Details

### Project Structure

```
thescreener/
├── pyproject.toml
├── setup.py
├── README.md
├── LICENSE
├── CHANGELOG.md
├── .gitignore
├── .pre-commit-config.yaml
├── thescreener/
│   ├── __init__.py
│   ├── client.py              # Main client class
│   ├── async_client.py        # Async client
│   ├── config.py              # Configuration
│   ├── exceptions.py          # Custom exceptions
│   ├── types.py               # Type definitions
│   ├── models/
│   │   ├── __init__.py
│   │   ├── stock.py
│   │   ├── price.py
│   │   ├── indicator.py
│   │   ├── financial.py
│   │   ├── market.py
│   │   └── webhook.py
│   ├── resources/
│   │   ├── __init__.py
│   │   ├── base.py           # Base resource class
│   │   ├── stocks.py
│   │   ├── screening.py
│   │   ├── market.py
│   │   └── webhooks.py
│   └── utils/
│       ├── __init__.py
│       ├── pagination.py
│       ├── filters.py
│       ├── retry.py
│       └── export.py
├── tests/
│   ├── __init__.py
│   ├── conftest.py
│   ├── unit/
│   │   ├── test_client.py
│   │   ├── test_models.py
│   │   ├── test_resources.py
│   │   └── test_utils.py
│   └── integration/
│       ├── test_stocks.py
│       ├── test_screening.py
│       └── test_async.py
├── examples/
│   ├── basic_usage.py
│   ├── async_example.py
│   ├── screening_example.py
│   ├── pandas_export.py
│   └── webhook_example.py
└── docs/
    ├── conf.py
    ├── index.md
    ├── quickstart.md
    ├── api.md
    └── guides/
```

### Core Client Implementation

**Synchronous Client:**
```python
# thescreener/client.py
from typing import Optional, Dict, Any
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

from .config import Config
from .exceptions import ScreenerError, AuthenticationError, RateLimitError
from .resources.stocks import StocksResource
from .resources.screening import ScreeningResource
from .resources.market import MarketResource
from .resources.webhooks import WebhooksResource

class Client:
    """
    TheScreener API client.

    Args:
        api_key: Your API key. If not provided, will use THESCREENER_API_KEY env var.
        base_url: Base URL for API. Defaults to production API.
        timeout: Request timeout in seconds. Defaults to 30.
        max_retries: Maximum number of retry attempts. Defaults to 3.

    Example:
        >>> from thescreener import Client
        >>> client = Client(api_key="your-api-key")
        >>> stock = client.stocks.get("005930")
        >>> print(stock.name)
        Samsung Electronics
    """

    def __init__(
        self,
        api_key: Optional[str] = None,
        base_url: Optional[str] = None,
        timeout: int = 30,
        max_retries: int = 3,
    ):
        self.config = Config(
            api_key=api_key,
            base_url=base_url,
            timeout=timeout,
            max_retries=max_retries
        )

        # Setup session with retry logic
        self.session = requests.Session()
        retry_strategy = Retry(
            total=max_retries,
            backoff_factor=1,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET", "POST", "DELETE"]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("https://", adapter)
        self.session.mount("http://", adapter)

        # Set default headers
        self.session.headers.update({
            "X-API-Key": self.config.api_key,
            "User-Agent": f"thescreener-python/{__version__}",
            "Accept": "application/json"
        })

        # Initialize resources
        self.stocks = StocksResource(self)
        self.screening = ScreeningResource(self)
        self.market = MarketResource(self)
        self.webhooks = WebhooksResource(self)

    def _request(
        self,
        method: str,
        endpoint: str,
        params: Optional[Dict[str, Any]] = None,
        json: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """Make an HTTP request to the API."""
        url = f"{self.config.base_url}{endpoint}"

        try:
            response = self.session.request(
                method=method,
                url=url,
                params=params,
                json=json,
                timeout=self.config.timeout
            )

            # Handle rate limiting
            if response.status_code == 429:
                retry_after = int(response.headers.get("Retry-After", 60))
                raise RateLimitError(
                    message="Rate limit exceeded",
                    retry_after=retry_after
                )

            # Handle authentication errors
            if response.status_code == 401:
                raise AuthenticationError("Invalid or expired API key")

            # Handle other errors
            response.raise_for_status()

            data = response.json()

            if not data.get("success"):
                error = data.get("error", {})
                raise ScreenerError(
                    code=error.get("code"),
                    message=error.get("message"),
                    details=error.get("details")
                )

            return data.get("data")

        except requests.exceptions.Timeout:
            raise ScreenerError("Request timeout")
        except requests.exceptions.ConnectionError:
            raise ScreenerError("Connection error")
        except requests.exceptions.RequestException as e:
            raise ScreenerError(f"Request failed: {str(e)}")

    def __enter__(self):
        """Context manager entry."""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit."""
        self.session.close()

    def close(self):
        """Close the HTTP session."""
        self.session.close()
```

**Async Client:**
```python
# thescreener/async_client.py
from typing import Optional, Dict, Any
import aiohttp
import asyncio
from aiohttp import ClientSession, ClientTimeout

from .config import Config
from .exceptions import ScreenerError, AuthenticationError, RateLimitError
from .resources.async_stocks import AsyncStocksResource
from .resources.async_screening import AsyncScreeningResource
from .resources.async_market import AsyncMarketResource
from .resources.async_webhooks import AsyncWebhooksResource

class AsyncClient:
    """
    Async TheScreener API client.

    Args:
        api_key: Your API key.
        base_url: Base URL for API.
        timeout: Request timeout in seconds.

    Example:
        >>> import asyncio
        >>> from thescreener import AsyncClient
        >>>
        >>> async def main():
        ...     async with AsyncClient(api_key="your-key") as client:
        ...         stock = await client.stocks.get("005930")
        ...         print(stock.name)
        >>>
        >>> asyncio.run(main())
    """

    def __init__(
        self,
        api_key: Optional[str] = None,
        base_url: Optional[str] = None,
        timeout: int = 30,
    ):
        self.config = Config(api_key=api_key, base_url=base_url, timeout=timeout)
        self._session: Optional[ClientSession] = None

        # Initialize resources
        self.stocks = AsyncStocksResource(self)
        self.screening = AsyncScreeningResource(self)
        self.market = AsyncMarketResource(self)
        self.webhooks = AsyncWebhooksResource(self)

    @property
    def session(self) -> ClientSession:
        """Get or create aiohttp session."""
        if self._session is None or self._session.closed:
            timeout = ClientTimeout(total=self.config.timeout)
            self._session = ClientSession(
                headers={
                    "X-API-Key": self.config.api_key,
                    "User-Agent": f"thescreener-python/{__version__}",
                    "Accept": "application/json"
                },
                timeout=timeout
            )
        return self._session

    async def _request(
        self,
        method: str,
        endpoint: str,
        params: Optional[Dict[str, Any]] = None,
        json: Optional[Dict[str, Any]] = None,
        retry_count: int = 0
    ) -> Dict[str, Any]:
        """Make an async HTTP request to the API."""
        url = f"{self.config.base_url}{endpoint}"

        try:
            async with self.session.request(
                method=method,
                url=url,
                params=params,
                json=json
            ) as response:

                # Handle rate limiting with retry
                if response.status == 429:
                    retry_after = int(response.headers.get("Retry-After", 60))

                    if retry_count < 3:
                        await asyncio.sleep(retry_after)
                        return await self._request(
                            method, endpoint, params, json, retry_count + 1
                        )

                    raise RateLimitError(
                        message="Rate limit exceeded",
                        retry_after=retry_after
                    )

                # Handle authentication errors
                if response.status == 401:
                    raise AuthenticationError("Invalid or expired API key")

                # Get response data
                data = await response.json()

                # Check for API errors
                if not data.get("success"):
                    error = data.get("error", {})
                    raise ScreenerError(
                        code=error.get("code"),
                        message=error.get("message"),
                        details=error.get("details")
                    )

                return data.get("data")

        except asyncio.TimeoutError:
            raise ScreenerError("Request timeout")
        except aiohttp.ClientError as e:
            raise ScreenerError(f"Request failed: {str(e)}")

    async def __aenter__(self):
        """Async context manager entry."""
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        await self.close()

    async def close(self):
        """Close the aiohttp session."""
        if self._session and not self._session.closed:
            await self._session.close()
```

### Data Models with Pydantic

```python
# thescreener/models/stock.py
from pydantic import BaseModel, Field, validator
from typing import Optional
from datetime import datetime

class Stock(BaseModel):
    """Stock information model."""

    code: str = Field(..., description="6-digit stock code")
    name: str = Field(..., description="Company name")
    market: str = Field(..., description="Market (KOSPI/KOSDAQ)")
    sector: str = Field(..., description="Industry sector")
    current_price: float = Field(..., description="Current price in KRW")
    market_cap: int = Field(..., description="Market capitalization in KRW")
    per: Optional[float] = Field(None, description="Price-to-Earnings ratio")
    pbr: Optional[float] = Field(None, description="Price-to-Book ratio")
    roe: Optional[float] = Field(None, description="Return on Equity %")
    dividend_yield: Optional[float] = Field(None, description="Dividend yield %")
    volume: Optional[int] = Field(None, description="Trading volume")
    updated_at: Optional[datetime] = Field(None, description="Last update time")

    @validator('code')
    def validate_code(cls, v):
        """Validate stock code format."""
        if not v.isdigit() or len(v) != 6:
            raise ValueError("Stock code must be 6 digits")
        return v

    @validator('market')
    def validate_market(cls, v):
        """Validate market value."""
        if v not in ['KOSPI', 'KOSDAQ']:
            raise ValueError("Market must be KOSPI or KOSDAQ")
        return v

    class Config:
        """Pydantic configuration."""
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }

    def __repr__(self) -> str:
        return f"Stock(code='{self.code}', name='{self.name}', price={self.current_price})"


class Price(BaseModel):
    """OHLCV price data model."""

    date: datetime = Field(..., description="Price date")
    open: float = Field(..., description="Opening price")
    high: float = Field(..., description="Highest price")
    low: float = Field(..., description="Lowest price")
    close: float = Field(..., description="Closing price")
    volume: int = Field(..., description="Trading volume")
    change: Optional[float] = Field(None, description="Price change %")

    class Config:
        json_encoders = {
            datetime: lambda v: v.strftime("%Y-%m-%d")
        }


class ScreenResult(BaseModel):
    """Screening result model."""

    stocks: list[Stock] = Field(..., description="Matching stocks")
    total: int = Field(..., description="Total number of matches")
    filters_applied: list[dict] = Field(..., description="Filters used")
    execution_time: float = Field(..., description="Query execution time (ms)")
```

### Stocks Resource

```python
# thescreener/resources/stocks.py
from typing import List, Optional
from datetime import date

from .base import BaseResource
from ..models.stock import Stock, Price

class StocksResource(BaseResource):
    """Stock-related API operations."""

    def list(
        self,
        limit: int = 20,
        offset: int = 0,
        market: Optional[str] = None,
        sector: Optional[str] = None,
        min_price: Optional[float] = None,
        max_price: Optional[float] = None
    ) -> List[Stock]:
        """
        List all stocks with optional filtering.

        Args:
            limit: Number of results per page (1-100). Defaults to 20.
            offset: Number of results to skip. Defaults to 0.
            market: Filter by market (KOSPI or KOSDAQ).
            sector: Filter by sector.
            min_price: Minimum stock price.
            max_price: Maximum stock price.

        Returns:
            List of Stock objects.

        Example:
            >>> stocks = client.stocks.list(market="KOSPI", limit=10)
            >>> for stock in stocks:
            ...     print(f"{stock.code}: {stock.name}")
        """
        params = {
            "limit": limit,
            "offset": offset
        }

        if market:
            params["market"] = market
        if sector:
            params["sector"] = sector
        if min_price:
            params["min_price"] = min_price
        if max_price:
            params["max_price"] = max_price

        data = self.client._request("GET", "/api/v1/public/stocks", params=params)
        return [Stock(**item) for item in data]

    def get(self, code: str) -> Stock:
        """
        Get detailed information for a specific stock.

        Args:
            code: 6-digit stock code (e.g., "005930").

        Returns:
            Stock object with detailed information.

        Raises:
            ValidationError: If stock code format is invalid.
            NotFoundError: If stock does not exist.

        Example:
            >>> stock = client.stocks.get("005930")
            >>> print(f"{stock.name}: ₩{stock.current_price:,}")
            Samsung Electronics: ₩75,000
        """
        # Validate code format
        if not code.isdigit() or len(code) != 6:
            raise ValidationError("Stock code must be 6 digits")

        data = self.client._request("GET", f"/api/v1/public/stocks/{code}")
        return Stock(**data)

    def prices(
        self,
        code: str,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
        interval: str = "1d",
        limit: int = 100
    ) -> List[Price]:
        """
        Get historical price data for a stock.

        Args:
            code: 6-digit stock code.
            start_date: Start date for price data.
            end_date: End date for price data.
            interval: Data interval (1d, 1w, 1m). Defaults to 1d.
            limit: Maximum number of data points. Defaults to 100.

        Returns:
            List of Price objects.

        Example:
            >>> from datetime import date, timedelta
            >>> end = date.today()
            >>> start = end - timedelta(days=30)
            >>> prices = client.stocks.prices("005930", start_date=start, end_date=end)
            >>> for price in prices:
            ...     print(f"{price.date}: ₩{price.close:,}")
        """
        params = {
            "interval": interval,
            "limit": limit
        }

        if start_date:
            params["start_date"] = start_date.isoformat()
        if end_date:
            params["end_date"] = end_date.isoformat()

        data = self.client._request(
            "GET",
            f"/api/v1/public/stocks/{code}/prices",
            params=params
        )
        return [Price(**item) for item in data]

    def all(self) -> List[Stock]:
        """
        Iterate through all stocks using automatic pagination.

        Yields:
            Stock objects.

        Example:
            >>> for stock in client.stocks.all():
            ...     if stock.per and stock.per < 10:
            ...         print(stock.name)
        """
        offset = 0
        limit = 100

        while True:
            batch = self.list(limit=limit, offset=offset)
            if not batch:
                break

            for stock in batch:
                yield stock

            offset += limit
```

### Error Handling

```python
# thescreener/exceptions.py
from typing import Optional

class ScreenerError(Exception):
    """Base exception for all Screener API errors."""

    def __init__(
        self,
        message: str,
        code: Optional[int] = None,
        details: Optional[str] = None,
        docs_url: Optional[str] = None
    ):
        self.message = message
        self.code = code
        self.details = details
        self.docs_url = docs_url
        super().__init__(self.message)

    def __str__(self) -> str:
        parts = [f"[{self.code}] " if self.code else "", self.message]
        if self.details:
            parts.append(f" - {self.details}")
        if self.docs_url:
            parts.append(f" (see {self.docs_url})")
        return "".join(parts)


class AuthenticationError(ScreenerError):
    """Raised when authentication fails (invalid or expired API key)."""

    def __init__(self, message: str = "Authentication failed"):
        super().__init__(message=message, code=4001)


class RateLimitError(ScreenerError):
    """Raised when rate limit is exceeded."""

    def __init__(self, message: str = "Rate limit exceeded", retry_after: int = 60):
        super().__init__(message=message, code=4290)
        self.retry_after = retry_after

    def __str__(self) -> str:
        return f"{super().__str__()} - Retry after {self.retry_after} seconds"


class ValidationError(ScreenerError):
    """Raised when request validation fails."""

    def __init__(self, message: str, details: Optional[str] = None):
        super().__init__(message=message, code=4220, details=details)


class NotFoundError(ScreenerError):
    """Raised when requested resource is not found."""

    def __init__(self, message: str):
        super().__init__(message=message, code=4301)


class ServerError(ScreenerError):
    """Raised when server encounters an error."""

    def __init__(self, message: str = "Server error occurred"):
        super().__init__(message=message, code=5000)
```

### Utilities

**Filter Builder:**
```python
# thescreener/utils/filters.py
from typing import List, Dict, Any, Literal, Union

FilterOperator = Literal["eq", "ne", "gt", "gte", "lt", "lte", "in", "contains"]
FilterLogic = Literal["AND", "OR"]

class FilterBuilder:
    """Fluent API for building screening filters."""

    def __init__(self):
        self._filters: List[Dict[str, Any]] = []
        self._logic: FilterLogic = "AND"

    def where(
        self,
        field: str,
        operator: FilterOperator,
        value: Union[str, int, float, List[Union[str, int, float]]]
    ) -> "FilterBuilder":
        """
        Add a filter condition.

        Args:
            field: Field to filter on (e.g., "per", "roe", "market_cap").
            operator: Comparison operator.
            value: Value to compare against.

        Returns:
            Self for method chaining.

        Example:
            >>> filters = (FilterBuilder()
            ...     .where("per", "lt", 10)
            ...     .where("roe", "gt", 15)
            ...     .build())
        """
        self._filters.append({
            "field": field,
            "operator": operator,
            "value": value
        })
        return self

    def and_(self) -> "FilterBuilder":
        """Set filter logic to AND."""
        self._logic = "AND"
        return self

    def or_(self) -> "FilterBuilder":
        """Set filter logic to OR."""
        self._logic = "OR"
        return self

    def build(self) -> Dict[str, Any]:
        """Build the final filter object."""
        return {
            "filters": self._filters,
            "logic": self._logic
        }

    # Convenience methods
    def per_lt(self, value: float) -> "FilterBuilder":
        """Filter stocks with PER less than value."""
        return self.where("per", "lt", value)

    def roe_gt(self, value: float) -> "FilterBuilder":
        """Filter stocks with ROE greater than value."""
        return self.where("roe", "gt", value)

    def market_cap_gt(self, value: int) -> "FilterBuilder":
        """Filter stocks with market cap greater than value."""
        return self.where("market_cap", "gt", value)

    def sector_in(self, sectors: List[str]) -> "FilterBuilder":
        """Filter stocks in specified sectors."""
        return self.where("sector", "in", sectors)
```

## Testing Strategy

### Unit Tests

```python
# tests/unit/test_client.py
import pytest
from unittest.mock import Mock, patch
from thescreener import Client
from thescreener.exceptions import AuthenticationError, RateLimitError

class TestClient:
    """Unit tests for Client class."""

    def test_client_initialization(self):
        """Test client initializes with API key."""
        client = Client(api_key="test-key")
        assert client.config.api_key == "test-key"
        assert client.stocks is not None
        assert client.screening is not None

    def test_client_uses_env_var(self, monkeypatch):
        """Test client reads API key from environment."""
        monkeypatch.setenv("THESCREENER_API_KEY", "env-key")
        client = Client()
        assert client.config.api_key == "env-key"

    def test_authentication_error(self):
        """Test authentication error is raised for 401 response."""
        with patch('requests.Session.request') as mock_request:
            mock_response = Mock()
            mock_response.status_code = 401
            mock_request.return_value = mock_response

            client = Client(api_key="invalid-key")

            with pytest.raises(AuthenticationError):
                client._request("GET", "/api/v1/public/stocks")

    def test_rate_limit_error(self):
        """Test rate limit error includes retry_after."""
        with patch('requests.Session.request') as mock_request:
            mock_response = Mock()
            mock_response.status_code = 429
            mock_response.headers = {"Retry-After": "120"}
            mock_request.return_value = mock_response

            client = Client(api_key="test-key")

            with pytest.raises(RateLimitError) as exc_info:
                client._request("GET", "/api/v1/public/stocks")

            assert exc_info.value.retry_after == 120

    def test_context_manager(self):
        """Test client works as context manager."""
        with Client(api_key="test-key") as client:
            assert client.session is not None

        assert client.session.adapters == {}  # Session closed
```

### Integration Tests

```python
# tests/integration/test_stocks.py
import pytest
from thescreener import Client
from thescreener.models.stock import Stock

@pytest.fixture
def client():
    """Create test client."""
    return Client(api_key=os.getenv("TEST_API_KEY"))

class TestStocksIntegration:
    """Integration tests for stocks resource."""

    def test_list_stocks(self, client):
        """Test listing stocks returns valid data."""
        stocks = client.stocks.list(limit=10)

        assert isinstance(stocks, list)
        assert len(stocks) <= 10
        assert all(isinstance(s, Stock) for s in stocks)

    def test_get_stock(self, client):
        """Test getting specific stock."""
        stock = client.stocks.get("005930")

        assert stock.code == "005930"
        assert stock.name is not None
        assert stock.market in ["KOSPI", "KOSDAQ"]
        assert stock.current_price > 0

    def test_stock_prices(self, client):
        """Test getting price history."""
        from datetime import date, timedelta

        end = date.today()
        start = end - timedelta(days=7)

        prices = client.stocks.prices("005930", start_date=start, end_date=end)

        assert isinstance(prices, list)
        assert len(prices) > 0
        assert all(p.close > 0 for p in prices)

    def test_filtering(self, client):
        """Test stock filtering."""
        stocks = client.stocks.list(
            market="KOSPI",
            min_price=10000,
            limit=5
        )

        assert all(s.market == "KOSPI" for s in stocks)
        assert all(s.current_price >= 10000 for s in stocks)
```

### Type Checking Tests

```python
# tests/type_checking/test_types.py
from thescreener import Client
from thescreener.models.stock import Stock

def test_client_types() -> None:
    """Test that type hints are correct."""
    client: Client = Client(api_key="test")

    # This should type-check correctly
    stock: Stock = client.stocks.get("005930")

    # These should be type-safe
    name: str = stock.name
    price: float = stock.current_price
```

## Risk Assessment

| Risk | Probability | Impact | Mitigation Strategy | Owner |
|------|-------------|--------|---------------------|-------|
| API changes break SDK | Medium | High | Pin to API version, comprehensive tests, deprecation warnings | SDK Team |
| Type hints incorrect or incomplete | Low | Medium | Mypy in CI, manual review, user feedback | SDK Team |
| Async implementation has bugs | Medium | Medium | Comprehensive async tests, real-world usage testing | SDK Team |
| Dependencies have vulnerabilities | Medium | High | Dependabot alerts, regular updates, minimal dependencies | SDK Team |
| Poor error messages confuse users | Medium | Medium | User testing, improve error context, documentation | SDK Team |
| Memory leaks in long-running apps | Low | High | Resource cleanup tests, connection pooling, profiling | SDK Team |
| PyPI package distribution issues | Low | Medium | Automated publishing, test on test.pypi.org first | DevOps Team |
| Documentation out of sync with code | High | Low | Generate docs from docstrings, CI validation | SDK Team |

## Performance Requirements

### Response Time
- **Client initialization**: < 100ms
- **Simple API call**: < 200ms (excluding network)
- **Complex screening**: < 500ms (excluding network)
- **Pagination iteration**: < 50ms per page

### Resource Usage
- **Memory footprint**: < 50 MB for typical usage
- **Connection pooling**: Reuse HTTP connections
- **Async efficiency**: Support 100+ concurrent requests

### Benchmarks
```python
# Benchmark targets
- 1000 stock listings: < 5 seconds
- 100 concurrent requests (async): < 10 seconds
- Pagination through 10,000 stocks: < 30 seconds
```

## Security Considerations

### API Key Protection
```python
# Never log API keys
import logging

logger = logging.getLogger(__name__)

# ❌ Bad
logger.info(f"Using API key: {api_key}")

# ✅ Good
logger.info("API key configured")
logger.debug(f"API key starts with: {api_key[:6]}...")
```

### Input Validation
```python
# Validate all user inputs
from pydantic import validator

class ScreenRequest(BaseModel):
    filters: List[ScreenFilter]

    @validator('filters')
    def validate_filters(cls, v):
        if len(v) > 10:
            raise ValueError("Maximum 10 filters allowed")
        return v
```

### Secure Defaults
```python
# Use HTTPS by default
DEFAULT_BASE_URL = "https://api.thescreener.com"  # ✅

# Validate SSL certificates
verify_ssl = True  # Default

# Timeout to prevent hanging
default_timeout = 30  # seconds
```

## Error Handling

### Retry Logic
```python
# thescreener/utils/retry.py
import time
from functools import wraps

def with_retry(max_retries=3, backoff_factor=1):
    """Decorator for retrying failed operations."""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except (ConnectionError, TimeoutError) as e:
                    if attempt == max_retries - 1:
                        raise
                    sleep_time = backoff_factor * (2 ** attempt)
                    time.sleep(sleep_time)
            return None
        return wrapper
    return decorator
```

### Comprehensive Error Messages
```python
try:
    stock = client.stocks.get("invalid")
except ValidationError as e:
    # Error message should be helpful:
    # "Stock code must be 6 digits. Received: 'invalid'"
    print(e)
except NotFoundError as e:
    # "Stock 999999 not found. Please verify the stock code."
    print(e)
```

## Acceptance Criteria

- [x] Package structure follows Python best practices
- [x] Synchronous client fully implemented
- [x] Async client with same functionality
- [x] All API endpoints wrapped
- [x] Pydantic models for all data types
- [x] Comprehensive type hints (mypy clean)
- [x] Custom exception hierarchy
- [x] Retry logic with exponential backoff
- [x] Pagination utilities
- [x] Filter builder utility
- [x] Unit test coverage > 90%
- [x] Integration tests with live API
- [x] Type checking with mypy
- [x] Code formatting with black
- [x] Linting with flake8
- [x] Documentation (README, docstrings, user guide)
- [x] Published to PyPI
- [x] CI/CD pipeline setup

## Dependencies

- **Requires**: API-002 (Public API Endpoints)
- **Blocks**: None

## Progress

**0% - Not started**

- [ ] Project Structure & Setup (0/3)
- [ ] Core Client Implementation (0/3)
- [ ] API Resource Modules (0/4)
- [ ] Data Models & Types (0/3)
- [ ] Error Handling (0/3)
- [ ] Utilities & Helpers (0/4)
- [ ] Testing & Quality (0/4)
- [ ] Documentation (0/3)

## Notes

### Python Version Support
- **Minimum**: Python 3.8
- **Tested on**: 3.8, 3.9, 3.10, 3.11, 3.12
- **Type hints**: Use from __future__ import annotations for 3.8

### Dependencies
```toml
[tool.poetry.dependencies]
python = "^3.8"
requests = "^2.31.0"
pydantic = "^2.0.0"
aiohttp = "^3.9.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
pytest-asyncio = "^0.21.0"
pytest-cov = "^4.1.0"
mypy = "^1.5.0"
black = "^23.7.0"
flake8 = "^6.1.0"
```

### Versioning Strategy
- Follow semantic versioning (SemVer)
- Major version matches API version
- Deprecate features with warnings before removal
- Maintain changelog

### Future Enhancements
- Pandas DataFrame integration
- CLI tool for quick queries
- Caching layer with TTL
- WebSocket support (when available)
- Batch operations
- Rate limit prediction
- Request mocking for tests

### Related Resources
- [Python Packaging Guide](https://packaging.python.org/)
- [Pydantic Documentation](https://docs.pydantic.dev/)
- [aiohttp Documentation](https://docs.aiohttp.org/)
- [pytest Documentation](https://docs.pytest.org/)

---

**Last Updated**: 2025-11-30
**Status**: Ready for implementation
