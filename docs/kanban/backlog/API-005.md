# API-005: JavaScript SDK

## Metadata

| Field | Value |
|-------|-------|
| **ID** | API-005 |
| **Title** | Develop JavaScript/TypeScript SDK |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P2 (Medium) |
| **Estimate** | 8 hours |
| **Sprint** | Sprint 8 |
| **Epic** | Developer API |
| **Assignee** | TBD |
| **Depends On** | API-002 |
| **Blocks** | - |
| **Tags** | `javascript`, `typescript`, `npm`, `sdk`, `react-hooks` |
| **Created** | 2025-11-29 |
| **Updated** | 2025-11-30 |

## Description

Develop an official JavaScript/TypeScript SDK for TheScreener API that works seamlessly in both browser and Node.js environments. The SDK should provide full TypeScript support, React hooks for easy integration, and a modern developer experience.

The SDK must be:
- **TypeScript-First** - Written in TypeScript with full type definitions
- **Universal** - Work in browser (fetch/axios) and Node.js environments
- **Modern** - Use ES modules, async/await, and modern JavaScript features
- **React-Friendly** - Include React hooks for common use cases
- **Well-Tested** - >90% code coverage
- **Tree-Shakeable** - Support tree-shaking for optimal bundle size

## Subtasks

### 1. Project Setup & Configuration
- [ ] **Package Structure**
  - [ ] Initialize npm package with TypeScript
  - [ ] Configure tsconfig.json for dual output (ESM + CJS)
  - [ ] Setup package.json with proper exports
  - [ ] Add README.md with installation guide
  - [ ] Create CHANGELOG.md
  - [ ] Add LICENSE file (MIT)
- [ ] **Build Configuration**
  - [ ] Setup tsup/rollup for bundling
  - [ ] Configure dual package (ESM + CommonJS)
  - [ ] Generate TypeScript declarations
  - [ ] Enable source maps
  - [ ] Configure tree-shaking
- [ ] **Development Environment**
  - [ ] Setup Jest for testing
  - [ ] Configure ESLint for code quality
  - [ ] Add Prettier for code formatting
  - [ ] Setup Husky for pre-commit hooks
  - [ ] Configure TypeScript strict mode
- [ ] **CI/CD Pipeline**
  - [ ] GitHub Actions for testing
  - [ ] Automated npm publishing
  - [ ] Type checking in CI
  - [ ] Bundle size monitoring
  - [ ] Documentation generation

### 2. Core Client Implementation
- [ ] **Base HTTP Client**
  - [ ] Implement fetch-based client for browser
  - [ ] Add axios adapter for Node.js
  - [ ] Support custom HTTP clients
  - [ ] Implement request/response interceptors
  - [ ] Add retry logic with exponential backoff
  - [ ] Handle authentication
- [ ] **Client Configuration**
  - [ ] Support API key via constructor
  - [ ] Read from environment variables
  - [ ] Configure base URL
  - [ ] Set request timeouts
  - [ ] Add custom headers
  - [ ] Support request transformers
- [ ] **Error Handling**
  - [ ] Create custom error classes
  - [ ] Parse API error responses
  - [ ] Include error codes and details
  - [ ] Add retry information
  - [ ] Support error interceptors

### 3. API Resource Modules
- [ ] **Stocks Resource**
  - [ ] Implement stocks.list() method
  - [ ] Implement stocks.get(code) method
  - [ ] Implement stocks.prices(code) method
  - [ ] Implement stocks.indicators(code) method
  - [ ] Implement stocks.financials(code) method
  - [ ] Add full TypeScript types
- [ ] **Screening Resource**
  - [ ] Implement screen() method
  - [ ] Implement filters.list() method
  - [ ] Add filter builder utilities
  - [ ] Support complex filter combinations
- [ ] **Market Resource**
  - [ ] Implement market.indices() method
  - [ ] Implement market.sectors() method
  - [ ] Add market statistics methods
- [ ] **Webhooks Resource**
  - [ ] Implement webhooks.create() method
  - [ ] Implement webhooks.list() method
  - [ ] Implement webhooks.delete() method
  - [ ] Add webhook verification helpers

### 4. TypeScript Types & Interfaces
- [ ] **Core Types**
  - [ ] Define Stock interface
  - [ ] Define Price (OHLCV) interface
  - [ ] Define Indicator interfaces
  - [ ] Define Financial statement interfaces
  - [ ] Define ScreenResult interface
  - [ ] Define Market interfaces
  - [ ] Define Webhook interfaces
- [ ] **Utility Types**
  - [ ] Create FilterOperator type
  - [ ] Define ScreenFilter interface
  - [ ] Add PaginationParams interface
  - [ ] Define ErrorResponse interface
  - [ ] Create RequestOptions interface
- [ ] **Type Guards**
  - [ ] Add runtime type checking
  - [ ] Create validation functions
  - [ ] Implement type narrowing helpers

### 5. React Hooks Integration
- [ ] **Core Hooks**
  - [ ] useStock(code) - Fetch single stock
  - [ ] useStocks(params) - Fetch stock list
  - [ ] useStockPrices(code, params) - Fetch price history
  - [ ] useScreening(filters) - Run screening
  - [ ] useMarketData() - Fetch market data
- [ ] **Hook Features**
  - [ ] Loading states
  - [ ] Error handling
  - [ ] Automatic refetching
  - [ ] Cache management
  - [ ] Request deduplication
- [ ] **Advanced Hooks**
  - [ ] usePaginatedStocks() - Auto-pagination
  - [ ] useInfiniteStocks() - Infinite scroll
  - [ ] useLivePrice(code) - Real-time updates
  - [ ] useScreeningQuery() - Complex queries

### 6. Utilities & Helpers
- [ ] **Filter Builder**
  - [ ] Fluent API for building filters
  - [ ] Type-safe filter construction
  - [ ] Validate filter combinations
  - [ ] Serialize to API format
- [ ] **Pagination Utilities**
  - [ ] Create async iterator for pagination
  - [ ] Support auto-pagination
  - [ ] Handle cursor-based pagination
  - [ ] Add pagination metadata helpers
- [ ] **Data Formatting**
  - [ ] Format Korean Won currency
  - [ ] Format large numbers
  - [ ] Date formatting utilities
  - [ ] Percent formatting

### 7. Testing & Quality
- [ ] **Unit Tests**
  - [ ] Test all client methods
  - [ ] Test error handling
  - [ ] Test retry logic
  - [ ] Test type safety
  - [ ] Mock HTTP responses
- [ ] **Integration Tests**
  - [ ] Test against live API
  - [ ] Test pagination
  - [ ] Test rate limiting
  - [ ] Test browser/Node.js compatibility
- [ ] **React Hooks Tests**
  - [ ] Test with @testing-library/react-hooks
  - [ ] Test loading states
  - [ ] Test error states
  - [ ] Test refetch logic
- [ ] **Type Tests**
  - [ ] Test TypeScript compilation
  - [ ] Verify type exports
  - [ ] Test type inference
- [ ] **Code Coverage**
  - [ ] Achieve >90% coverage
  - [ ] Generate coverage reports
  - [ ] Upload to Codecov

### 8. Documentation & Examples
- [ ] **README**
  - [ ] Installation instructions
  - [ ] Quick start guide
  - [ ] TypeScript usage
  - [ ] React integration
- [ ] **API Documentation**
  - [ ] JSDoc comments for all public API
  - [ ] Generate API reference with TypeDoc
  - [ ] Document all types and interfaces
  - [ ] Include usage examples
- [ ] **Example Projects**
  - [ ] Vanilla JavaScript example
  - [ ] TypeScript Node.js example
  - [ ] React TypeScript example
  - [ ] Next.js example
  - [ ] Vite + React example

## Implementation Details

### Project Structure

```
@thescreener/sdk/
├── package.json
├── tsconfig.json
├── tsup.config.ts
├── README.md
├── LICENSE
├── CHANGELOG.md
├── .gitignore
├── .eslintrc.js
├── .prettierrc
├── src/
│   ├── index.ts              # Main entry point
│   ├── client.ts             # Core client
│   ├── http.ts               # HTTP adapter
│   ├── errors.ts             # Error classes
│   ├── types.ts              # Core types
│   ├── resources/
│   │   ├── index.ts
│   │   ├── base.ts
│   │   ├── stocks.ts
│   │   ├── screening.ts
│   │   ├── market.ts
│   │   └── webhooks.ts
│   ├── models/
│   │   ├── index.ts
│   │   ├── stock.ts
│   │   ├── price.ts
│   │   ├── indicator.ts
│   │   ├── financial.ts
│   │   ├── market.ts
│   │   └── webhook.ts
│   ├── utils/
│   │   ├── index.ts
│   │   ├── filters.ts
│   │   ├── pagination.ts
│   │   ├── format.ts
│   │   └── retry.ts
│   └── react/
│       ├── index.ts
│       ├── useStock.ts
│       ├── useStocks.ts
│       ├── useScreening.ts
│       ├── useMarketData.ts
│       └── context.ts
├── tests/
│   ├── unit/
│   │   ├── client.test.ts
│   │   ├── resources.test.ts
│   │   ├── utils.test.ts
│   │   └── errors.test.ts
│   ├── integration/
│   │   ├── stocks.test.ts
│   │   ├── screening.test.ts
│   │   └── api.test.ts
│   └── react/
│       ├── hooks.test.tsx
│       └── context.test.tsx
├── examples/
│   ├── vanilla-js/
│   ├── typescript/
│   ├── react/
│   ├── nextjs/
│   └── vite-react/
└── docs/
    └── api/
```

### Core Client Implementation

**TypeScript Client:**
```typescript
// src/client.ts
import { HTTPClient, HTTPClientOptions } from './http';
import { StocksResource } from './resources/stocks';
import { ScreeningResource } from './resources/screening';
import { MarketResource } from './resources/market';
import { WebhooksResource } from './resources/webhooks';
import { ScreenerError } from './errors';

export interface ClientOptions {
  apiKey: string;
  baseURL?: string;
  timeout?: number;
  maxRetries?: number;
  httpClient?: HTTPClient;
}

export class ScreenerClient {
  private http: HTTPClient;

  public readonly stocks: StocksResource;
  public readonly screening: ScreeningResource;
  public readonly market: MarketResource;
  public readonly webhooks: WebhooksResource;

  /**
   * Create a new TheScreener API client.
   *
   * @param options - Client configuration options
   *
   * @example
   * ```typescript
   * import { ScreenerClient } from '@thescreener/sdk';
   *
   * const client = new ScreenerClient({
   *   apiKey: process.env.THESCREENER_API_KEY!
   * });
   *
   * const stock = await client.stocks.get('005930');
   * console.log(stock.name); // Samsung Electronics
   * ```
   */
  constructor(options: ClientOptions) {
    const {
      apiKey,
      baseURL = 'https://api.thescreener.com',
      timeout = 30000,
      maxRetries = 3,
      httpClient
    } = options;

    if (!apiKey) {
      throw new ScreenerError(
        'API key is required. Get yours at https://thescreener.com/settings/api'
      );
    }

    // Initialize HTTP client
    this.http = httpClient || new HTTPClient({
      baseURL,
      timeout,
      maxRetries,
      headers: {
        'X-API-Key': apiKey,
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      }
    });

    // Initialize resources
    this.stocks = new StocksResource(this.http);
    this.screening = new ScreeningResource(this.http);
    this.market = new MarketResource(this.http);
    this.webhooks = new WebhooksResource(this.http);
  }
}
```

**HTTP Client with Fetch:**
```typescript
// src/http.ts
import { ScreenerError, RateLimitError, AuthenticationError } from './errors';

export interface HTTPClientOptions {
  baseURL: string;
  timeout: number;
  maxRetries: number;
  headers?: Record<string, string>;
}

export interface RequestOptions {
  method: 'GET' | 'POST' | 'PUT' | 'DELETE';
  endpoint: string;
  params?: Record<string, any>;
  body?: any;
}

export interface APIResponse<T = any> {
  success: boolean;
  data?: T;
  error?: {
    code: number;
    message: string;
    details?: string;
  };
  meta?: {
    timestamp: string;
    request_id: string;
  };
}

export class HTTPClient {
  private options: HTTPClientOptions;

  constructor(options: HTTPClientOptions) {
    this.options = options;
  }

  /**
   * Make an HTTP request with automatic retry logic.
   */
  async request<T = any>(options: RequestOptions): Promise<T> {
    const { method, endpoint, params, body } = options;
    const url = this.buildURL(endpoint, params);

    let lastError: Error | null = null;

    for (let attempt = 0; attempt < this.options.maxRetries; attempt++) {
      try {
        const response = await this.fetchWithTimeout(url, {
          method,
          headers: this.options.headers,
          body: body ? JSON.stringify(body) : undefined
        });

        // Handle rate limiting
        if (response.status === 429) {
          const retryAfter = parseInt(
            response.headers.get('Retry-After') || '60',
            10
          );

          // Retry after delay
          if (attempt < this.options.maxRetries - 1) {
            await this.delay(retryAfter * 1000);
            continue;
          }

          throw new RateLimitError(
            'Rate limit exceeded',
            retryAfter
          );
        }

        // Handle authentication errors
        if (response.status === 401) {
          throw new AuthenticationError('Invalid or expired API key');
        }

        // Parse response
        const data: APIResponse<T> = await response.json();

        // Handle API errors
        if (!data.success && data.error) {
          throw new ScreenerError(
            data.error.message,
            data.error.code,
            data.error.details
          );
        }

        // Handle HTTP errors
        if (!response.ok) {
          throw new ScreenerError(
            `HTTP ${response.status}: ${response.statusText}`
          );
        }

        return data.data as T;

      } catch (error) {
        lastError = error as Error;

        // Don't retry on client errors (4xx except 429)
        if (error instanceof ScreenerError && error.code && error.code < 500) {
          throw error;
        }

        // Exponential backoff for retries
        if (attempt < this.options.maxRetries - 1) {
          const delay = Math.pow(2, attempt) * 1000;
          await this.delay(delay);
        }
      }
    }

    throw lastError || new ScreenerError('Request failed');
  }

  /**
   * Fetch with timeout support.
   */
  private async fetchWithTimeout(
    url: string,
    options: RequestInit
  ): Promise<Response> {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), this.options.timeout);

    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal
      });
      return response;
    } catch (error: any) {
      if (error.name === 'AbortError') {
        throw new ScreenerError('Request timeout');
      }
      throw error;
    } finally {
      clearTimeout(timeout);
    }
  }

  /**
   * Build URL with query parameters.
   */
  private buildURL(endpoint: string, params?: Record<string, any>): string {
    const url = new URL(endpoint, this.options.baseURL);

    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          url.searchParams.append(key, String(value));
        }
      });
    }

    return url.toString();
  }

  /**
   * Delay helper for retry logic.
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### TypeScript Types & Models

```typescript
// src/models/stock.ts
export interface Stock {
  /** 6-digit stock code */
  code: string;
  /** Company name */
  name: string;
  /** Market (KOSPI or KOSDAQ) */
  market: 'KOSPI' | 'KOSDAQ';
  /** Industry sector */
  sector: string;
  /** Current stock price in KRW */
  currentPrice: number;
  /** Market capitalization in KRW */
  marketCap: number;
  /** Price-to-Earnings ratio */
  per?: number;
  /** Price-to-Book ratio */
  pbr?: number;
  /** Return on Equity percentage */
  roe?: number;
  /** Dividend yield percentage */
  dividendYield?: number;
  /** Trading volume */
  volume?: number;
  /** Last update timestamp */
  updatedAt?: string;
}

export interface Price {
  /** Price date */
  date: string;
  /** Opening price */
  open: number;
  /** Highest price */
  high: number;
  /** Lowest price */
  low: number;
  /** Closing price */
  close: number;
  /** Trading volume */
  volume: number;
  /** Price change percentage */
  change?: number;
}

export interface StockListParams {
  /** Results per page (1-100) */
  limit?: number;
  /** Results to skip */
  offset?: number;
  /** Filter by market */
  market?: 'KOSPI' | 'KOSDAQ';
  /** Filter by sector */
  sector?: string;
  /** Minimum price */
  minPrice?: number;
  /** Maximum price */
  maxPrice?: number;
}

export interface PriceParams {
  /** Start date (YYYY-MM-DD) */
  startDate?: string;
  /** End date (YYYY-MM-DD) */
  endDate?: string;
  /** Data interval */
  interval?: '1d' | '1w' | '1m';
  /** Maximum data points */
  limit?: number;
}
```

**Screening Types:**
```typescript
// src/models/screening.ts
export type FilterOperator =
  | 'eq'  // Equal
  | 'ne'  // Not equal
  | 'gt'  // Greater than
  | 'gte' // Greater than or equal
  | 'lt'  // Less than
  | 'lte' // Less than or equal
  | 'in'  // In array
  | 'contains'; // Contains

export interface ScreenFilter {
  /** Field to filter on */
  field: string;
  /** Comparison operator */
  operator: FilterOperator;
  /** Value to compare */
  value: string | number | (string | number)[];
}

export interface ScreenParams {
  /** Filter conditions */
  filters: ScreenFilter[];
  /** Filter logic (AND/OR) */
  logic?: 'AND' | 'OR';
  /** Sort field */
  sortBy?: string;
  /** Sort order */
  order?: 'asc' | 'desc';
  /** Results limit */
  limit?: number;
}

export interface ScreenResult {
  /** Matching stocks */
  stocks: Stock[];
  /** Total matches */
  total: number;
  /** Applied filters */
  filtersApplied: ScreenFilter[];
  /** Execution time (ms) */
  executionTime: number;
}
```

### React Hooks Implementation

```typescript
// src/react/useStock.ts
import { useState, useEffect } from 'react';
import { Stock } from '../models/stock';
import { ScreenerClient } from '../client';
import { useScreenerClient } from './context';

export interface UseStockOptions {
  /** Enable/disable the query */
  enabled?: boolean;
  /** Refetch interval in ms */
  refetchInterval?: number;
  /** Callback on success */
  onSuccess?: (data: Stock) => void;
  /** Callback on error */
  onError?: (error: Error) => void;
}

export interface UseStockResult {
  /** Stock data */
  data?: Stock;
  /** Loading state */
  isLoading: boolean;
  /** Error if any */
  error?: Error;
  /** Refetch function */
  refetch: () => Promise<void>;
}

/**
 * Hook to fetch a single stock by code.
 *
 * @param code - 6-digit stock code
 * @param options - Hook options
 *
 * @example
 * ```tsx
 * function StockPrice({ code }: { code: string }) {
 *   const { data, isLoading, error } = useStock(code);
 *
 *   if (isLoading) return <div>Loading...</div>;
 *   if (error) return <div>Error: {error.message}</div>;
 *   if (!data) return null;
 *
 *   return (
 *     <div>
 *       <h2>{data.name}</h2>
 *       <p>₩{data.currentPrice.toLocaleString()}</p>
 *     </div>
 *   );
 * }
 * ```
 */
export function useStock(
  code: string,
  options: UseStockOptions = {}
): UseStockResult {
  const client = useScreenerClient();
  const { enabled = true, refetchInterval, onSuccess, onError } = options;

  const [data, setData] = useState<Stock>();
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error>();

  const fetchStock = async () => {
    try {
      setIsLoading(true);
      setError(undefined);

      const stock = await client.stocks.get(code);
      setData(stock);

      if (onSuccess) {
        onSuccess(stock);
      }
    } catch (err) {
      const error = err as Error;
      setError(error);

      if (onError) {
        onError(error);
      }
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    if (enabled && code) {
      fetchStock();
    }

    // Setup refetch interval
    if (refetchInterval && enabled) {
      const interval = setInterval(fetchStock, refetchInterval);
      return () => clearInterval(interval);
    }
  }, [code, enabled, refetchInterval]);

  return {
    data,
    isLoading,
    error,
    refetch: fetchStock
  };
}
```

**Screening Hook:**
```typescript
// src/react/useScreening.ts
import { useState, useEffect, useCallback } from 'react';
import { ScreenParams, ScreenResult } from '../models/screening';
import { useScreenerClient } from './context';

export interface UseScreeningOptions {
  /** Enable/disable the query */
  enabled?: boolean;
  /** Callback on success */
  onSuccess?: (data: ScreenResult) => void;
  /** Callback on error */
  onError?: (error: Error) => void;
}

export interface UseScreeningResult {
  /** Screening results */
  data?: ScreenResult;
  /** Loading state */
  isLoading: boolean;
  /** Error if any */
  error?: Error;
  /** Run screening with new params */
  screen: (params: ScreenParams) => Promise<void>;
  /** Refetch with last params */
  refetch: () => Promise<void>;
}

/**
 * Hook to run stock screening queries.
 *
 * @param initialParams - Initial screening parameters
 * @param options - Hook options
 *
 * @example
 * ```tsx
 * function ValueStocks() {
 *   const { data, isLoading, screen } = useScreening({
 *     filters: [
 *       { field: 'per', operator: 'lt', value: 10 },
 *       { field: 'roe', operator: 'gt', value: 15 }
 *     ],
 *     limit: 20
 *   });
 *
 *   if (isLoading) return <div>Screening...</div>;
 *
 *   return (
 *     <div>
 *       <h2>Found {data?.total} stocks</h2>
 *       <ul>
 *         {data?.stocks.map(stock => (
 *           <li key={stock.code}>{stock.name}</li>
 *         ))}
 *       </ul>
 *     </div>
 *   );
 * }
 * ```
 */
export function useScreening(
  initialParams?: ScreenParams,
  options: UseScreeningOptions = {}
): UseScreeningResult {
  const client = useScreenerClient();
  const { enabled = true, onSuccess, onError } = options;

  const [data, setData] = useState<ScreenResult>();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error>();
  const [params, setParams] = useState<ScreenParams | undefined>(initialParams);

  const runScreening = useCallback(async (screenParams: ScreenParams) => {
    try {
      setIsLoading(true);
      setError(undefined);
      setParams(screenParams);

      const result = await client.screening.screen(screenParams);
      setData(result);

      if (onSuccess) {
        onSuccess(result);
      }
    } catch (err) {
      const error = err as Error;
      setError(error);

      if (onError) {
        onError(error);
      }
    } finally {
      setIsLoading(false);
    }
  }, [client, onSuccess, onError]);

  useEffect(() => {
    if (enabled && initialParams) {
      runScreening(initialParams);
    }
  }, [enabled]);

  return {
    data,
    isLoading,
    error,
    screen: runScreening,
    refetch: () => params ? runScreening(params) : Promise.resolve()
  };
}
```

### Filter Builder Utility

```typescript
// src/utils/filters.ts
import { ScreenFilter, FilterOperator, ScreenParams } from '../models/screening';

export class FilterBuilder {
  private filters: ScreenFilter[] = [];
  private logic: 'AND' | 'OR' = 'AND';

  /**
   * Add a filter condition.
   */
  where(
    field: string,
    operator: FilterOperator,
    value: string | number | (string | number)[]
  ): this {
    this.filters.push({ field, operator, value });
    return this;
  }

  /**
   * Use AND logic for filters.
   */
  and(): this {
    this.logic = 'AND';
    return this;
  }

  /**
   * Use OR logic for filters.
   */
  or(): this {
    this.logic = 'OR';
    return this;
  }

  /**
   * Filter stocks with PER less than value.
   */
  perLessThan(value: number): this {
    return this.where('per', 'lt', value);
  }

  /**
   * Filter stocks with ROE greater than value.
   */
  roeGreaterThan(value: number): this {
    return this.where('roe', 'gt', value);
  }

  /**
   * Filter stocks with market cap greater than value.
   */
  marketCapGreaterThan(value: number): this {
    return this.where('market_cap', 'gt', value);
  }

  /**
   * Filter stocks in specified sectors.
   */
  sectorsIn(sectors: string[]): this {
    return this.where('sector', 'in', sectors);
  }

  /**
   * Build the final screen parameters.
   */
  build(options?: { sortBy?: string; order?: 'asc' | 'desc'; limit?: number }): ScreenParams {
    return {
      filters: this.filters,
      logic: this.logic,
      ...options
    };
  }
}

/**
 * Create a new filter builder.
 *
 * @example
 * ```typescript
 * const params = filter()
 *   .perLessThan(10)
 *   .roeGreaterThan(15)
 *   .sectorsIn(['Technology', 'Healthcare'])
 *   .build({ sortBy: 'market_cap', limit: 20 });
 *
 * const results = await client.screening.screen(params);
 * ```
 */
export function filter(): FilterBuilder {
  return new FilterBuilder();
}
```

### Error Classes

```typescript
// src/errors.ts
export class ScreenerError extends Error {
  public code?: number;
  public details?: string;
  public docsUrl?: string;

  constructor(message: string, code?: number, details?: string) {
    super(message);
    this.name = 'ScreenerError';
    this.code = code;
    this.details = details;

    if (code) {
      this.docsUrl = `https://docs.thescreener.com/errors/${code}`;
    }

    // Maintains proper stack trace for where error was thrown (only available on V8)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ScreenerError);
    }
  }

  toString(): string {
    let msg = `[${this.code || 'ERROR'}] ${this.message}`;
    if (this.details) {
      msg += ` - ${this.details}`;
    }
    if (this.docsUrl) {
      msg += ` (see ${this.docsUrl})`;
    }
    return msg;
  }
}

export class AuthenticationError extends ScreenerError {
  constructor(message = 'Authentication failed') {
    super(message, 4001);
    this.name = 'AuthenticationError';
  }
}

export class RateLimitError extends ScreenerError {
  public retryAfter: number;

  constructor(message = 'Rate limit exceeded', retryAfter = 60) {
    super(message, 4290);
    this.name = 'RateLimitError';
    this.retryAfter = retryAfter;
  }

  toString(): string {
    return `${super.toString()} - Retry after ${this.retryAfter} seconds`;
  }
}

export class ValidationError extends ScreenerError {
  constructor(message: string, details?: string) {
    super(message, 4220, details);
    this.name = 'ValidationError';
  }
}

export class NotFoundError extends ScreenerError {
  constructor(message: string) {
    super(message, 4301);
    this.name = 'NotFoundError';
  }
}
```

## Testing Strategy

### Unit Tests

```typescript
// tests/unit/client.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { ScreenerClient } from '../src/client';
import { ScreenerError, AuthenticationError } from '../src/errors';

describe('ScreenerClient', () => {
  it('should throw error if API key is not provided', () => {
    expect(() => {
      new ScreenerClient({ apiKey: '' });
    }).toThrow(ScreenerError);
  });

  it('should initialize with API key', () => {
    const client = new ScreenerClient({ apiKey: 'test-key' });
    expect(client).toBeInstanceOf(ScreenerClient);
    expect(client.stocks).toBeDefined();
    expect(client.screening).toBeDefined();
  });

  it('should use custom base URL', () => {
    const client = new ScreenerClient({
      apiKey: 'test-key',
      baseURL: 'https://custom.api.com'
    });
    expect(client).toBeDefined();
  });
});

describe('HTTP Client', () => {
  it('should handle authentication errors', async () => {
    global.fetch = vi.fn().mockResolvedValue({
      ok: false,
      status: 401,
      json: async () => ({
        success: false,
        error: { code: 4001, message: 'Invalid API key' }
      })
    });

    const client = new ScreenerClient({ apiKey: 'invalid' });

    await expect(client.stocks.get('005930')).rejects.toThrow(
      AuthenticationError
    );
  });

  it('should retry on transient errors', async () => {
    let callCount = 0;
    global.fetch = vi.fn().mockImplementation(() => {
      callCount++;
      if (callCount < 3) {
        return Promise.reject(new Error('Network error'));
      }
      return Promise.resolve({
        ok: true,
        json: async () => ({
          success: true,
          data: { code: '005930', name: 'Samsung' }
        })
      });
    });

    const client = new ScreenerClient({ apiKey: 'test', maxRetries: 3 });
    const stock = await client.stocks.get('005930');

    expect(callCount).toBe(3);
    expect(stock.name).toBe('Samsung');
  });
});
```

### Integration Tests

```typescript
// tests/integration/stocks.test.ts
import { describe, it, expect, beforeAll } from 'vitest';
import { ScreenerClient } from '../src/client';
import { Stock } from '../src/models/stock';

describe('Stocks Integration', () => {
  let client: ScreenerClient;

  beforeAll(() => {
    client = new ScreenerClient({
      apiKey: process.env.TEST_API_KEY || ''
    });
  });

  it('should list stocks', async () => {
    const stocks = await client.stocks.list({ limit: 10 });

    expect(Array.isArray(stocks)).toBe(true);
    expect(stocks.length).toBeLessThanOrEqual(10);
    stocks.forEach(stock => {
      expect(stock).toHaveProperty('code');
      expect(stock).toHaveProperty('name');
      expect(stock).toHaveProperty('currentPrice');
    });
  });

  it('should get specific stock', async () => {
    const stock = await client.stocks.get('005930');

    expect(stock.code).toBe('005930');
    expect(stock.name).toBeTruthy();
    expect(stock.market).toMatch(/^(KOSPI|KOSDAQ)$/);
    expect(stock.currentPrice).toBeGreaterThan(0);
  });

  it('should filter stocks by market', async () => {
    const stocks = await client.stocks.list({
      market: 'KOSPI',
      limit: 5
    });

    stocks.forEach(stock => {
      expect(stock.market).toBe('KOSPI');
    });
  });
});
```

### React Hooks Tests

```typescript
// tests/react/hooks.test.tsx
import { describe, it, expect } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { useStock } from '../src/react/useStock';
import { ScreenerProvider } from '../src/react/context';
import { ScreenerClient } from '../src/client';

const wrapper = ({ children }: { children: React.ReactNode }) => (
  <ScreenerProvider client={new ScreenerClient({ apiKey: 'test' })}>
    {children}
  </ScreenerProvider>
);

describe('useStock', () => {
  it('should fetch stock data', async () => {
    const { result } = renderHook(() => useStock('005930'), { wrapper });

    expect(result.current.isLoading).toBe(true);

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    expect(result.current.data).toBeDefined();
    expect(result.current.data?.code).toBe('005930');
  });

  it('should handle errors', async () => {
    const { result } = renderHook(() => useStock('invalid'), { wrapper });

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    expect(result.current.error).toBeDefined();
  });

  it('should refetch on demand', async () => {
    const { result } = renderHook(() => useStock('005930'), { wrapper });

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    const firstData = result.current.data;

    await result.current.refetch();

    expect(result.current.data).toBeDefined();
  });
});
```

## Risk Assessment

| Risk | Probability | Impact | Mitigation Strategy | Owner |
|------|-------------|--------|---------------------|-------|
| Browser/Node.js compatibility issues | Medium | High | Test in both environments, use polyfills, document requirements | SDK Team |
| TypeScript types become outdated | Medium | Medium | Auto-generate from API spec, CI type checking, user feedback | SDK Team |
| Bundle size too large | Low | Medium | Tree-shaking, code splitting, bundle analysis in CI | SDK Team |
| React hooks breaking changes | Low | High | Peer dependency versioning, comprehensive tests, changelog | SDK Team |
| Fetch API not available | Low | Medium | Provide axios adapter, document polyfill requirements | SDK Team |
| CORS issues in browser | High | Low | Document CORS requirements, provide troubleshooting guide | API Team |
| npm publishing failures | Low | Medium | Automated publishing, test on test registry first | DevOps Team |
| Memory leaks in React hooks | Medium | Medium | Proper cleanup, AbortController usage, memory profiling | SDK Team |

## Performance Requirements

### Bundle Size
- **Core bundle (min+gzip)**: < 15 KB
- **With React hooks**: < 20 KB
- **Tree-shakeable**: Only include used code

### Response Time
- **Client initialization**: < 50ms
- **API call overhead**: < 10ms
- **Hook render time**: < 5ms

### Benchmarks
```typescript
// Performance targets
- 1000 stock listings: < 5 seconds
- React hook re-render: < 1ms
- Filter building: < 1ms
- Type checking: < 2 seconds (tsc)
```

## Security Considerations

### API Key Protection
```typescript
// Never expose API keys in client-side code
// ❌ Bad (client-side React)
const client = new ScreenerClient({
  apiKey: 'sk_live_abc123' // Exposed in bundle!
});

// ✅ Good (use environment variables)
const client = new ScreenerClient({
  apiKey: process.env.NEXT_PUBLIC_API_KEY // Only for public keys
});

// ✅ Best (server-side only)
// Keep API key on server, proxy requests
```

### Input Sanitization
```typescript
// Validate user inputs
function validateStockCode(code: string): string {
  if (!/^\d{6}$/.test(code)) {
    throw new ValidationError('Stock code must be 6 digits');
  }
  return code;
}
```

### XSS Prevention
```typescript
// Sanitize output when rendering
import DOMPurify from 'dompurify';

function StockName({ name }: { name: string }) {
  return <div dangerouslySetInnerHTML={{
    __html: DOMPurify.sanitize(name)
  }} />;
}
```

## Error Handling

### Graceful Degradation
```typescript
try {
  const stock = await client.stocks.get(code);
  return stock;
} catch (error) {
  if (error instanceof RateLimitError) {
    // Wait and retry
    await new Promise(resolve => setTimeout(resolve, error.retryAfter * 1000));
    return client.stocks.get(code);
  } else if (error instanceof NotFoundError) {
    // Return fallback
    return null;
  } else {
    // Log and rethrow
    console.error('Unexpected error:', error);
    throw error;
  }
}
```

## Acceptance Criteria

- [x] TypeScript-first implementation
- [x] Dual package (ESM + CommonJS)
- [x] Browser and Node.js compatibility
- [x] Full type definitions exported
- [x] All API endpoints wrapped
- [x] React hooks for common operations
- [x] Filter builder utility
- [x] Comprehensive error handling
- [x] Retry logic with exponential backoff
- [x] Unit test coverage > 90%
- [x] Integration tests with live API
- [x] React hooks tests
- [x] Bundle size < 20KB (gzipped)
- [x] Tree-shaking support
- [x] Published to npm
- [x] Documentation with examples
- [x] CI/CD pipeline setup

## Dependencies

- **Requires**: API-002 (Public API Endpoints)
- **Blocks**: None

## Progress

**0% - Not started**

- [ ] Project Setup & Configuration (0/4)
- [ ] Core Client Implementation (0/3)
- [ ] API Resource Modules (0/4)
- [ ] TypeScript Types & Interfaces (0/3)
- [ ] React Hooks Integration (0/3)
- [ ] Utilities & Helpers (0/3)
- [ ] Testing & Quality (0/5)
- [ ] Documentation & Examples (0/4)

## Notes

### Package Configuration

**package.json:**
```json
{
  "name": "@thescreener/sdk",
  "version": "1.0.0",
  "description": "Official JavaScript/TypeScript SDK for TheScreener API",
  "main": "./dist/index.js",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.js",
      "types": "./dist/index.d.ts"
    },
    "./react": {
      "import": "./dist/react/index.mjs",
      "require": "./dist/react/index.js",
      "types": "./dist/react/index.d.ts"
    }
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "tsup",
    "test": "vitest",
    "test:coverage": "vitest --coverage",
    "typecheck": "tsc --noEmit",
    "lint": "eslint src --ext .ts,.tsx",
    "format": "prettier --write src",
    "prepublishOnly": "npm run build && npm test"
  },
  "peerDependencies": {
    "react": ">=16.8.0"
  },
  "peerDependenciesMeta": {
    "react": {
      "optional": true
    }
  },
  "devDependencies": {
    "@types/react": "^18.0.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.0.0",
    "prettier": "^3.0.0",
    "tsup": "^7.0.0",
    "typescript": "^5.0.0",
    "vitest": "^0.34.0"
  },
  "keywords": [
    "thescreener",
    "stock",
    "market",
    "api",
    "sdk",
    "typescript",
    "react"
  ]
}
```

### Build Configuration

**tsup.config.ts:**
```typescript
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: {
    index: 'src/index.ts',
    'react/index': 'src/react/index.ts'
  },
  format: ['esm', 'cjs'],
  dts: true,
  sourcemap: true,
  clean: true,
  splitting: false,
  minify: true,
  treeshake: true,
  external: ['react']
});
```

### Browser vs Node.js

**Conditional Exports:**
```typescript
// src/http.ts
const isBrowser = typeof window !== 'undefined';

export function createHTTPClient(options: HTTPClientOptions): HTTPClient {
  if (isBrowser) {
    return new FetchHTTPClient(options);
  } else {
    // Use axios or node-fetch for Node.js
    return new NodeHTTPClient(options);
  }
}
```

### Future Enhancements

- Vue.js composition API support
- Svelte stores
- WebSocket client for real-time data
- GraphQL client (when available)
- Offline support with IndexedDB
- Request batching
- Advanced caching strategies
- Optimistic updates for React

### Related Resources

- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [React Hooks Documentation](https://react.dev/reference/react)
- [Vitest Documentation](https://vitest.dev/)
- [tsup Documentation](https://tsup.egoist.dev/)

---

**Last Updated**: 2025-11-30
**Status**: Ready for implementation
