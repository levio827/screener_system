# BT-001a: Backtesting Core - Simulation Engine

## Metadata

| Field | Value |
|-------|-------|
| **ID** | BT-001a |
| **Title** | Implement Backtesting Simulation Engine |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P0 (Critical) |
| **Estimate** | 12 hours |
| **Sprint** | Sprint 5 |
| **Epic** | Backtesting Engine |
| **Assignee** | TBD |
| **Created** | 2025-11-29 |
| **Tags** | #backend #backtesting #simulation #performance |
| **Blocks** | BT-001b, BT-002, BT-005 |

## Description

Implement the core backtesting simulation engine that executes historical performance analysis of screening strategies. The engine will simulate portfolio rebalancing, apply transaction costs, manage position sizing, and generate detailed trade history logs. This is the foundational component that powers all backtesting functionality.

## Subtasks

### Core Engine Implementation
- [ ] Create BacktestEngine class structure
  - [ ] Initialize engine with configuration parameters
  - [ ] Set up historical data loading interface
  - [ ] Implement portfolio state management
  - [ ] Create rebalancing scheduler
- [ ] Implement simulation loop
  - [ ] Date iteration logic (daily/weekly/monthly)
  - [ ] Portfolio rebalancing triggers
  - [ ] Trade execution simulation
  - [ ] Portfolio value calculation
  - [ ] Performance tracking

### Rebalancing Strategy
- [ ] Implement rebalancing period configuration
  - [ ] Daily rebalancing option
  - [ ] Weekly rebalancing (Monday default)
  - [ ] Monthly rebalancing (first business day)
  - [ ] Custom interval support
- [ ] Portfolio reconstruction logic
  - [ ] Screen universe on rebalancing date
  - [ ] Determine positions to close
  - [ ] Calculate new position sizes
  - [ ] Generate buy/sell orders

### Transaction Cost Modeling
- [ ] Commission calculation
  - [ ] Fixed commission per trade
  - [ ] Percentage-based commission
  - [ ] Tiered commission structure
  - [ ] Minimum commission floor
- [ ] Slippage modeling
  - [ ] Fixed percentage slippage
  - [ ] Volume-based slippage
  - [ ] Market impact estimation
  - [ ] Bid-ask spread simulation

### Position Sizing Strategies
- [ ] Equal-weight allocation
  - [ ] Divide capital equally among positions
  - [ ] Handle fractional shares
  - [ ] Minimum position size enforcement
- [ ] Market-cap weighted allocation
  - [ ] Load market cap data
  - [ ] Calculate proportional weights
  - [ ] Apply weight caps (e.g., max 10% per position)
- [ ] Custom weighting support
  - [ ] Factor-based weighting (value, momentum, etc.)
  - [ ] Risk parity weighting
  - [ ] Volatility-adjusted sizing

### Trade History & Logging
- [ ] Trade execution logging
  - [ ] Log every buy/sell transaction
  - [ ] Record trade date, symbol, quantity, price
  - [ ] Track commission and slippage costs
  - [ ] Store portfolio state snapshots
- [ ] Performance logging
  - [ ] Daily portfolio value tracking
  - [ ] Position-level P&L tracking
  - [ ] Cash balance tracking
  - [ ] Benchmark comparison data

### Testing
- [ ] Unit tests for core engine
  - [ ] Test simulation loop logic
  - [ ] Verify date iteration
  - [ ] Test portfolio state transitions
- [ ] Position sizing tests
  - [ ] Equal-weight calculation accuracy
  - [ ] Market-cap weight calculation
  - [ ] Weight cap enforcement
- [ ] Transaction cost tests
  - [ ] Commission calculation accuracy
  - [ ] Slippage application
  - [ ] Total cost aggregation

## Implementation Details

### BacktestEngine Class

```python
# backend/app/services/backtesting/engine.py
from datetime import date, timedelta
from typing import List, Dict, Optional
from decimal import Decimal
from dataclasses import dataclass

@dataclass
class BacktestConfig:
    """Backtesting configuration parameters"""
    initial_capital: Decimal
    rebalancing_period: str  # 'daily', 'weekly', 'monthly'
    rebalancing_day: Optional[int] = None  # Day of week/month
    commission_rate: Decimal = Decimal('0.0015')  # 0.15%
    slippage_rate: Decimal = Decimal('0.001')  # 0.1%
    position_sizing: str = 'equal_weight'  # 'equal_weight', 'market_cap'
    max_position_weight: Decimal = Decimal('0.1')  # 10% max per position
    min_position_size: Decimal = Decimal('1000')  # Minimum $1000 per position

@dataclass
class Trade:
    """Individual trade record"""
    date: date
    symbol: str
    action: str  # 'BUY' or 'SELL'
    quantity: int
    price: Decimal
    commission: Decimal
    slippage: Decimal
    total_cost: Decimal

@dataclass
class PortfolioSnapshot:
    """Portfolio state at a point in time"""
    date: date
    cash: Decimal
    positions: Dict[str, int]  # symbol -> quantity
    position_values: Dict[str, Decimal]  # symbol -> market value
    total_value: Decimal

class BacktestEngine:
    """Core backtesting simulation engine"""

    def __init__(self, config: BacktestConfig):
        self.config = config
        self.trades: List[Trade] = []
        self.snapshots: List[PortfolioSnapshot] = []
        self.cash = config.initial_capital
        self.positions: Dict[str, int] = {}

    async def simulate(
        self,
        strategy: ScreeningStrategy,
        start_date: date,
        end_date: date,
        price_data: Dict[str, pd.DataFrame],  # symbol -> OHLCV dataframe
        benchmark_data: Optional[pd.DataFrame] = None
    ) -> SimulationResult:
        """
        Execute backtest simulation

        Args:
            strategy: Screening strategy to backtest
            start_date: Start date of backtest
            end_date: End date of backtest
            price_data: Historical price data for all symbols
            benchmark_data: Benchmark index data (e.g., KOSPI)

        Returns:
            SimulationResult with trades, snapshots, and performance metrics
        """
        current_date = start_date

        while current_date <= end_date:
            # Check if rebalancing is needed
            if self._should_rebalance(current_date):
                await self._rebalance(current_date, strategy, price_data)

            # Update portfolio value
            self._update_portfolio_value(current_date, price_data)

            # Move to next business day
            current_date = self._next_business_day(current_date)

        return self._generate_results(benchmark_data)

    def _should_rebalance(self, current_date: date) -> bool:
        """Determine if portfolio should be rebalanced on given date"""
        if self.config.rebalancing_period == 'daily':
            return True
        elif self.config.rebalancing_period == 'weekly':
            target_day = self.config.rebalancing_day or 0  # Monday
            return current_date.weekday() == target_day
        elif self.config.rebalancing_period == 'monthly':
            target_day = self.config.rebalancing_day or 1
            return current_date.day == target_day
        return False

    async def _rebalance(
        self,
        rebalance_date: date,
        strategy: ScreeningStrategy,
        price_data: Dict[str, pd.DataFrame]
    ):
        """Execute portfolio rebalancing"""
        # Run screening strategy on rebalance date
        selected_symbols = await self._run_strategy(
            strategy,
            rebalance_date
        )

        # Calculate target positions
        target_positions = self._calculate_target_positions(
            selected_symbols,
            rebalance_date,
            price_data
        )

        # Generate and execute trades
        await self._execute_rebalancing_trades(
            target_positions,
            rebalance_date,
            price_data
        )

    def _calculate_target_positions(
        self,
        symbols: List[str],
        date: date,
        price_data: Dict[str, pd.DataFrame]
    ) -> Dict[str, int]:
        """Calculate target position sizes based on strategy"""
        if self.config.position_sizing == 'equal_weight':
            return self._equal_weight_positions(symbols, date, price_data)
        elif self.config.position_sizing == 'market_cap':
            return self._market_cap_positions(symbols, date, price_data)
        else:
            raise ValueError(f"Unknown position sizing: {self.config.position_sizing}")

    def _equal_weight_positions(
        self,
        symbols: List[str],
        date: date,
        price_data: Dict[str, pd.DataFrame]
    ) -> Dict[str, int]:
        """Calculate equal-weighted positions"""
        if not symbols:
            return {}

        total_value = self.cash + self._get_portfolio_market_value(date, price_data)
        target_value_per_position = total_value / len(symbols)

        # Apply max position weight constraint
        max_position_value = total_value * self.config.max_position_weight
        target_value_per_position = min(
            target_value_per_position,
            max_position_value
        )

        # Calculate quantities
        positions = {}
        for symbol in symbols:
            price = self._get_price(symbol, date, price_data)
            if price > 0 and target_value_per_position >= self.config.min_position_size:
                quantity = int(target_value_per_position / price)
                if quantity > 0:
                    positions[symbol] = quantity

        return positions

    def _apply_transaction_costs(
        self,
        symbol: str,
        quantity: int,
        price: Decimal,
        action: str
    ) -> tuple[Decimal, Decimal]:
        """Calculate commission and slippage costs"""
        gross_amount = price * quantity

        # Commission
        commission = gross_amount * self.config.commission_rate

        # Slippage (price impact)
        slippage_amount = gross_amount * self.config.slippage_rate
        if action == 'BUY':
            effective_price = price * (1 + self.config.slippage_rate)
        else:  # SELL
            effective_price = price * (1 - self.config.slippage_rate)

        return commission, slippage_amount
```

### Trade Execution Logic

```python
async def _execute_rebalancing_trades(
    self,
    target_positions: Dict[str, int],
    date: date,
    price_data: Dict[str, pd.DataFrame]
):
    """Execute trades to reach target positions"""
    # Close positions not in target
    for symbol, current_qty in list(self.positions.items()):
        target_qty = target_positions.get(symbol, 0)

        if target_qty == 0:
            # Full liquidation
            await self._execute_trade(
                symbol,
                current_qty,
                'SELL',
                date,
                price_data
            )
        elif target_qty < current_qty:
            # Partial sell
            sell_qty = current_qty - target_qty
            await self._execute_trade(
                symbol,
                sell_qty,
                'SELL',
                date,
                price_data
            )

    # Open or increase positions
    for symbol, target_qty in target_positions.items():
        current_qty = self.positions.get(symbol, 0)

        if target_qty > current_qty:
            buy_qty = target_qty - current_qty
            await self._execute_trade(
                symbol,
                buy_qty,
                'BUY',
                date,
                price_data
            )

async def _execute_trade(
    self,
    symbol: str,
    quantity: int,
    action: str,
    date: date,
    price_data: Dict[str, pd.DataFrame]
):
    """Execute a single trade with transaction costs"""
    price = self._get_price(symbol, date, price_data)
    commission, slippage = self._apply_transaction_costs(
        symbol, quantity, price, action
    )

    if action == 'BUY':
        total_cost = (price * quantity) + commission + slippage
        if total_cost > self.cash:
            # Insufficient funds - reduce quantity
            quantity = int(self.cash / (price * 1.002))  # Account for costs
            if quantity == 0:
                return
            total_cost = (price * quantity) + commission + slippage

        self.cash -= total_cost
        self.positions[symbol] = self.positions.get(symbol, 0) + quantity

    else:  # SELL
        proceeds = (price * quantity) - commission - slippage
        self.cash += proceeds
        self.positions[symbol] = self.positions.get(symbol, 0) - quantity

        if self.positions[symbol] == 0:
            del self.positions[symbol]

    # Log trade
    trade = Trade(
        date=date,
        symbol=symbol,
        action=action,
        quantity=quantity,
        price=price,
        commission=commission,
        slippage=slippage,
        total_cost=total_cost if action == 'BUY' else -proceeds
    )
    self.trades.append(trade)
```

## Acceptance Criteria

- [ ] Engine executes complete backtest from start to end date
- [ ] Rebalancing occurs at configured intervals (daily/weekly/monthly)
- [ ] Transaction costs (commission + slippage) applied to all trades
- [ ] Position sizing strategies work correctly:
  - [ ] Equal-weight allocation sums to 100% (or cash reserve)
  - [ ] Market-cap weighting respects weight caps
  - [ ] Minimum position size enforced
- [ ] Trade history captures all transactions with complete details
- [ ] Portfolio snapshots recorded at each rebalancing event
- [ ] Cash balance never goes negative (trade rejection when insufficient funds)
- [ ] Fractional shares handled appropriately (round down to integers)
- [ ] Performance: 1-year backtest with daily rebalancing completes in < 10 seconds
- [ ] Unit tests achieve > 90% code coverage

## Testing Strategy

### Unit Tests

```python
# tests/services/backtesting/test_engine.py
import pytest
from datetime import date
from decimal import Decimal
from app.services.backtesting.engine import BacktestEngine, BacktestConfig

class TestBacktestEngine:
    def test_should_rebalance_daily(self):
        """Test daily rebalancing logic"""
        config = BacktestConfig(
            initial_capital=Decimal('10000000'),
            rebalancing_period='daily'
        )
        engine = BacktestEngine(config)

        assert engine._should_rebalance(date(2024, 1, 1)) is True
        assert engine._should_rebalance(date(2024, 1, 2)) is True

    def test_should_rebalance_weekly(self):
        """Test weekly rebalancing on Monday"""
        config = BacktestConfig(
            initial_capital=Decimal('10000000'),
            rebalancing_period='weekly',
            rebalancing_day=0  # Monday
        )
        engine = BacktestEngine(config)

        # 2024-01-01 is Monday
        assert engine._should_rebalance(date(2024, 1, 1)) is True
        # 2024-01-02 is Tuesday
        assert engine._should_rebalance(date(2024, 1, 2)) is False

    def test_equal_weight_positions(self):
        """Test equal-weight position calculation"""
        config = BacktestConfig(
            initial_capital=Decimal('10000000'),
            position_sizing='equal_weight'
        )
        engine = BacktestEngine(config)

        symbols = ['005930', '000660', '035420']  # 3 stocks
        price_data = {
            '005930': create_mock_price_df(Decimal('70000')),
            '000660': create_mock_price_df(Decimal('50000')),
            '035420': create_mock_price_df(Decimal('100000'))
        }

        positions = engine._equal_weight_positions(
            symbols,
            date(2024, 1, 1),
            price_data
        )

        # Each position should be ~3.33M (10M / 3)
        total_value = sum(
            positions[s] * engine._get_price(s, date(2024, 1, 1), price_data)
            for s in positions
        )

        assert abs(total_value - Decimal('10000000')) < Decimal('100000')

    def test_transaction_costs(self):
        """Test commission and slippage calculation"""
        config = BacktestConfig(
            initial_capital=Decimal('10000000'),
            commission_rate=Decimal('0.0015'),
            slippage_rate=Decimal('0.001')
        )
        engine = BacktestEngine(config)

        price = Decimal('50000')
        quantity = 100

        commission, slippage = engine._apply_transaction_costs(
            '005930', quantity, price, 'BUY'
        )

        expected_commission = price * quantity * Decimal('0.0015')
        expected_slippage = price * quantity * Decimal('0.001')

        assert commission == expected_commission
        assert slippage == expected_slippage
```

### Integration Tests

- [ ] Full backtest simulation with real historical data
  - [ ] 1-year period with 100+ stocks
  - [ ] Verify all trades are logged
  - [ ] Verify portfolio value changes align with trades
- [ ] Multi-year backtest (3-5 years)
  - [ ] Test performance on extended periods
  - [ ] Verify survivorship bias handling
- [ ] Edge case testing
  - [ ] Stocks that get delisted during backtest
  - [ ] Extreme volatility periods (market crashes)
  - [ ] Insufficient liquidity scenarios

### Performance Tests

- [ ] Benchmark execution speed
  - [ ] 1-year daily rebalancing: < 10 seconds
  - [ ] 3-year weekly rebalancing: < 30 seconds
  - [ ] 10-year monthly rebalancing: < 60 seconds
- [ ] Memory usage profiling
  - [ ] Large universe (1000+ stocks): < 2GB RAM
  - [ ] Trade history storage optimization

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Look-ahead bias in data access | High | Critical | Strict date filtering, only use data available at simulation date |
| Survivorship bias (delisted stocks) | High | High | Include full universe with delisting dates, maintain historical composition |
| Unrealistic transaction costs | Medium | High | Calibrate costs to real broker data, add market impact for large orders |
| Memory overflow on long backtests | Medium | Medium | Implement streaming/chunking for multi-decade backtests |
| Floating point precision errors | Medium | Medium | Use Decimal type for all monetary calculations |
| Incorrect rebalancing logic | Low | High | Comprehensive unit tests, manual verification on known examples |

## Performance Requirements

- **Execution Speed**:
  - 1-year backtest (daily rebalancing, 200 stocks): < 10 seconds
  - 5-year backtest (weekly rebalancing, 500 stocks): < 60 seconds
  - 10-year backtest (monthly rebalancing, 1000 stocks): < 120 seconds

- **Memory Usage**:
  - Peak memory < 2GB for typical backtests
  - Trade history storage: < 100MB per 10,000 trades

- **Data Processing**:
  - Historical data loading: < 5 seconds for 5 years of daily data
  - Portfolio value calculation: < 100ms per rebalancing event

- **Scalability**:
  - Support up to 2000 stocks in universe
  - Handle up to 20 years of historical data
  - Support up to 100,000 simulated trades

## Security Considerations

- [ ] Validate all input parameters to prevent injection attacks
- [ ] Sanitize strategy code if user-defined (prevent arbitrary code execution)
- [ ] Rate limit backtesting API to prevent resource exhaustion
- [ ] Restrict data access to authorized date ranges only
- [ ] Log all backtest executions for audit trail
- [ ] Ensure user can only access their own backtest results

## Error Handling

### Graceful Degradation

```python
class BacktestEngine:
    async def simulate(self, ...) -> SimulationResult:
        try:
            # Main simulation logic
            ...
        except InsufficientDataError as e:
            # Missing historical data
            logger.warning(f"Insufficient data for backtest: {e}")
            raise HTTPException(
                status_code=400,
                detail=f"Historical data not available for period: {e.missing_period}"
            )
        except InvalidConfigurationError as e:
            # Invalid backtest parameters
            logger.error(f"Invalid configuration: {e}")
            raise HTTPException(
                status_code=422,
                detail=f"Invalid backtest configuration: {str(e)}"
            )
        except Exception as e:
            # Unexpected errors
            logger.exception("Backtest simulation failed")
            raise HTTPException(
                status_code=500,
                detail="Backtesting engine encountered an internal error"
            )

    def _execute_trade(self, ...) -> None:
        """Execute trade with error recovery"""
        try:
            # Trade execution logic
            ...
        except InsufficientFundsError:
            # Skip trade if insufficient cash
            logger.warning(
                f"Skipping trade {symbol} - insufficient funds "
                f"(need: {total_cost}, have: {self.cash})"
            )
            return
        except PriceDataMissingError as e:
            # Missing price data for symbol
            logger.warning(f"Missing price data for {symbol} on {date}")
            # Continue without this trade
            return
```

### Data Validation

```python
def validate_backtest_request(
    start_date: date,
    end_date: date,
    config: BacktestConfig
):
    """Validate backtest parameters"""
    # Date range validation
    if start_date >= end_date:
        raise ValueError("Start date must be before end date")

    if end_date > date.today():
        raise ValueError("End date cannot be in the future")

    max_backtest_years = 20
    if (end_date - start_date).days > max_backtest_years * 365:
        raise ValueError(f"Backtest period cannot exceed {max_backtest_years} years")

    # Configuration validation
    if config.initial_capital <= 0:
        raise ValueError("Initial capital must be positive")

    if config.commission_rate < 0 or config.commission_rate > 0.1:
        raise ValueError("Commission rate must be between 0% and 10%")

    if config.max_position_weight <= 0 or config.max_position_weight > 1:
        raise ValueError("Max position weight must be between 0 and 1")
```

## Dependencies

- **Depends on**:
  - TimescaleDB historical price data (2.4M+ rows)
  - Screening strategy execution engine
  - Market calendar for business day calculations

- **External Libraries**:
  - pandas: Historical data manipulation
  - numpy: Numerical calculations
  - decimal: Precise monetary calculations

- **Blocks**: BT-001b, BT-002, BT-005

## References

- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 2: Backtesting Engine
- **SRS.md**: Section 3.2 Backtesting Requirements
- **SDS.md**: Section 5.3 Backtesting Architecture
- [Quantopian Lecture Notes - Transaction Costs](https://www.quantopian.com/lectures)
- [Zipline Backtesting Library](https://github.com/quantopian/zipline)
- [Backtrader Documentation](https://www.backtrader.com/docu/)

## Progress

- **0%** - Not started

## Notes

- Use `Decimal` type for all monetary values to avoid floating-point precision errors
- Implement strict date filtering to prevent look-ahead bias
- Consider caching price data for frequently accessed symbols
- Log all assumptions (e.g., market-on-close execution) in trade records
- Future enhancement: support for shorting, leverage, and options strategies
- Future enhancement: intraday backtesting with minute-level data
