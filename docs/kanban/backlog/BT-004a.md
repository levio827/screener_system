# BT-004a: Backtesting Frontend - Configuration UI

## Metadata

| Field | Value |
|-------|-------|
| **ID** | BT-004a |
| **Title** | Build Backtesting Configuration UI |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P1 (High) |
| **Estimate** | 8 hours |
| **Sprint** | Sprint 6 |
| **Epic** | Backtesting Engine |
| **Assignee** | TBD |
| **Depends On** | BT-003 |
| **Blocks** | BT-004b |
| **Created** | 2025-11-29 |
| **Updated** | 2025-11-30 |
| **Tags** | `frontend`, `react`, `typescript`, `ui`, `forms`, `validation` |

## Description

Build comprehensive backtesting configuration UI with form components for strategy selection, parameter configuration, and validation. Includes visual strategy builder, transaction cost settings, benchmark selection, and real-time progress tracking during execution. The interface will provide an intuitive experience for configuring and launching backtests with proper error handling and user feedback.

## Acceptance Criteria

- [ ] **Configuration Form**
  - [ ] Date range picker (start/end date)
  - [ ] Strategy selection dropdown or custom filter builder
  - [ ] Initial capital input with validation
  - [ ] Rebalancing frequency selector (daily/weekly/monthly/quarterly)
  - [ ] Form validation with real-time error messages
  - [ ] Save configuration as template
- [ ] **Transaction Cost Settings**
  - [ ] Commission rate input (0-10%)
  - [ ] Slippage rate input (0-5%)
  - [ ] Preset buttons for common broker fees
  - [ ] Cost impact calculator/preview
- [ ] **Benchmark Configuration**
  - [ ] Benchmark symbol selector with autocomplete
  - [ ] Popular benchmarks quick selection (SPY, ^GSPC, etc.)
  - [ ] Custom benchmark upload option
- [ ] **Execution Controls**
  - [ ] Submit button with loading state
  - [ ] Cancel button for running backtest
  - [ ] Progress indicator (progress bar + percentage)
  - [ ] Real-time status updates via WebSocket
  - [ ] Estimated time remaining display
- [ ] **Backtest History**
  - [ ] List of user's previous backtests
  - [ ] Sortable columns (date, status, return)
  - [ ] Filter by status (completed/running/failed)
  - [ ] Quick view of key metrics
  - [ ] Load configuration from history
- [ ] **Responsive Design**
  - [ ] Mobile-friendly layout
  - [ ] Tablet optimized view
  - [ ] Desktop full-width layout

## Subtasks

### 1. Project Setup and Dependencies
- [ ] Install required packages
  - [ ] `react>=18.0.0` - UI library
  - [ ] `typescript>=5.0.0` - Type safety
  - [ ] `@tanstack/react-query>=5.0.0` - API state management
  - [ ] `react-hook-form>=7.48.0` - Form management
  - [ ] `zod>=3.22.0` - Schema validation
  - [ ] `date-fns>=3.0.0` - Date manipulation
  - [ ] `react-datepicker>=4.21.0` - Date picker component
  - [ ] `recharts>=2.10.0` - Charts for preview
  - [ ] `@headlessui/react>=1.7.0` - UI components
  - [ ] `tailwindcss>=3.3.0` - Styling
- [ ] Setup component structure
  - [ ] Create `components/backtest/` directory
  - [ ] Create `hooks/useBacktest.ts`
  - [ ] Create `types/backtest.ts`
  - [ ] Create `utils/validation.ts`

### 2. Type Definitions
- [ ] Define TypeScript interfaces
  - [ ] `BacktestConfig` - Configuration model
    - [ ] Strategy selection (ID or filter)
    - [ ] Date range
    - [ ] Capital and transaction costs
    - [ ] Rebalancing settings
    - [ ] Benchmark configuration
  - [ ] `BacktestFormData` - Form data
  - [ ] `BacktestStatus` - Status enum
  - [ ] `BacktestProgress` - Progress state
  - [ ] `BacktestTemplate` - Saved configuration
- [ ] Create validation schemas with Zod
  - [ ] Date range validation
  - [ ] Numeric input constraints
  - [ ] Required field validation

### 3. Form Components
- [ ] Create `BacktestConfigForm` component
  - [ ] Form layout with sections
  - [ ] Field grouping and organization
  - [ ] Responsive grid layout
  - [ ] Submit/cancel handlers
- [ ] Build `DateRangePicker` component
  - [ ] Start and end date inputs
  - [ ] Calendar popup
  - [ ] Preset ranges (1Y, 3Y, 5Y, Max)
  - [ ] Date range validation
  - [ ] Disable future dates
- [ ] Build `StrategySelector` component
  - [ ] Dropdown for saved strategies
  - [ ] Custom filter builder option
  - [ ] Strategy preview/description
  - [ ] Search/filter capabilities
- [ ] Build `CapitalInput` component
  - [ ] Numeric input with formatting
  - [ ] Currency symbol display
  - [ ] Min/max validation (1K - 10M)
  - [ ] Increment/decrement buttons
- [ ] Build `RebalancingSelector` component
  - [ ] Radio buttons or segmented control
  - [ ] Visual frequency representation
  - [ ] Description for each option
- [ ] Build `TransactionCostForm` component
  - [ ] Commission rate slider/input
  - [ ] Slippage rate slider/input
  - [ ] Preset buttons (Interactive Brokers, TD Ameritrade, etc.)
  - [ ] Cost impact preview
- [ ] Build `BenchmarkSelector` component
  - [ ] Autocomplete input
  - [ ] Popular benchmarks list
  - [ ] Symbol validation
  - [ ] Comparison preview

### 4. Strategy Builder UI
- [ ] Create visual filter builder
  - [ ] Drag-and-drop interface
  - [ ] Condition builder (AND/OR logic)
  - [ ] Metric selection dropdown
  - [ ] Operator selection (>, <, =, between)
  - [ ] Value input fields
- [ ] Implement filter preview
  - [ ] Show resulting SQL/filter logic
  - [ ] Estimated stock count
  - [ ] Save filter as strategy
- [ ] Add filter validation
  - [ ] Check for empty conditions
  - [ ] Validate metric existence
  - [ ] Ensure value types match

### 5. Progress Tracking Component
- [ ] Create `BacktestProgress` component
  - [ ] Progress bar with percentage
  - [ ] Status message display
  - [ ] Current processing date
  - [ ] Estimated time remaining
  - [ ] Cancel button
- [ ] Implement WebSocket connection
  - [ ] Connect on backtest start
  - [ ] Handle incoming progress messages
  - [ ] Update UI in real-time
  - [ ] Handle disconnect/reconnect
  - [ ] Clean up on unmount
- [ ] Add status indicators
  - [ ] Pending (gray)
  - [ ] Running (blue with animation)
  - [ ] Completed (green)
  - [ ] Failed (red with error)
  - [ ] Cancelled (orange)

### 6. Backtest History Component
- [ ] Create `BacktestHistory` component
  - [ ] Table with sortable columns
  - [ ] Pagination controls
  - [ ] Filter by status
  - [ ] Search by strategy name
- [ ] Implement table columns
  - [ ] Created date (sortable)
  - [ ] Strategy name
  - [ ] Date range
  - [ ] Status badge
  - [ ] Total return (if completed)
  - [ ] Actions (view, delete, reload config)
- [ ] Add row actions
  - [ ] View results (navigate to BT-004b)
  - [ ] Load configuration
  - [ ] Delete backtest
  - [ ] Download report

### 7. API Integration
- [ ] Create API hooks with React Query
  - [ ] `useCreateBacktest` - Submit backtest
  - [ ] `useBacktestStatus` - Poll status
  - [ ] `useBacktestHistory` - Fetch history
  - [ ] `useCancelBacktest` - Cancel running test
  - [ ] `useStrategies` - Fetch saved strategies
- [ ] Implement error handling
  - [ ] Display API errors in form
  - [ ] Rate limit error handling
  - [ ] Network error retry
  - [ ] Validation error display
- [ ] Add optimistic updates
  - [ ] Immediate feedback on submit
  - [ ] Optimistic status updates
  - [ ] Rollback on error

### 8. Form Validation
- [ ] Implement real-time validation
  - [ ] Validate on blur
  - [ ] Show errors inline
  - [ ] Disable submit on errors
  - [ ] Clear errors on fix
- [ ] Add custom validators
  - [ ] Date range validator (start < end)
  - [ ] Capital range validator (1K - 10M)
  - [ ] Future date prevention
  - [ ] Transaction cost limits
- [ ] Display validation messages
  - [ ] Field-level error messages
  - [ ] Form-level summary
  - [ ] Success messages
  - [ ] Warning for high costs

### 9. User Experience Enhancements
- [ ] Add loading states
  - [ ] Skeleton loaders for form
  - [ ] Spinner during submission
  - [ ] Disabled state for inputs
- [ ] Implement tooltips
  - [ ] Field help text
  - [ ] Metric explanations
  - [ ] Best practice tips
- [ ] Add confirmation dialogs
  - [ ] Confirm before cancel
  - [ ] Confirm before delete
  - [ ] Unsaved changes warning
- [ ] Create success feedback
  - [ ] Toast notifications
  - [ ] Success checkmark
  - [ ] Navigate to results option

### 10. Testing
- [ ] Unit tests
  - [ ] Test form validation logic
  - [ ] Test date range calculations
  - [ ] Test API hook behavior
  - [ ] Test validation schemas
- [ ] Component tests
  - [ ] Render all form fields
  - [ ] User interaction simulation
  - [ ] Form submission flow
  - [ ] Error display
- [ ] Integration tests
  - [ ] Full form submission
  - [ ] WebSocket connection
  - [ ] Progress tracking
  - [ ] History loading
- [ ] E2E tests
  - [ ] Complete backtest workflow
  - [ ] Form validation scenarios
  - [ ] Error handling
  - [ ] Mobile responsiveness

## Implementation Details

### Type Definitions

```typescript
// types/backtest.ts
import { z } from 'zod';

export const RebalancingFrequency = {
  DAILY: 'daily',
  WEEKLY: 'weekly',
  MONTHLY: 'monthly',
  QUARTERLY: 'quarterly',
} as const;

export type RebalancingFrequency = typeof RebalancingFrequency[keyof typeof RebalancingFrequency];

export const BacktestStatus = {
  PENDING: 'pending',
  RUNNING: 'running',
  COMPLETED: 'completed',
  FAILED: 'failed',
  CANCELLED: 'cancelled',
} as const;

export type BacktestStatus = typeof BacktestStatus[keyof typeof BacktestStatus];

// Zod validation schema
export const backtestConfigSchema = z.object({
  strategyId: z.number().optional(),
  filterCriteria: z.record(z.any()).optional(),
  startDate: z.date(),
  endDate: z.date(),
  initialCapital: z.number().min(1000).max(10_000_000),
  rebalancing: z.enum(['daily', 'weekly', 'monthly', 'quarterly']),
  commission: z.number().min(0).max(0.1),
  slippage: z.number().min(0).max(0.05),
  benchmark: z.string().optional(),
}).refine((data) => data.endDate > data.startDate, {
  message: "End date must be after start date",
  path: ["endDate"],
}).refine((data) => data.strategyId || data.filterCriteria, {
  message: "Either strategy or filter criteria is required",
  path: ["strategyId"],
});

export type BacktestConfig = z.infer<typeof backtestConfigSchema>;

export interface BacktestProgress {
  status: BacktestStatus;
  progress: number; // 0-100
  message?: string;
  currentDate?: string;
  estimatedTimeRemaining?: number; // seconds
  tradesExecuted?: number;
}

export interface BacktestHistoryItem {
  taskId: string;
  status: BacktestStatus;
  createdAt: string;
  completedAt?: string;
  strategyName?: string;
  dateRange: {
    start: string;
    end: string;
  };
  totalReturn?: number;
  sharpeRatio?: number;
}

export interface BacktestTemplate {
  id: string;
  name: string;
  description?: string;
  config: BacktestConfig;
  createdAt: string;
}
```

### Main Configuration Form Component

```typescript
// components/backtest/BacktestConfigForm.tsx
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { backtestConfigSchema, BacktestConfig } from '@/types/backtest';
import { useCreateBacktest } from '@/hooks/useBacktest';
import DateRangePicker from './DateRangePicker';
import StrategySelector from './StrategySelector';
import CapitalInput from './CapitalInput';
import RebalancingSelector from './RebalancingSelector';
import TransactionCostForm from './TransactionCostForm';
import BenchmarkSelector from './BenchmarkSelector';
import BacktestProgress from './BacktestProgress';

interface BacktestConfigFormProps {
  onSuccess?: (taskId: string) => void;
  initialValues?: Partial<BacktestConfig>;
}

export const BacktestConfigForm: React.FC<BacktestConfigFormProps> = ({
  onSuccess,
  initialValues,
}) => {
  const [activeTaskId, setActiveTaskId] = useState<string | null>(null);
  const createBacktest = useCreateBacktest();

  const {
    control,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    watch,
  } = useForm<BacktestConfig>({
    resolver: zodResolver(backtestConfigSchema),
    defaultValues: {
      startDate: new Date(new Date().setFullYear(new Date().getFullYear() - 3)),
      endDate: new Date(),
      initialCapital: 100000,
      rebalancing: 'monthly',
      commission: 0.001,
      slippage: 0.0005,
      ...initialValues,
    },
  });

  const onSubmit = async (data: BacktestConfig) => {
    try {
      const response = await createBacktest.mutateAsync(data);
      setActiveTaskId(response.taskId);
      onSuccess?.(response.taskId);
    } catch (error) {
      console.error('Failed to create backtest:', error);
    }
  };

  if (activeTaskId) {
    return (
      <BacktestProgress
        taskId={activeTaskId}
        onComplete={() => setActiveTaskId(null)}
        onCancel={() => setActiveTaskId(null)}
      />
    );
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-8">
      {/* Header */}
      <div className="border-b border-gray-200 pb-5">
        <h2 className="text-2xl font-bold text-gray-900">
          Configure Backtest
        </h2>
        <p className="mt-1 text-sm text-gray-600">
          Set up your backtesting parameters and run historical analysis
        </p>
      </div>

      {/* Strategy Selection */}
      <section>
        <h3 className="text-lg font-medium text-gray-900 mb-4">
          Strategy Selection
        </h3>
        <StrategySelector
          control={control}
          name="strategyId"
          error={errors.strategyId}
        />
      </section>

      {/* Time Period */}
      <section>
        <h3 className="text-lg font-medium text-gray-900 mb-4">
          Time Period
        </h3>
        <DateRangePicker
          control={control}
          startName="startDate"
          endName="endDate"
          errors={errors}
        />
      </section>

      {/* Portfolio Settings */}
      <section>
        <h3 className="text-lg font-medium text-gray-900 mb-4">
          Portfolio Settings
        </h3>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <CapitalInput
            control={control}
            name="initialCapital"
            error={errors.initialCapital}
          />
          <RebalancingSelector
            control={control}
            name="rebalancing"
            error={errors.rebalancing}
          />
        </div>
      </section>

      {/* Transaction Costs */}
      <section>
        <h3 className="text-lg font-medium text-gray-900 mb-4">
          Transaction Costs
        </h3>
        <TransactionCostForm
          control={control}
          commissionName="commission"
          slippageName="slippage"
          errors={errors}
        />
      </section>

      {/* Benchmark */}
      <section>
        <h3 className="text-lg font-medium text-gray-900 mb-4">
          Benchmark (Optional)
        </h3>
        <BenchmarkSelector
          control={control}
          name="benchmark"
          error={errors.benchmark}
        />
      </section>

      {/* Form Actions */}
      <div className="flex justify-end gap-4 pt-6 border-t border-gray-200">
        <button
          type="button"
          onClick={() => reset()}
          className="px-6 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50"
        >
          Reset
        </button>
        <button
          type="submit"
          disabled={isSubmitting}
          className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {isSubmitting ? 'Starting Backtest...' : 'Run Backtest'}
        </button>
      </div>

      {/* Error Summary */}
      {Object.keys(errors).length > 0 && (
        <div className="rounded-lg bg-red-50 p-4">
          <div className="flex">
            <div className="flex-shrink-0">
              <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
              </svg>
            </div>
            <div className="ml-3">
              <h3 className="text-sm font-medium text-red-800">
                Please fix the following errors:
              </h3>
              <ul className="mt-2 text-sm text-red-700 list-disc list-inside">
                {Object.entries(errors).map(([key, error]) => (
                  <li key={key}>{error?.message}</li>
                ))}
              </ul>
            </div>
          </div>
        </div>
      )}
    </form>
  );
};
```

### Progress Tracking Component

```typescript
// components/backtest/BacktestProgress.tsx
import React, { useEffect, useState } from 'react';
import { useBacktestProgress, useCancelBacktest } from '@/hooks/useBacktest';
import { BacktestProgress as ProgressType, BacktestStatus } from '@/types/backtest';

interface BacktestProgressProps {
  taskId: string;
  onComplete: () => void;
  onCancel: () => void;
}

export const BacktestProgress: React.FC<BacktestProgressProps> = ({
  taskId,
  onComplete,
  onCancel,
}) => {
  const { data: progress, isError } = useBacktestProgress(taskId);
  const cancelBacktest = useCancelBacktest();
  const [showCancelConfirm, setShowCancelConfirm] = useState(false);

  useEffect(() => {
    if (progress?.status === BacktestStatus.COMPLETED) {
      setTimeout(onComplete, 1000); // Delay for UX
    }
  }, [progress?.status, onComplete]);

  const handleCancel = async () => {
    try {
      await cancelBacktest.mutateAsync(taskId);
      onCancel();
    } catch (error) {
      console.error('Failed to cancel backtest:', error);
    }
  };

  const getStatusColor = (status: BacktestStatus) => {
    switch (status) {
      case BacktestStatus.PENDING:
        return 'bg-gray-200';
      case BacktestStatus.RUNNING:
        return 'bg-blue-500';
      case BacktestStatus.COMPLETED:
        return 'bg-green-500';
      case BacktestStatus.FAILED:
        return 'bg-red-500';
      case BacktestStatus.CANCELLED:
        return 'bg-orange-500';
      default:
        return 'bg-gray-200';
    }
  };

  const formatTimeRemaining = (seconds: number): string => {
    if (seconds < 60) return `${seconds}s`;
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m ${seconds % 60}s`;
    return `${Math.floor(seconds / 3600)}h ${Math.floor((seconds % 3600) / 60)}m`;
  };

  if (isError) {
    return (
      <div className="rounded-lg bg-red-50 p-6">
        <h3 className="text-lg font-medium text-red-800">
          Failed to track backtest progress
        </h3>
        <button
          onClick={onCancel}
          className="mt-4 px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700"
        >
          Close
        </button>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow-lg p-8">
      {/* Status Header */}
      <div className="text-center mb-8">
        <h2 className="text-2xl font-bold text-gray-900 mb-2">
          Backtest {progress?.status || 'Starting'}
        </h2>
        <p className="text-gray-600">{progress?.message || 'Initializing...'}</p>
      </div>

      {/* Progress Bar */}
      <div className="mb-6">
        <div className="flex justify-between text-sm text-gray-600 mb-2">
          <span>Progress</span>
          <span>{progress?.progress || 0}%</span>
        </div>
        <div className="w-full bg-gray-200 rounded-full h-4 overflow-hidden">
          <div
            className={`h-full transition-all duration-300 ${getStatusColor(progress?.status || BacktestStatus.PENDING)}`}
            style={{ width: `${progress?.progress || 0}%` }}
          >
            {progress?.status === BacktestStatus.RUNNING && (
              <div className="h-full w-full animate-pulse" />
            )}
          </div>
        </div>
      </div>

      {/* Status Details */}
      <div className="grid grid-cols-2 gap-4 mb-8">
        {progress?.currentDate && (
          <div className="text-center p-4 bg-gray-50 rounded-lg">
            <div className="text-sm text-gray-600 mb-1">Processing Date</div>
            <div className="text-lg font-semibold">
              {new Date(progress.currentDate).toLocaleDateString()}
            </div>
          </div>
        )}
        {progress?.estimatedTimeRemaining !== undefined && (
          <div className="text-center p-4 bg-gray-50 rounded-lg">
            <div className="text-sm text-gray-600 mb-1">Time Remaining</div>
            <div className="text-lg font-semibold">
              {formatTimeRemaining(progress.estimatedTimeRemaining)}
            </div>
          </div>
        )}
        {progress?.tradesExecuted !== undefined && (
          <div className="text-center p-4 bg-gray-50 rounded-lg">
            <div className="text-sm text-gray-600 mb-1">Trades Executed</div>
            <div className="text-lg font-semibold">
              {progress.tradesExecuted.toLocaleString()}
            </div>
          </div>
        )}
      </div>

      {/* Actions */}
      <div className="flex justify-center gap-4">
        {progress?.status === BacktestStatus.RUNNING && (
          <>
            {!showCancelConfirm ? (
              <button
                onClick={() => setShowCancelConfirm(true)}
                className="px-6 py-2 border border-red-300 text-red-700 rounded-lg hover:bg-red-50"
              >
                Cancel Backtest
              </button>
            ) : (
              <div className="flex gap-2">
                <button
                  onClick={handleCancel}
                  className="px-6 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700"
                >
                  Confirm Cancel
                </button>
                <button
                  onClick={() => setShowCancelConfirm(false)}
                  className="px-6 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
                >
                  Keep Running
                </button>
              </div>
            )}
          </>
        )}
        {progress?.status === BacktestStatus.COMPLETED && (
          <button
            onClick={onComplete}
            className="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700"
          >
            View Results
          </button>
        )}
      </div>
    </div>
  );
};
```

### API Hooks

```typescript
// hooks/useBacktest.ts
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { BacktestConfig, BacktestProgress, BacktestHistoryItem } from '@/types/backtest';
import { useWebSocket } from './useWebSocket';

const API_BASE = '/api/v1/backtest';

export const useCreateBacktest = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (config: BacktestConfig) => {
      const response = await fetch(API_BASE, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(config),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.detail || 'Failed to create backtest');
      }

      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['backtest', 'history'] });
    },
  });
};

export const useBacktestProgress = (taskId: string) => {
  const { data, isConnected } = useWebSocket<BacktestProgress>(
    `${API_BASE}/${taskId}/progress`
  );

  // Fallback to polling if WebSocket not available
  const pollingQuery = useQuery({
    queryKey: ['backtest', taskId, 'status'],
    queryFn: async () => {
      const response = await fetch(`${API_BASE}/${taskId}`);
      if (!response.ok) throw new Error('Failed to fetch status');
      return response.json();
    },
    enabled: !isConnected,
    refetchInterval: 2000, // Poll every 2 seconds
  });

  return isConnected ? { data, isError: false } : pollingQuery;
};

export const useBacktestHistory = (
  limit = 20,
  offset = 0,
  status?: string
) => {
  return useQuery({
    queryKey: ['backtest', 'history', { limit, offset, status }],
    queryFn: async () => {
      const params = new URLSearchParams({
        limit: limit.toString(),
        offset: offset.toString(),
        ...(status && { status }),
      });

      const response = await fetch(`${API_BASE}?${params}`);
      if (!response.ok) throw new Error('Failed to fetch history');
      return response.json() as Promise<BacktestHistoryItem[]>;
    },
  });
};

export const useCancelBacktest = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (taskId: string) => {
      const response = await fetch(`${API_BASE}/${taskId}`, {
        method: 'DELETE',
      });

      if (!response.ok) throw new Error('Failed to cancel backtest');
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['backtest'] });
    },
  });
};
```

### WebSocket Hook

```typescript
// hooks/useWebSocket.ts
import { useEffect, useState, useRef } from 'react';

interface UseWebSocketOptions {
  onOpen?: () => void;
  onClose?: () => void;
  onError?: (error: Event) => void;
  reconnect?: boolean;
  reconnectInterval?: number;
}

export const useWebSocket = <T>(
  url: string,
  options: UseWebSocketOptions = {}
) => {
  const [data, setData] = useState<T | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const wsRef = useRef<WebSocket | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();

  const {
    onOpen,
    onClose,
    onError,
    reconnect = true,
    reconnectInterval = 3000,
  } = options;

  useEffect(() => {
    const connect = () => {
      // Get auth token
      const token = localStorage.getItem('auth_token');
      const wsUrl = `${url.replace(/^http/, 'ws')}?token=${token}`;

      const ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        setIsConnected(true);
        onOpen?.();
      };

      ws.onmessage = (event) => {
        try {
          const parsed = JSON.parse(event.data);
          setData(parsed);
        } catch (error) {
          console.error('Failed to parse WebSocket message:', error);
        }
      };

      ws.onclose = () => {
        setIsConnected(false);
        onClose?.();

        if (reconnect) {
          reconnectTimeoutRef.current = setTimeout(connect, reconnectInterval);
        }
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        onError?.(error);
      };

      wsRef.current = ws;
    };

    connect();

    return () => {
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
      }
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, [url, reconnect, reconnectInterval, onOpen, onClose, onError]);

  return { data, isConnected };
};
```

## Testing Strategy

### Unit Tests

```typescript
// components/backtest/__tests__/BacktestConfigForm.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { BacktestConfigForm } from '../BacktestConfigForm';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient({
  defaultOptions: { queries: { retry: false } },
});

const wrapper = ({ children }: { children: React.ReactNode }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
);

describe('BacktestConfigForm', () => {
  it('renders all form sections', () => {
    render(<BacktestConfigForm />, { wrapper });

    expect(screen.getByText('Strategy Selection')).toBeInTheDocument();
    expect(screen.getByText('Time Period')).toBeInTheDocument();
    expect(screen.getByText('Portfolio Settings')).toBeInTheDocument();
    expect(screen.getByText('Transaction Costs')).toBeInTheDocument();
  });

  it('validates required fields', async () => {
    render(<BacktestConfigForm />, { wrapper });

    const submitButton = screen.getByText('Run Backtest');
    await userEvent.click(submitButton);

    await waitFor(() => {
      expect(screen.getByText(/strategy or filter criteria is required/i)).toBeInTheDocument();
    });
  });

  it('validates date range', async () => {
    render(<BacktestConfigForm />, { wrapper });

    // Set end date before start date
    const startDateInput = screen.getByLabelText(/start date/i);
    const endDateInput = screen.getByLabelText(/end date/i);

    await userEvent.clear(startDateInput);
    await userEvent.type(startDateInput, '2023-12-31');

    await userEvent.clear(endDateInput);
    await userEvent.type(endDateInput, '2023-01-01');

    await userEvent.click(screen.getByText('Run Backtest'));

    await waitFor(() => {
      expect(screen.getByText(/end date must be after start date/i)).toBeInTheDocument();
    });
  });

  it('validates capital range', async () => {
    render(<BacktestConfigForm />, { wrapper });

    const capitalInput = screen.getByLabelText(/initial capital/i);

    await userEvent.clear(capitalInput);
    await userEvent.type(capitalInput, '500'); // Below minimum

    await userEvent.click(screen.getByText('Run Backtest'));

    await waitFor(() => {
      expect(screen.getByText(/must be at least 1000/i)).toBeInTheDocument();
    });
  });

  it('submits valid form data', async () => {
    const onSuccess = jest.fn();
    render(<BacktestConfigForm onSuccess={onSuccess} />, { wrapper });

    // Fill in form...
    const submitButton = screen.getByText('Run Backtest');
    await userEvent.click(submitButton);

    await waitFor(() => {
      expect(onSuccess).toHaveBeenCalled();
    });
  });
});
```

### Integration Tests

```typescript
// components/backtest/__tests__/BacktestFlow.integration.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { BacktestConfigForm } from '../BacktestConfigForm';
import { server } from '@/mocks/server';
import { rest } from 'msw';

describe('Backtest Flow Integration', () => {
  it('completes full backtest workflow', async () => {
    // Mock API responses
    server.use(
      rest.post('/api/v1/backtest', (req, res, ctx) => {
        return res(ctx.json({
          taskId: 'test-task-123',
          status: 'pending',
          createdAt: new Date().toISOString(),
        }));
      })
    );

    render(<BacktestConfigForm />);

    // Select strategy
    await userEvent.click(screen.getByLabelText(/strategy/i));
    await userEvent.click(screen.getByText('Value Strategy'));

    // Set dates
    await userEvent.type(screen.getByLabelText(/start date/i), '2020-01-01');
    await userEvent.type(screen.getByLabelText(/end date/i), '2023-12-31');

    // Submit
    await userEvent.click(screen.getByText('Run Backtest'));

    // Verify progress component appears
    await waitFor(() => {
      expect(screen.getByText(/backtest running/i)).toBeInTheDocument();
    });

    // Verify progress updates
    await waitFor(() => {
      expect(screen.getByText(/50%/)).toBeInTheDocument();
    }, { timeout: 5000 });
  });
});
```

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Form validation edge cases | Medium | Low | Comprehensive unit tests, Zod schema validation, manual QA |
| WebSocket connection failures | Medium | Medium | Implement polling fallback, reconnection logic, user feedback |
| Browser compatibility issues | Low | Medium | Use modern browser features with polyfills, test on multiple browsers |
| Large form state management | Low | Medium | Use react-hook-form for performance, implement field-level validation |
| API rate limiting impact on UX | Medium | Low | Show rate limit status, queue requests, clear error messages |
| Mobile responsiveness issues | Medium | Medium | Implement responsive design, test on real devices, use CSS Grid/Flexbox |
| Date picker timezone issues | High | Medium | Use UTC consistently, display in user's timezone, clear date format |
| Unsaved changes loss | Medium | High | Implement auto-save to localStorage, confirm before navigation |
| Accessibility violations | Medium | Medium | ARIA labels, keyboard navigation, screen reader testing |
| Performance with large history | Low | Low | Implement pagination, virtual scrolling, query optimization |

## Performance Requirements

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| Initial page load | < 2s | Lighthouse, Web Vitals |
| Form interaction response | < 100ms | Performance API, React DevTools Profiler |
| WebSocket message handling | < 50ms | Custom timing, browser console |
| Form validation time | < 200ms | React Hook Form devtools |
| History list rendering | < 500ms for 100 items | React DevTools Profiler |
| Bundle size (gzipped) | < 150KB | webpack-bundle-analyzer |
| Accessibility score | > 95 | Lighthouse, axe DevTools |
| Mobile responsiveness | 100% coverage | BrowserStack, manual testing |

### Optimization Strategies

1. **Code Splitting**
   - Lazy load chart components
   - Separate routes for config and results
   - Dynamic imports for heavy libraries

2. **Memoization**
   - Memo expensive calculations
   - UseMemo for derived state
   - React.memo for components

3. **Debouncing**
   - Debounce validation (300ms)
   - Throttle WebSocket updates
   - Debounce search inputs

4. **Caching**
   - React Query caching
   - LocalStorage for form drafts
   - Service worker for assets

## Security Considerations

### Client-Side Security

- Store JWT in httpOnly cookies (not localStorage)
- Implement CSRF protection
- Sanitize all user inputs
- Validate API responses
- Use Content Security Policy
- Implement XSS protection

### Data Validation

```typescript
// Validate all inputs client-side before submission
const sanitizeInput = (input: string): string => {
  return input.replace(/[<>]/g, ''); // Basic XSS prevention
};

// Validate numeric inputs
const validateCapital = (value: number): boolean => {
  return !isNaN(value) && value >= 1000 && value <= 10_000_000;
};
```

### WebSocket Security

- Authenticate WebSocket connections with JWT
- Validate message origin
- Implement message rate limiting
- Close connections on auth failure
- Encrypt sensitive data

### Error Handling

- Don't expose sensitive errors to UI
- Log security events
- Implement error boundaries
- Graceful degradation
- User-friendly error messages

## Error Handling

### Form Errors

```typescript
// Field-level error display
{errors.initialCapital && (
  <p className="mt-1 text-sm text-red-600">
    {errors.initialCapital.message}
  </p>
)}

// Form-level error summary
{Object.keys(errors).length > 0 && (
  <div className="rounded-md bg-red-50 p-4">
    <h3 className="text-sm font-medium text-red-800">
      Please fix the following errors:
    </h3>
    <ul className="mt-2 text-sm text-red-700 list-disc list-inside">
      {Object.entries(errors).map(([key, error]) => (
        <li key={key}>{error.message}</li>
      ))}
    </ul>
  </div>
)}
```

### API Errors

```typescript
// Handle different error types
const handleApiError = (error: unknown) => {
  if (error instanceof Response) {
    if (error.status === 429) {
      toast.error('Rate limit exceeded. Please try again later.');
    } else if (error.status === 400) {
      toast.error('Invalid configuration. Please check your inputs.');
    } else {
      toast.error('An error occurred. Please try again.');
    }
  } else {
    toast.error('Network error. Please check your connection.');
  }
};
```

### Error Boundaries

```typescript
// Wrap components in error boundary
class BacktestErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Backtest error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="rounded-md bg-red-50 p-4">
          <h3 className="text-lg font-medium text-red-800">
            Something went wrong
          </h3>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

## Progress

**0% - Not started**

## Notes

### Implementation Priority

1. **Phase 1 (Core Form)**: Basic form with validation
2. **Phase 2 (Strategy Builder)**: Visual filter builder
3. **Phase 3 (Progress Tracking)**: WebSocket integration
4. **Phase 4 (History)**: History list and management

### Dependencies

- **BT-003**: Requires completed API endpoints
- **React Query**: For API state management
- **React Hook Form**: For form state and validation
- **Zod**: For schema validation

### Technical Decisions

1. **Why React Hook Form over Formik?**
   - Better performance (less re-renders)
   - Built-in validation
   - TypeScript support
   - Smaller bundle size

2. **Why Zod over Yup?**
   - Better TypeScript inference
   - More concise syntax
   - Better error messages
   - Active development

3. **Why WebSocket over polling?**
   - Real-time updates
   - Lower server load
   - Better UX
   - Fallback to polling if needed

### UI/UX Considerations

- Progressive disclosure (show advanced options on demand)
- Preset configurations for common use cases
- Visual feedback for all actions
- Responsive design for all devices
- Accessibility (WCAG 2.1 AA)
- Dark mode support (future)

### Browser Support

- Chrome 90+
- Firefox 88+
- Safari 14+
- Edge 90+
- Mobile browsers (iOS Safari, Chrome Mobile)

### Future Enhancements

- **Strategy templates**: Pre-configured backtest setups
- **Batch backtesting**: Run multiple configurations
- **Comparison mode**: Compare different strategies
- **Advanced filters**: Complex filter builder
- **Export configurations**: Save/share configs
- **Backtest scheduling**: Schedule recurring backtests
