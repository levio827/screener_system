# IND-002: Advanced Fundamental Indicators

## Metadata

| Field | Value |
|-------|-------|
| **ID** | IND-002 |
| **Title** | Add Advanced Fundamental Indicators |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P1 (High) |
| **Estimate** | 16 hours |
| **Sprint** | Sprint 5 |
| **Epic** | Extended Indicators |
| **Assignee** | TBD |
| **Created** | 2025-11-29 |
| **Tags** | `fundamental-analysis`, `valuation`, `financial-statements`, `quality-metrics` |
| **Blocks** | None |

## Description

Add advanced fundamental analysis indicators to provide comprehensive company valuation, quality assessment, financial stability, and growth metrics. This enhancement will enable sophisticated fundamental screening based on industry-standard metrics including ROIC, Altman Z-Score, Piotroski F-Score, and multi-year CAGR calculations.

The implementation will integrate financial statement data (income statement, balance sheet, cash flow statement) with the existing data pipeline to calculate 25 advanced fundamental indicators.

## New Indicators

```python
# Valuation
- ev_sales                        # EV/Sales
- ev_fcf                          # EV/FCF
- ev_ebit                         # EV/EBIT
- price_to_book_tangible          # P/TBV
- earnings_yield                  # Earnings Yield
- fcf_yield                       # FCF Yield

# Quality
- roic                            # Return on Invested Capital
- roce                            # Return on Capital Employed
- gross_profit_to_assets          # Gross Profitability
- asset_turnover                  # Asset Turnover
- inventory_turnover              # Inventory Turnover
- receivables_turnover            # Receivables Turnover

# Stability/Risk
- altman_z_score                  # Bankruptcy Risk Indicator
- beneish_m_score                 # Earnings Manipulation Detection
- piotroski_f_score               # Piotroski F-Score
- interest_coverage_ratio         # Interest Coverage Ratio
- cash_ratio                      # Cash Ratio
- quick_ratio                     # Quick Ratio

# Growth
- revenue_cagr_3y                 # 3-Year Revenue CAGR
- revenue_cagr_5y                 # 5-Year Revenue CAGR
- eps_cagr_3y                     # 3-Year EPS CAGR
- eps_cagr_5y                     # 5-Year EPS CAGR
- dividend_cagr_5y                # 5-Year Dividend CAGR

# Dividend
- dividend_payout_ratio           # Dividend Payout Ratio
- dividend_growth_rate            # Dividend Growth Rate
- dividend_consistency            # Dividend Consistency (years)
```

## Subtasks

- [ ] **Data Collection & Integration**
  - [ ] Integrate financial statement data sources (income statement, balance sheet, cash flow)
  - [ ] Create financial_statements table schema with historical data support
  - [ ] Implement ETL pipeline for quarterly and annual financial data
  - [ ] Add data validation and quality checks for financial data
- [ ] **Backend Implementation**
  - [ ] Implement valuation indicators (6 metrics)
  - [ ] Implement quality indicators (6 metrics)
  - [ ] Implement stability/risk indicators (6 metrics)
  - [ ] Implement growth indicators (5 metrics)
  - [ ] Implement dividend indicators (3 metrics)
  - [ ] Add comprehensive unit tests for each calculation
- [ ] **Advanced Scoring Systems**
  - [ ] Implement Altman Z-Score calculation and interpretation
  - [ ] Implement Beneish M-Score calculation
  - [ ] Implement Piotroski F-Score (9-point system)
  - [ ] Add sector-specific adjustments for scoring models
- [ ] **Data Pipeline Integration**
  - [ ] Update Airflow DAG for fundamental indicator calculations
  - [ ] Implement incremental update logic for quarterly earnings
  - [ ] Add backfill capability for historical fundamental data
  - [ ] Create monitoring for data freshness and completeness
- [ ] **API & Frontend Integration**
  - [ ] Update API endpoints to include fundamental indicators
  - [ ] Add fundamental screening filters to frontend
  - [ ] Create comparison views for peer analysis
  - [ ] Add educational tooltips explaining each metric

## Implementation Details

### Backend Calculation Example (Python)

```python
import pandas as pd
import numpy as np
from typing import Dict, Any, Optional
from dataclasses import dataclass
from enum import Enum

@dataclass
class FinancialStatements:
    """Financial statement data structure"""
    # Income Statement
    revenue: float
    gross_profit: float
    operating_income: float
    ebit: float
    net_income: float
    eps: float

    # Balance Sheet
    total_assets: float
    current_assets: float
    cash_and_equivalents: float
    inventory: float
    accounts_receivable: float
    total_liabilities: float
    current_liabilities: float
    long_term_debt: float
    shareholders_equity: float
    tangible_book_value: float

    # Cash Flow Statement
    operating_cash_flow: float
    free_cash_flow: float
    capital_expenditure: float

    # Market Data
    market_cap: float
    shares_outstanding: float
    stock_price: float

class FundamentalIndicators:
    """Calculate advanced fundamental indicators"""

    @staticmethod
    def calculate_valuation_metrics(fs: FinancialStatements) -> Dict[str, float]:
        """
        Calculate valuation indicators

        Args:
            fs: Financial statements data

        Returns:
            Dictionary of valuation metrics
        """
        # Enterprise Value = Market Cap + Total Debt - Cash
        enterprise_value = (
            fs.market_cap +
            fs.long_term_debt -
            fs.cash_and_equivalents
        )

        # EV/Sales
        ev_sales = enterprise_value / fs.revenue if fs.revenue > 0 else np.nan

        # EV/FCF
        ev_fcf = enterprise_value / fs.free_cash_flow if fs.free_cash_flow > 0 else np.nan

        # EV/EBIT
        ev_ebit = enterprise_value / fs.ebit if fs.ebit > 0 else np.nan

        # Price to Tangible Book Value
        price_to_book_tangible = (
            fs.market_cap / fs.tangible_book_value
            if fs.tangible_book_value > 0 else np.nan
        )

        # Earnings Yield (inverse of P/E)
        earnings_yield = (fs.net_income / fs.market_cap * 100) if fs.market_cap > 0 else np.nan

        # FCF Yield
        fcf_yield = (fs.free_cash_flow / fs.market_cap * 100) if fs.market_cap > 0 else np.nan

        return {
            'ev_sales': ev_sales,
            'ev_fcf': ev_fcf,
            'ev_ebit': ev_ebit,
            'price_to_book_tangible': price_to_book_tangible,
            'earnings_yield': earnings_yield,
            'fcf_yield': fcf_yield
        }

    @staticmethod
    def calculate_quality_metrics(fs: FinancialStatements) -> Dict[str, float]:
        """
        Calculate quality indicators

        Args:
            fs: Financial statements data

        Returns:
            Dictionary of quality metrics
        """
        # ROIC = NOPAT / Invested Capital
        # NOPAT = EBIT * (1 - tax_rate), assuming 25% tax rate
        nopat = fs.ebit * 0.75
        invested_capital = fs.shareholders_equity + fs.long_term_debt
        roic = (nopat / invested_capital * 100) if invested_capital > 0 else np.nan

        # ROCE = EBIT / Capital Employed
        # Capital Employed = Total Assets - Current Liabilities
        capital_employed = fs.total_assets - fs.current_liabilities
        roce = (fs.ebit / capital_employed * 100) if capital_employed > 0 else np.nan

        # Gross Profitability
        gross_profit_to_assets = (
            fs.gross_profit / fs.total_assets * 100
        ) if fs.total_assets > 0 else np.nan

        # Asset Turnover
        asset_turnover = fs.revenue / fs.total_assets if fs.total_assets > 0 else np.nan

        # Inventory Turnover
        # Cost of Goods Sold = Revenue - Gross Profit
        cogs = fs.revenue - fs.gross_profit
        inventory_turnover = cogs / fs.inventory if fs.inventory > 0 else np.nan

        # Receivables Turnover
        receivables_turnover = (
            fs.revenue / fs.accounts_receivable
        ) if fs.accounts_receivable > 0 else np.nan

        return {
            'roic': roic,
            'roce': roce,
            'gross_profit_to_assets': gross_profit_to_assets,
            'asset_turnover': asset_turnover,
            'inventory_turnover': inventory_turnover,
            'receivables_turnover': receivables_turnover
        }

    @staticmethod
    def calculate_altman_z_score(fs: FinancialStatements) -> float:
        """
        Calculate Altman Z-Score for bankruptcy prediction

        Z-Score Formula:
        Z = 1.2*X1 + 1.4*X2 + 3.3*X3 + 0.6*X4 + 1.0*X5

        Where:
        X1 = Working Capital / Total Assets
        X2 = Retained Earnings / Total Assets
        X3 = EBIT / Total Assets
        X4 = Market Cap / Total Liabilities
        X5 = Sales / Total Assets

        Interpretation:
        Z > 2.99: Safe Zone
        1.81 < Z < 2.99: Grey Zone
        Z < 1.81: Distress Zone

        Args:
            fs: Financial statements data

        Returns:
            Altman Z-Score
        """
        if fs.total_assets == 0 or fs.total_liabilities == 0:
            return np.nan

        working_capital = fs.current_assets - fs.current_liabilities

        x1 = working_capital / fs.total_assets
        x2 = (fs.shareholders_equity - fs.market_cap / fs.shares_outstanding * fs.shares_outstanding) / fs.total_assets
        x3 = fs.ebit / fs.total_assets
        x4 = fs.market_cap / fs.total_liabilities
        x5 = fs.revenue / fs.total_assets

        z_score = 1.2*x1 + 1.4*x2 + 3.3*x3 + 0.6*x4 + 1.0*x5

        return z_score

    @staticmethod
    def calculate_piotroski_f_score(current_fs: FinancialStatements,
                                    prior_fs: FinancialStatements) -> int:
        """
        Calculate Piotroski F-Score (9-point scoring system)

        Profitability (4 points):
        1. Positive net income
        2. Positive operating cash flow
        3. Increasing ROA
        4. Operating cash flow > Net income (quality of earnings)

        Leverage/Liquidity (3 points):
        5. Decreasing long-term debt
        6. Increasing current ratio
        7. No new shares issued

        Operating Efficiency (2 points):
        8. Increasing gross margin
        9. Increasing asset turnover

        Args:
            current_fs: Current period financial statements
            prior_fs: Prior period financial statements

        Returns:
            F-Score (0-9)
        """
        score = 0

        # Profitability
        if current_fs.net_income > 0:
            score += 1

        if current_fs.operating_cash_flow > 0:
            score += 1

        current_roa = current_fs.net_income / current_fs.total_assets
        prior_roa = prior_fs.net_income / prior_fs.total_assets
        if current_roa > prior_roa:
            score += 1

        if current_fs.operating_cash_flow > current_fs.net_income:
            score += 1

        # Leverage/Liquidity
        if current_fs.long_term_debt < prior_fs.long_term_debt:
            score += 1

        current_ratio = current_fs.current_assets / current_fs.current_liabilities
        prior_ratio = prior_fs.current_assets / prior_fs.current_liabilities
        if current_ratio > prior_ratio:
            score += 1

        if current_fs.shares_outstanding <= prior_fs.shares_outstanding:
            score += 1

        # Operating Efficiency
        current_margin = current_fs.gross_profit / current_fs.revenue
        prior_margin = prior_fs.gross_profit / prior_fs.revenue
        if current_margin > prior_margin:
            score += 1

        current_turnover = current_fs.revenue / current_fs.total_assets
        prior_turnover = prior_fs.revenue / prior_fs.total_assets
        if current_turnover > prior_turnover:
            score += 1

        return score

    @staticmethod
    def calculate_growth_cagr(values: list, periods: int) -> float:
        """
        Calculate Compound Annual Growth Rate

        CAGR = (Ending Value / Beginning Value)^(1/periods) - 1

        Args:
            values: List of values over time (oldest to newest)
            periods: Number of periods

        Returns:
            CAGR as percentage
        """
        if len(values) < 2 or values[0] <= 0 or values[-1] <= 0:
            return np.nan

        beginning_value = values[0]
        ending_value = values[-1]

        cagr = (pow(ending_value / beginning_value, 1/periods) - 1) * 100

        return cagr

# Airflow DAG Integration
from airflow import DAG
from airflow.operators.python import PythonOperator
from datetime import datetime, timedelta

def fetch_and_calculate_fundamentals(**context):
    """Fetch financial statements and calculate fundamental indicators"""
    from sqlalchemy import create_engine
    import os

    engine = create_engine(os.getenv('DATABASE_URL'))

    # Fetch financial statement data
    query = """
        SELECT
            stock_code,
            fiscal_period,
            revenue,
            gross_profit,
            ebit,
            net_income,
            total_assets,
            current_assets,
            total_liabilities,
            current_liabilities,
            long_term_debt,
            shareholders_equity,
            operating_cash_flow,
            free_cash_flow
        FROM financial_statements
        WHERE fiscal_period >= NOW() - INTERVAL '5 years'
        ORDER BY stock_code, fiscal_period
    """

    df = pd.read_sql(query, engine)

    # Fetch market data
    market_query = """
        SELECT stock_code, market_cap, shares_outstanding, close as stock_price
        FROM stocks s
        JOIN stock_prices p ON s.code = p.stock_code
        WHERE p.date = (SELECT MAX(date) FROM stock_prices)
    """
    market_df = pd.read_sql(market_query, engine)

    results = []

    for stock_code in df['stock_code'].unique():
        stock_data = df[df['stock_code'] == stock_code].sort_values('fiscal_period')

        if len(stock_data) < 1:
            continue

        # Get latest financial data
        latest = stock_data.iloc[-1]
        market_data = market_df[market_df['stock_code'] == stock_code].iloc[0]

        # Create FinancialStatements object
        fs = FinancialStatements(
            revenue=latest['revenue'],
            gross_profit=latest['gross_profit'],
            operating_income=latest['ebit'],
            ebit=latest['ebit'],
            net_income=latest['net_income'],
            eps=latest['net_income'] / market_data['shares_outstanding'],
            total_assets=latest['total_assets'],
            current_assets=latest['current_assets'],
            cash_and_equivalents=latest.get('cash', 0),
            inventory=latest.get('inventory', 0),
            accounts_receivable=latest.get('receivables', 0),
            total_liabilities=latest['total_liabilities'],
            current_liabilities=latest['current_liabilities'],
            long_term_debt=latest['long_term_debt'],
            shareholders_equity=latest['shareholders_equity'],
            tangible_book_value=latest.get('tangible_book_value', latest['shareholders_equity']),
            operating_cash_flow=latest['operating_cash_flow'],
            free_cash_flow=latest['free_cash_flow'],
            capital_expenditure=latest.get('capex', 0),
            market_cap=market_data['market_cap'],
            shares_outstanding=market_data['shares_outstanding'],
            stock_price=market_data['stock_price']
        )

        # Calculate all fundamental indicators
        valuation = FundamentalIndicators.calculate_valuation_metrics(fs)
        quality = FundamentalIndicators.calculate_quality_metrics(fs)
        altman_z = FundamentalIndicators.calculate_altman_z_score(fs)

        # Calculate growth metrics
        revenue_5y = stock_data.tail(5)['revenue'].tolist()
        revenue_cagr_5y = FundamentalIndicators.calculate_growth_cagr(revenue_5y, 5)

        indicator_data = {
            'stock_code': stock_code,
            'date': datetime.now().date(),
            **valuation,
            **quality,
            'altman_z_score': altman_z,
            'revenue_cagr_5y': revenue_cagr_5y
        }

        results.append(indicator_data)

    # Store results
    results_df = pd.DataFrame(results)
    results_df.to_sql('calculated_indicators', engine, if_exists='append', index=False)

default_args = {
    'owner': 'airflow',
    'depends_on_past': False,
    'start_date': datetime(2025, 11, 29),
    'email_on_failure': True,
    'retries': 2,
    'retry_delay': timedelta(minutes=5),
}

dag = DAG(
    'calculate_fundamental_indicators',
    default_args=default_args,
    description='Calculate advanced fundamental indicators',
    schedule_interval='0 2 * * *',  # Daily at 2 AM
    catchup=False,
)

calc_task = PythonOperator(
    task_id='calculate_fundamentals',
    python_callable=fetch_and_calculate_fundamentals,
    dag=dag,
)
```

## Testing Strategy

### Unit Tests

```python
import pytest
from fundamental_indicators import FundamentalIndicators, FinancialStatements

class TestFundamentalIndicators:

    @pytest.fixture
    def sample_financials(self):
        """Create sample financial data"""
        return FinancialStatements(
            revenue=1_000_000_000,
            gross_profit=400_000_000,
            operating_income=200_000_000,
            ebit=200_000_000,
            net_income=150_000_000,
            eps=3.0,
            total_assets=2_000_000_000,
            current_assets=800_000_000,
            cash_and_equivalents=200_000_000,
            inventory=150_000_000,
            accounts_receivable=100_000_000,
            total_liabilities=800_000_000,
            current_liabilities=300_000_000,
            long_term_debt=400_000_000,
            shareholders_equity=1_200_000_000,
            tangible_book_value=1_000_000_000,
            operating_cash_flow=180_000_000,
            free_cash_flow=120_000_000,
            capital_expenditure=60_000_000,
            market_cap=1_500_000_000,
            shares_outstanding=50_000_000,
            stock_price=30.0
        )

    def test_valuation_metrics(self, sample_financials):
        """Test valuation indicator calculations"""
        result = FundamentalIndicators.calculate_valuation_metrics(sample_financials)

        # Check all metrics are calculated
        assert 'ev_sales' in result
        assert 'ev_fcf' in result
        assert 'fcf_yield' in result

        # Verify FCF yield calculation
        expected_fcf_yield = (120_000_000 / 1_500_000_000) * 100
        assert abs(result['fcf_yield'] - expected_fcf_yield) < 0.01

    def test_quality_metrics(self, sample_financials):
        """Test quality indicator calculations"""
        result = FundamentalIndicators.calculate_quality_metrics(sample_financials)

        # Check ROIC is reasonable
        assert 'roic' in result
        assert 0 < result['roic'] < 100

        # Check asset turnover
        expected_turnover = 1_000_000_000 / 2_000_000_000
        assert abs(result['asset_turnover'] - expected_turnover) < 0.01

    def test_altman_z_score(self, sample_financials):
        """Test Altman Z-Score calculation"""
        z_score = FundamentalIndicators.calculate_altman_z_score(sample_financials)

        # Z-Score should be in reasonable range
        assert -10 < z_score < 20

        # This sample should be in safe zone (> 2.99)
        assert z_score > 2.0

    def test_piotroski_f_score(self, sample_financials):
        """Test Piotroski F-Score calculation"""
        # Create prior period with slightly lower metrics
        prior_financials = FinancialStatements(
            **{**sample_financials.__dict__, 'net_income': 140_000_000}
        )

        score = FundamentalIndicators.calculate_piotroski_f_score(
            sample_financials,
            prior_financials
        )

        # Score should be between 0 and 9
        assert 0 <= score <= 9
        assert isinstance(score, int)

    def test_cagr_calculation(self):
        """Test CAGR calculation"""
        # 100 growing to 150 over 3 years
        values = [100, 120, 135, 150]
        cagr = FundamentalIndicators.calculate_growth_cagr(values, 3)

        # CAGR should be approximately 14.5%
        assert 14 < cagr < 15

    def test_handles_zero_values(self):
        """Test handling of zero/negative values"""
        bad_financials = FinancialStatements(
            revenue=0,
            total_assets=0,
            market_cap=0,
            **{k: 0 for k in FinancialStatements.__dataclass_fields__.keys()}
        )

        result = FundamentalIndicators.calculate_valuation_metrics(bad_financials)

        # Should return NaN for invalid calculations
        assert pd.isna(result['ev_sales'])
```

### Integration Tests

```python
def test_financial_data_integration():
    """Test integration with financial_statements table"""
    from sqlalchemy import create_engine
    import os

    engine = create_engine(os.getenv('TEST_DATABASE_URL'))

    # Verify financial_statements table structure
    query = "SELECT * FROM financial_statements LIMIT 1"
    df = pd.read_sql(query, engine)

    required_columns = ['stock_code', 'fiscal_period', 'revenue', 'net_income',
                       'total_assets', 'shareholders_equity']

    for col in required_columns:
        assert col in df.columns

def test_quarterly_update_pipeline():
    """Test quarterly earnings update workflow"""
    # Mock quarterly earnings release
    # Verify that new fundamental indicators are calculated
    # Check that historical values are preserved
    pass
```

## Acceptance Criteria

- [ ] 25 new fundamental indicator calculation logic implemented and tested
- [ ] Financial statement data integration complete with quarterly and annual data
- [ ] Airflow DAG updated for daily fundamental indicator calculation
- [ ] All indicators added to screening filters with industry comparisons
- [ ] Unit tests achieve >90% code coverage
- [ ] API documentation includes formulas and interpretation guides
- [ ] Frontend displays sector averages for comparison
- [ ] Performance: Complete calculation for all stocks within 30 minutes

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Financial data quality issues | High | High | Implement robust data validation, cross-reference multiple sources, add outlier detection |
| Formula calculation errors | Medium | High | Validate against known values, use peer-reviewed formulas, comprehensive unit tests |
| Missing historical data for CAGR | Medium | Medium | Implement graceful degradation, show partial data with warnings, backfill from archives |
| Sector-specific metric interpretation | High | Medium | Add sector normalization, provide industry benchmarks, include percentile rankings |
| Data source API rate limits | Medium | Low | Implement caching, schedule off-peak updates, use multiple data providers |
| Accounting standard differences (IFRS vs GAAP) | Low | Medium | Document assumptions, add standard detection, normalize key metrics |

## Performance Requirements

- **Calculation Time**: < 30 minutes for all stocks (daily batch)
- **API Response Time**: < 300ms for fundamental indicator queries
- **Database Query Performance**: < 200ms for historical financial data retrieval
- **Memory Usage**: < 4GB during batch processing
- **Data Freshness**: Updated within 24 hours of earnings release
- **Historical Data**: Maintain at least 10 years of financial history

## Security Considerations

- **Data Source Authentication**: Secure API keys for financial data providers
- **Data Validation**: Validate all financial inputs to prevent manipulation
- **Access Control**: Restrict calculation trigger endpoints to authorized users
- **Audit Trail**: Log all fundamental indicator calculations with source data references
- **Data Integrity**: Implement checksums for financial statement data
- **PII Protection**: Ensure no personal financial information is exposed
- **Rate Limiting**: Limit fundamental data API requests to prevent abuse

## Error Handling

```python
class FundamentalCalculationError(Exception):
    """Base exception for fundamental calculation errors"""
    pass

class MissingFinancialDataError(FundamentalCalculationError):
    """Raised when required financial data is missing"""
    pass

def safe_calculate_fundamentals(stock_code: str, engine) -> Dict[str, Any]:
    """
    Safely calculate fundamental indicators with error handling

    Args:
        stock_code: Stock identifier
        engine: Database engine

    Returns:
        Dictionary of calculated indicators
    """
    import logging
    logger = logging.getLogger(__name__)

    try:
        # Fetch financial data with validation
        query = """
            SELECT * FROM financial_statements
            WHERE stock_code = %s
            ORDER BY fiscal_period DESC
            LIMIT 8
        """
        df = pd.read_sql(query, engine, params=[stock_code])

        if df.empty:
            raise MissingFinancialDataError(f"No financial data for {stock_code}")

        # Validate required fields
        required_fields = ['revenue', 'total_assets', 'shareholders_equity']
        latest = df.iloc[0]

        for field in required_fields:
            if pd.isna(latest.get(field)) or latest.get(field) == 0:
                logger.warning(f"Missing or zero {field} for {stock_code}")

        # Calculate indicators with individual error handling
        results = {}

        try:
            fs = create_financial_statements_object(latest)
            results.update(FundamentalIndicators.calculate_valuation_metrics(fs))
        except Exception as e:
            logger.error(f"Valuation calculation failed for {stock_code}: {e}")
            results.update({'ev_sales': None, 'ev_fcf': None, 'fcf_yield': None})

        try:
            if len(df) >= 2:
                current_fs = create_financial_statements_object(df.iloc[0])
                prior_fs = create_financial_statements_object(df.iloc[1])
                results['piotroski_f_score'] = FundamentalIndicators.calculate_piotroski_f_score(
                    current_fs, prior_fs
                )
        except Exception as e:
            logger.error(f"Piotroski F-Score failed for {stock_code}: {e}")
            results['piotroski_f_score'] = None

        return results

    except MissingFinancialDataError:
        logger.warning(f"Skipping {stock_code} - insufficient data")
        raise
    except Exception as e:
        logger.error(f"Unexpected error for {stock_code}: {e}")
        raise FundamentalCalculationError(f"Calculation failed: {e}") from e
```

## Dependencies

- **Technical**: pandas >= 1.3.0, numpy >= 1.21.0, SQLAlchemy >= 1.4.0
- **Data Sources**: Financial statement APIs (e.g., Financial Modeling Prep, Alpha Vantage)
- **Infrastructure**: Airflow >= 2.5.0, PostgreSQL >= 13
- **External**: financial_statements table schema, market data table
- **Blocked By**: Financial data source integration
- **Blocks**: Sector comparison features, peer analysis tools

## Notes

- Consider implementing sector-specific adjustments for metrics (e.g., different Z-Score thresholds for financial vs manufacturing)
- Add support for multiple accounting standards (IFRS, GAAP)
- Implement trend analysis showing metric evolution over time
- Consider adding analyst consensus estimates integration
- Plan for handling special events (mergers, spinoffs, stock splits)
- Document interpretation guidelines for each metric
- Consider implementing custom composite scores combining multiple metrics
- Add alerts for significant metric changes (e.g., Z-Score dropping below threshold)

## Progress

**Status**: 0% - Not started

**Next Steps**:
1. Design financial_statements table schema with historical support
2. Integrate financial data API (select provider)
3. Implement and test valuation metrics calculations
4. Implement quality and stability metrics
5. Add Altman Z-Score and Piotroski F-Score

## References

- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 5: Extended Indicators
- [Investopedia - ROIC](https://www.investopedia.com/terms/r/returnoninvestmentcapital.asp)
- [Altman Z-Score Paper](https://www.investopedia.com/terms/a/altman.asp)
- [Piotroski F-Score Research](https://www.investopedia.com/terms/p/piotroski-score.asp)
- [Beneish M-Score](https://en.wikipedia.org/wiki/Beneish_M-Score)
