# IND-003: Supply-Demand Indicators

## Metadata

| Field | Value |
|-------|-------|
| **ID** | IND-003 |
| **Title** | Add Supply-Demand (수급) Indicators |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P1 (High) |
| **Estimate** | 16 hours |
| **Sprint** | Sprint 6 |
| **Epic** | Extended Indicators |
| **Assignee** | TBD |
| **Created** | 2025-11-29 |
| **Tags** | `supply-demand`, `korea-market`, `institutional-data`, `foreign-ownership`, `short-selling` |
| **Blocks** | None |

## Description

Add Korea market-specific supply-demand indicators to provide insights into investor behavior and market microstructure. This feature implements 20 new indicators tracking net buying patterns by investor type (foreign, institutional, individual), ownership ratios, short selling activity, and margin/lending balances.

These indicators are critical for Korean market analysis as they reveal the flow of capital between different investor groups and can signal potential price movements before they occur in the price data itself.

## New Indicators

```python
# Net Buying by Investor Type (Flow Analysis)
- foreign_net_buy_1d              # Foreign Net Buy (1 Day) - Daily foreign investor flow
- foreign_net_buy_5d              # Foreign Net Buy (5 Days) - Weekly foreign trend
- foreign_net_buy_20d             # Foreign Net Buy (20 Days) - Monthly foreign trend
- institution_net_buy_1d          # Institution Net Buy (1 Day) - Daily institutional flow
- institution_net_buy_5d          # Institution Net Buy (5 Days) - Weekly institutional trend
- institution_net_buy_20d         # Institution Net Buy (20 Days) - Monthly institutional trend
- individual_net_buy_1d           # Individual Net Buy (1 Day) - Daily retail flow

# Ownership Ratios (Stock Analysis)
- foreign_ownership_pct           # Foreign Ownership % - Total foreign holdings
- foreign_ownership_change_1m     # Foreign Ownership Change (1 Month) - Trend direction
- institution_ownership_pct       # Institution Ownership % - Total institutional holdings
- major_shareholder_pct           # Major Shareholder % - Insider/controlling shareholder %

# Short Selling (Sentiment Analysis)
- short_balance                   # Short Balance - Total shares sold short
- short_ratio                     # Short Ratio - Short interest as % of float
- short_balance_change_1w         # Short Balance Change (1 Week) - Trend in short interest
- days_to_cover                   # Days to Cover - Short interest / avg daily volume

# Margin/Stock Lending (Leverage Analysis)
- credit_balance                  # Credit Balance - Total margin buying
- credit_ratio                    # Credit Ratio - Credit balance / market cap
- loan_balance                    # Stock Lending Balance - Total shares lent
- loan_ratio                      # Loan Ratio - Loan balance / float
```

## Subtasks

- [ ] **Data Source Integration**
  - [ ] Research and document KRX API endpoints for investor data
  - [ ] Implement KRX Information Data System API client
  - [ ] Integrate Korea Financial Investment Association (KOFIA) data
  - [ ] Setup Korea Securities Depository (KSD) data pipeline
  - [ ] Implement authentication and API key management
  - [ ] Add rate limiting and retry logic for external APIs
  - [ ] Create data validation rules for external data quality
- [ ] **Backend Calculation Logic**
  - [ ] Implement net buying calculations (7 indicators)
  - [ ] Implement ownership ratio calculations (4 indicators)
  - [ ] Implement short selling metrics (4 indicators)
  - [ ] Implement margin/lending calculations (4 indicators)
  - [ ] Add unit tests for each calculation
  - [ ] Validate against official KRX published data
- [ ] **Data Pipeline Integration**
  - [ ] Create Airflow DAG for daily data collection
  - [ ] Implement incremental data updates (avoid full refresh)
  - [ ] Add data quality checks and anomaly detection
  - [ ] Setup error notification for data collection failures
  - [ ] Implement backfill script for historical data (1+ years)
  - [ ] Add monitoring for data freshness and completeness
- [ ] **Database Schema Updates**
  - [ ] Add 20 new columns to calculated_indicators table
  - [ ] Create indexes on frequently queried columns
  - [ ] Implement data retention policy for historical data
  - [ ] Add constraints and validation at database level
- [ ] **API Integration**
  - [ ] Update API schema to include supply-demand indicators
  - [ ] Add filtering capabilities for supply-demand data
  - [ ] Implement aggregation endpoints (sector/industry summaries)
  - [ ] Update API documentation with field descriptions
- [ ] **Frontend Implementation**
  - [ ] Add supply-demand filters to screening UI
  - [ ] Implement supply-demand trend chart component
  - [ ] Add investor flow visualization (stacked bar chart)
  - [ ] Create ownership breakdown pie chart
  - [ ] Add tooltips explaining each indicator
  - [ ] Implement data export functionality

## Implementation Details

### Data Source Integration (Python)

```python
import requests
from typing import Dict, List, Optional
from datetime import datetime, timedelta
import logging

class KRXDataClient:
    """Client for fetching supply-demand data from KRX APIs"""

    BASE_URL = "http://data.krx.co.kr/comm/bldAttendant/getJsonData.cmd"

    def __init__(self, timeout: int = 30):
        self.session = requests.Session()
        self.timeout = timeout
        self.logger = logging.getLogger(__name__)

    def get_investor_trading(self, date: str, market: str = "STK") -> List[Dict]:
        """
        Fetch investor trading data (foreign, institutional, individual)

        Args:
            date: Trading date in YYYYMMDD format
            market: Market code (STK=KOSPI, KSQ=KOSDAQ)

        Returns:
            List of dictionaries with investor trading data per stock
        """
        payload = {
            "bld": "dbms/MDC/STAT/standard/MDCSTAT02303",
            "locale": "ko_KR",
            "trdDd": date,
            "mktId": market,
            "share": "1",
            "money": "1",
            "csvxls_isNo": "false"
        }

        try:
            response = self.session.post(
                self.BASE_URL,
                data=payload,
                timeout=self.timeout
            )
            response.raise_for_status()
            data = response.json()

            return data.get("OutBlock_1", [])

        except requests.exceptions.RequestException as e:
            self.logger.error(f"Failed to fetch investor trading data: {e}")
            raise

    def get_foreign_ownership(self, date: str) -> List[Dict]:
        """
        Fetch foreign ownership data

        Args:
            date: Date in YYYYMMDD format

        Returns:
            List of foreign ownership data per stock
        """
        payload = {
            "bld": "dbms/MDC/STAT/standard/MDCSTAT03702",
            "locale": "ko_KR",
            "trdDd": date,
            "csvxls_isNo": "false"
        }

        try:
            response = self.session.post(
                self.BASE_URL,
                data=payload,
                timeout=self.timeout
            )
            response.raise_for_status()
            data = response.json()

            return data.get("OutBlock_1", [])

        except requests.exceptions.RequestException as e:
            self.logger.error(f"Failed to fetch foreign ownership: {e}")
            raise

    def get_short_selling_data(self, date: str) -> List[Dict]:
        """
        Fetch short selling balance data

        Args:
            date: Date in YYYYMMDD format

        Returns:
            Short selling data per stock
        """
        payload = {
            "bld": "dbms/MDC/STAT/standard/MDCSTAT03901",
            "locale": "ko_KR",
            "trdDd": date,
            "csvxls_isNo": "false"
        }

        try:
            response = self.session.post(
                self.BASE_URL,
                data=payload,
                timeout=self.timeout
            )
            response.raise_for_status()
            data = response.json()

            return data.get("OutBlock_1", [])

        except requests.exceptions.RequestException as e:
            self.logger.error(f"Failed to fetch short selling data: {e}")
            raise

class SupplyDemandCalculator:
    """Calculate supply-demand indicators from raw data"""

    @staticmethod
    def calculate_net_buying(df: pd.DataFrame) -> Dict[str, float]:
        """
        Calculate net buying indicators

        Args:
            df: DataFrame with columns: date, foreign_buy, foreign_sell,
                institution_buy, institution_sell, individual_buy, individual_sell

        Returns:
            Dictionary of net buying indicators
        """
        # Calculate net values
        df['foreign_net'] = df['foreign_buy'] - df['foreign_sell']
        df['institution_net'] = df['institution_buy'] - df['institution_sell']
        df['individual_net'] = df['individual_buy'] - df['individual_sell']

        # Get latest row for 1-day values
        latest = df.iloc[-1]

        return {
            'foreign_net_buy_1d': latest['foreign_net'],
            'foreign_net_buy_5d': df['foreign_net'].tail(5).sum(),
            'foreign_net_buy_20d': df['foreign_net'].tail(20).sum(),
            'institution_net_buy_1d': latest['institution_net'],
            'institution_net_buy_5d': df['institution_net'].tail(5).sum(),
            'institution_net_buy_20d': df['institution_net'].tail(20).sum(),
            'individual_net_buy_1d': latest['individual_net']
        }

    @staticmethod
    def calculate_ownership_ratios(
        foreign_shares: int,
        institution_shares: int,
        major_shareholder_shares: int,
        total_shares: int,
        prev_month_foreign_pct: float
    ) -> Dict[str, float]:
        """
        Calculate ownership ratio indicators

        Args:
            foreign_shares: Total shares held by foreign investors
            institution_shares: Total shares held by institutions
            major_shareholder_shares: Shares held by major shareholders (>1%)
            total_shares: Total outstanding shares
            prev_month_foreign_pct: Foreign ownership % from 1 month ago

        Returns:
            Dictionary of ownership indicators
        """
        foreign_pct = (foreign_shares / total_shares) * 100
        institution_pct = (institution_shares / total_shares) * 100
        major_pct = (major_shareholder_shares / total_shares) * 100

        return {
            'foreign_ownership_pct': foreign_pct,
            'foreign_ownership_change_1m': foreign_pct - prev_month_foreign_pct,
            'institution_ownership_pct': institution_pct,
            'major_shareholder_pct': major_pct
        }

    @staticmethod
    def calculate_short_metrics(
        short_balance: int,
        total_shares: int,
        avg_daily_volume: float,
        prev_week_short_balance: int
    ) -> Dict[str, float]:
        """
        Calculate short selling indicators

        Args:
            short_balance: Current short balance (shares)
            total_shares: Total outstanding shares
            avg_daily_volume: Average daily trading volume (20-day)
            prev_week_short_balance: Short balance from 1 week ago

        Returns:
            Dictionary of short selling indicators
        """
        short_ratio = (short_balance / total_shares) * 100
        days_to_cover = short_balance / avg_daily_volume if avg_daily_volume > 0 else 0
        short_change = short_balance - prev_week_short_balance

        return {
            'short_balance': short_balance,
            'short_ratio': short_ratio,
            'short_balance_change_1w': short_change,
            'days_to_cover': days_to_cover
        }

    @staticmethod
    def calculate_margin_metrics(
        credit_balance: int,
        loan_balance: int,
        market_cap: float,
        float_shares: int
    ) -> Dict[str, float]:
        """
        Calculate margin/lending indicators

        Args:
            credit_balance: Total credit balance (KRW)
            loan_balance: Total stock lending balance (shares)
            market_cap: Market capitalization (KRW)
            float_shares: Free float shares

        Returns:
            Dictionary of margin/lending indicators
        """
        credit_ratio = (credit_balance / market_cap) * 100 if market_cap > 0 else 0
        loan_ratio = (loan_balance / float_shares) * 100 if float_shares > 0 else 0

        return {
            'credit_balance': credit_balance,
            'credit_ratio': credit_ratio,
            'loan_balance': loan_balance,
            'loan_ratio': loan_ratio
        }

# Airflow DAG Implementation
from airflow import DAG
from airflow.operators.python import PythonOperator
from datetime import datetime, timedelta

def collect_supply_demand_data(**context):
    """Collect and store supply-demand data"""
    from sqlalchemy import create_engine
    import pandas as pd
    import os

    engine = create_engine(os.getenv('DATABASE_URL'))
    client = KRXDataClient()
    calculator = SupplyDemandCalculator()

    # Get target date (yesterday for T+1 settlement)
    target_date = (datetime.now() - timedelta(days=1)).strftime('%Y%m%d')

    # Fetch data from all sources
    investor_data = client.get_investor_trading(target_date)
    ownership_data = client.get_foreign_ownership(target_date)
    short_data = client.get_short_selling_data(target_date)

    # Process each stock
    results = []
    for stock_data in investor_data:
        stock_code = stock_data['ISU_SRT_CD']

        # Fetch historical data for calculations
        hist_query = f"""
            SELECT * FROM investor_trading
            WHERE stock_code = '{stock_code}'
            AND date >= NOW() - INTERVAL '30 days'
            ORDER BY date
        """
        hist_df = pd.read_sql(hist_query, engine)

        # Calculate all indicators
        net_buying = calculator.calculate_net_buying(hist_df)

        # Combine results
        indicator_data = {
            'stock_code': stock_code,
            'date': target_date,
            **net_buying,
            # Add ownership, short, and margin data...
        }
        results.append(indicator_data)

    # Bulk insert
    results_df = pd.DataFrame(results)
    results_df.to_sql(
        'supply_demand_indicators',
        engine,
        if_exists='append',
        index=False
    )

    logging.info(f"Processed {len(results)} stocks for date {target_date}")

default_args = {
    'owner': 'airflow',
    'depends_on_past': False,
    'start_date': datetime(2025, 11, 29),
    'email_on_failure': True,
    'email': ['alerts@screener.com'],
    'email_on_retry': False,
    'retries': 3,
    'retry_delay': timedelta(minutes=5),
}

dag = DAG(
    'collect_supply_demand_data',
    default_args=default_args,
    description='Collect supply-demand indicators from KRX',
    schedule_interval='0 19 * * 1-5',  # 7PM on weekdays (after market close)
    catchup=False,
    tags=['supply-demand', 'krx', 'korea-market']
)

collect_task = PythonOperator(
    task_id='collect_supply_demand',
    python_callable=collect_supply_demand_data,
    dag=dag,
)
```

### Frontend Visualization (React + D3.js)

```typescript
import React, { useEffect, useState } from 'react';
import * as d3 from 'd3';

interface InvestorFlow {
  date: string;
  foreign: number;
  institution: number;
  individual: number;
}

const SupplyDemandChart: React.FC<{ stockCode: string }> = ({ stockCode }) => {
  const [data, setData] = useState<InvestorFlow[]>([]);

  useEffect(() => {
    // Fetch supply-demand data
    fetch(`/api/stocks/${stockCode}/supply-demand?period=30d`)
      .then(res => res.json())
      .then(setData);
  }, [stockCode]);

  useEffect(() => {
    if (data.length === 0) return;

    const margin = { top: 20, right: 80, bottom: 30, left: 50 };
    const width = 800 - margin.left - margin.right;
    const height = 400 - margin.top - margin.bottom;

    // Clear previous chart
    d3.select('#investor-flow-chart').selectAll('*').remove();

    const svg = d3.select('#investor-flow-chart')
      .append('svg')
      .attr('width', width + margin.left + margin.right)
      .attr('height', height + margin.top + margin.bottom)
      .append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);

    // Scales
    const x = d3.scaleTime()
      .domain(d3.extent(data, d => new Date(d.date)) as [Date, Date])
      .range([0, width]);

    const y = d3.scaleLinear()
      .domain([
        d3.min(data, d => Math.min(d.foreign, d.institution, d.individual)) as number,
        d3.max(data, d => Math.max(d.foreign, d.institution, d.individual)) as number
      ])
      .range([height, 0]);

    // Lines
    const line = d3.line<InvestorFlow>()
      .x(d => x(new Date(d.date)))
      .y(d => y(d.foreign));

    // Add three lines for each investor type
    svg.append('path')
      .datum(data)
      .attr('fill', 'none')
      .attr('stroke', '#ff6b6b')
      .attr('stroke-width', 2)
      .attr('d', d3.line<InvestorFlow>()
        .x(d => x(new Date(d.date)))
        .y(d => y(d.foreign))
      );

    svg.append('path')
      .datum(data)
      .attr('fill', 'none')
      .attr('stroke', '#4ecdc4')
      .attr('stroke-width', 2)
      .attr('d', d3.line<InvestorFlow>()
        .x(d => x(new Date(d.date)))
        .y(d => y(d.institution))
      );

    svg.append('path')
      .datum(data)
      .attr('fill', 'none')
      .attr('stroke', '#95e1d3')
      .attr('stroke-width', 2)
      .attr('d', d3.line<InvestorFlow>()
        .x(d => x(new Date(d.date)))
        .y(d => y(d.individual))
      );

    // Axes
    svg.append('g')
      .attr('transform', `translate(0,${height})`)
      .call(d3.axisBottom(x));

    svg.append('g')
      .call(d3.axisLeft(y));

    // Legend
    const legend = svg.append('g')
      .attr('transform', `translate(${width - 100}, 20)`);

    legend.append('line')
      .attr('x1', 0).attr('x2', 20)
      .attr('stroke', '#ff6b6b').attr('stroke-width', 2);
    legend.append('text')
      .attr('x', 25).attr('y', 5)
      .text('Foreign');

    legend.append('line')
      .attr('x1', 0).attr('x2', 20).attr('y1', 20).attr('y2', 20)
      .attr('stroke', '#4ecdc4').attr('stroke-width', 2);
    legend.append('text')
      .attr('x', 25).attr('y', 25)
      .text('Institution');

    legend.append('line')
      .attr('x1', 0).attr('x2', 20).attr('y1', 40).attr('y2', 40)
      .attr('stroke', '#95e1d3').attr('stroke-width', 2);
    legend.append('text')
      .attr('x', 25).attr('y', 45)
      .text('Individual');

  }, [data]);

  return (
    <div>
      <h3>Investor Flow Analysis</h3>
      <div id="investor-flow-chart"></div>
    </div>
  );
};

export default SupplyDemandChart;
```

## Testing Strategy

### Unit Tests

```python
import pytest
import pandas as pd
from datetime import datetime, timedelta
from supply_demand import SupplyDemandCalculator

class TestSupplyDemandCalculators:

    @pytest.fixture
    def sample_trading_data(self):
        """Create sample investor trading data"""
        dates = pd.date_range('2025-11-01', periods=30)
        data = pd.DataFrame({
            'date': dates,
            'foreign_buy': [1000000 + i * 1000 for i in range(30)],
            'foreign_sell': [900000 + i * 500 for i in range(30)],
            'institution_buy': [800000 + i * 800 for i in range(30)],
            'institution_sell': [750000 + i * 700 for i in range(30)],
            'individual_buy': [500000 + i * 300 for i in range(30)],
            'individual_sell': [550000 + i * 400 for i in range(30)]
        })
        return data

    def test_net_buying_calculation(self, sample_trading_data):
        """Test net buying calculations are correct"""
        result = SupplyDemandCalculator.calculate_net_buying(sample_trading_data)

        # Check all keys present
        expected_keys = [
            'foreign_net_buy_1d', 'foreign_net_buy_5d', 'foreign_net_buy_20d',
            'institution_net_buy_1d', 'institution_net_buy_5d', 'institution_net_buy_20d',
            'individual_net_buy_1d'
        ]
        for key in expected_keys:
            assert key in result

        # Verify 1-day calculation
        latest_foreign_net = sample_trading_data.iloc[-1]['foreign_buy'] - \
                            sample_trading_data.iloc[-1]['foreign_sell']
        assert result['foreign_net_buy_1d'] == latest_foreign_net

        # Verify cumulative calculations are positive for net buying
        assert isinstance(result['foreign_net_buy_5d'], (int, float))
        assert isinstance(result['foreign_net_buy_20d'], (int, float))

    def test_ownership_ratios(self):
        """Test ownership ratio calculations"""
        result = SupplyDemandCalculator.calculate_ownership_ratios(
            foreign_shares=1000000,
            institution_shares=2000000,
            major_shareholder_shares=3000000,
            total_shares=10000000,
            prev_month_foreign_pct=9.5
        )

        # Check percentages
        assert result['foreign_ownership_pct'] == 10.0
        assert result['institution_ownership_pct'] == 20.0
        assert result['major_shareholder_pct'] == 30.0

        # Check change calculation
        assert result['foreign_ownership_change_1m'] == 0.5  # 10.0 - 9.5

    def test_short_metrics(self):
        """Test short selling metrics"""
        result = SupplyDemandCalculator.calculate_short_metrics(
            short_balance=100000,
            total_shares=10000000,
            avg_daily_volume=50000,
            prev_week_short_balance=90000
        )

        assert result['short_balance'] == 100000
        assert result['short_ratio'] == 1.0  # 100000 / 10000000 * 100
        assert result['days_to_cover'] == 2.0  # 100000 / 50000
        assert result['short_balance_change_1w'] == 10000

    def test_margin_metrics(self):
        """Test margin/lending metrics"""
        result = SupplyDemandCalculator.calculate_margin_metrics(
            credit_balance=1000000000,  # 1 billion KRW
            loan_balance=50000,          # 50k shares
            market_cap=100000000000,     # 100 billion KRW
            float_shares=5000000         # 5 million shares
        )

        assert result['credit_balance'] == 1000000000
        assert result['credit_ratio'] == 1.0  # 1B / 100B * 100
        assert result['loan_balance'] == 50000
        assert result['loan_ratio'] == 1.0  # 50k / 5M * 100

    def test_zero_division_handling(self):
        """Test that zero division is handled gracefully"""
        result = SupplyDemandCalculator.calculate_short_metrics(
            short_balance=100000,
            total_shares=10000000,
            avg_daily_volume=0,  # Zero volume
            prev_week_short_balance=90000
        )

        assert result['days_to_cover'] == 0  # Should not raise exception

### Integration Tests

```python
def test_krx_api_integration():
    """Test KRX API client can fetch real data"""
    client = KRXDataClient()

    # Use yesterday's date (market data is T+1)
    yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y%m%d')

    # Fetch investor trading data
    data = client.get_investor_trading(yesterday)

    assert data is not None
    assert len(data) > 0
    assert 'ISU_SRT_CD' in data[0]  # Stock code

def test_airflow_dag_validation():
    """Test Airflow DAG structure"""
    from airflow.models import DagBag

    dagbag = DagBag(dag_folder='dags/')
    dag = dagbag.get_dag('collect_supply_demand_data')

    assert dag is not None
    assert len(dag.tasks) == 1
    assert 'collect_supply_demand' in [task.task_id for task in dag.tasks]

def test_database_storage():
    """Test data is correctly stored in database"""
    from sqlalchemy import create_engine, text
    import os

    engine = create_engine(os.getenv('TEST_DATABASE_URL'))

    # Insert test data
    test_data = {
        'stock_code': '005930',
        'date': '20251129',
        'foreign_net_buy_1d': 1000000,
        'foreign_ownership_pct': 52.5
    }

    with engine.connect() as conn:
        conn.execute(
            text("""
                INSERT INTO supply_demand_indicators
                (stock_code, date, foreign_net_buy_1d, foreign_ownership_pct)
                VALUES (:stock_code, :date, :foreign_net_buy_1d, :foreign_ownership_pct)
            """),
            test_data
        )
        conn.commit()

        # Verify retrieval
        result = conn.execute(
            text("SELECT * FROM supply_demand_indicators WHERE stock_code = :code"),
            {'code': '005930'}
        ).fetchone()

        assert result is not None
        assert result.foreign_net_buy_1d == 1000000
```

## Acceptance Criteria

- [ ] External data source API integration with KRX, KOFIA, and KSD
- [ ] Daily data collection DAG running successfully at 7PM KST
- [ ] 20 supply-demand indicator calculations implemented and tested
- [ ] Screening filter integration with all 20 indicators
- [ ] Supply-demand trend chart UI with investor flow visualization
- [ ] Data validation ensures 95%+ accuracy vs. official KRX data
- [ ] API response time < 200ms for supply-demand endpoints
- [ ] Historical backfill completed for at least 1 year of data
- [ ] Frontend tooltips explain each indicator clearly

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| KRX API changes without notice | High | High | Implement API version monitoring, create alerts for failed requests, maintain documentation of API structure |
| Data delays or unavailability | Medium | High | Implement retry logic with exponential backoff, cache previous day's data, add manual override capability |
| Calculation discrepancies with official data | Medium | Medium | Validate against KRX published reports weekly, implement automated reconciliation checks |
| Foreign ownership data incomplete | Low | Medium | Implement data quality checks, flag stocks with missing data, provide estimated values with disclaimers |
| Rate limiting by external APIs | Medium | Low | Implement request throttling, use appropriate delays between requests, request higher rate limits |
| Database storage costs for historical data | Low | Low | Implement data archival strategy, compress old data, use partitioning |

## Performance Requirements

- **Data Collection Time**: Complete all stocks within 30 minutes
- **API Response Time**: < 200ms for supply-demand indicator endpoints
- **Database Query Time**: < 100ms for filtered queries
- **Memory Usage**: < 1GB during data collection process
- **Airflow DAG Success Rate**: > 99% (failures should auto-retry)
- **Data Freshness**: Updated daily by 8PM KST

## Security Considerations

- **API Key Management**: Store KRX API keys in secure vault (HashiCorp Vault, AWS Secrets Manager)
- **Data Access Control**: Restrict supply-demand data access to authenticated users only
- **Rate Limiting**: Implement rate limits to prevent API abuse
- **Data Validation**: Sanitize all external data inputs to prevent injection attacks
- **Audit Logging**: Log all external API calls with timestamps and response codes
- **Error Handling**: Avoid exposing API credentials in error messages
- **Compliance**: Ensure data usage complies with KRX terms of service

## Error Handling

```python
class SupplyDemandDataError(Exception):
    """Base exception for supply-demand data errors"""
    pass

class APIConnectionError(SupplyDemandDataError):
    """Raised when external API is unreachable"""
    pass

class DataValidationError(SupplyDemandDataError):
    """Raised when data fails validation checks"""
    pass

def safe_collect_supply_demand_data(stock_code: str, date: str) -> Optional[Dict]:
    """
    Safely collect supply-demand data with error handling

    Args:
        stock_code: Stock code (e.g., '005930')
        date: Date in YYYYMMDD format

    Returns:
        Dictionary of indicators or None if failed

    Raises:
        APIConnectionError: If API is unreachable
        DataValidationError: If data is invalid
    """
    import logging
    logger = logging.getLogger(__name__)

    max_retries = 3
    retry_delay = 5  # seconds

    for attempt in range(max_retries):
        try:
            client = KRXDataClient()

            # Fetch data with timeout
            investor_data = client.get_investor_trading(date)
            ownership_data = client.get_foreign_ownership(date)
            short_data = client.get_short_selling_data(date)

            # Find stock in results
            stock_investor = next(
                (item for item in investor_data if item['ISU_SRT_CD'] == stock_code),
                None
            )

            if stock_investor is None:
                logger.warning(f"Stock {stock_code} not found in investor data for {date}")
                return None

            # Validate data quality
            if not validate_supply_demand_data(stock_investor):
                raise DataValidationError(f"Invalid data for {stock_code}")

            # Calculate indicators
            calculator = SupplyDemandCalculator()
            indicators = {
                **calculator.calculate_net_buying(build_historical_df(stock_code)),
                # ... other calculations
            }

            return indicators

        except requests.exceptions.Timeout:
            logger.warning(f"Attempt {attempt + 1}/{max_retries}: Timeout fetching data")
            if attempt < max_retries - 1:
                time.sleep(retry_delay * (attempt + 1))
            else:
                raise APIConnectionError("API timeout after all retries")

        except requests.exceptions.RequestException as e:
            logger.error(f"API connection error: {e}")
            raise APIConnectionError(f"Failed to connect to KRX API: {e}")

        except DataValidationError as e:
            logger.error(f"Data validation failed: {e}")
            raise

        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            raise SupplyDemandDataError(f"Unexpected error: {e}")

def validate_supply_demand_data(data: Dict) -> bool:
    """Validate supply-demand data quality"""
    required_fields = ['ISU_SRT_CD', 'TDD_CLSPRC', 'ACC_TRDVOL']

    # Check required fields
    for field in required_fields:
        if field not in data or data[field] is None:
            return False

    # Check value ranges
    if float(data.get('TDD_CLSPRC', 0)) <= 0:
        return False

    return True
```

## Dependencies

- **Technical**: requests >= 2.28.0, pandas >= 1.3.0, apache-airflow >= 2.5.0
- **External APIs**: KRX Information Data System, KOFIA API, KSD API
- **Infrastructure**: Airflow data pipeline, PostgreSQL database
- **Database**: calculated_indicators table with new columns
- **Blocked By**: None
- **Blocks**: Supply-demand based trading strategies, institutional flow alerts

## Notes

- KRX publishes data with T+1 delay, so yesterday's data is collected at 7PM
- Foreign ownership data is reported monthly, so daily changes are estimates
- Short selling data excludes market making activities
- Credit balance includes both margin trading and short selling collateral
- Consider adding investor sentiment score (composite indicator)
- Plan for real-time websocket integration for institutional flow alerts
- Document correlation between foreign buying and next-day price movements
- Consider adding sector-level aggregations for market overview

## Progress

**Status**: 0% - Not started

**Next Steps**:
1. Research and document KRX API endpoints and authentication requirements
2. Setup development environment with API credentials
3. Implement KRXDataClient with basic investor trading data fetch
4. Create database migration for new supply_demand_indicators table

## Data Sources

- **KRX Information Data System**: http://data.krx.co.kr
  - Investor trading data (daily)
  - Foreign ownership data (daily)
  - Short selling balance (daily)
- **Korea Financial Investment Association (KOFIA)**: https://www.kofia.or.kr
  - Margin trading balance (daily)
  - Stock lending balance (daily)
- **Korea Securities Depository (KSD)**: https://www.ksd.or.kr
  - Shareholder data (monthly)
  - Major shareholder holdings (quarterly)

## References

- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 5: Extended Indicators
- [KRX Open API Documentation](http://data.krx.co.kr/contents/MDC/MAIN/main/index.cmd)
- [KOFIA Market Data](https://www.kofia.or.kr/wpge/m_58/info01.do)
- [Short Selling Regulations in Korea](https://www.fsc.go.kr)
