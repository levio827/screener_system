# KR-001: DART Integration

## Metadata

| Field | Value |
|-------|-------|
| **ID** | KR-001 |
| **Title** | Integrate DART Electronic Disclosure |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P0 (Critical) |
| **Estimate** | 16 hours |
| **Sprint** | Sprint 6 |
| **Epic** | Korea Market Specialization |
| **Assignee** | TBD |
| **Created** | 2025-11-29 |
| **Tags** | i18n, korean-market, api-integration, real-time |
| **Blocks** | KR-002, KR-003 |

## Description

Integrate with DART (Data Analysis, Retrieval and Transfer System), the Korean electronic disclosure system operated by the Financial Supervisory Service. This system provides real-time access to corporate disclosures including financial reports, major events, and shareholder information. The integration will enable users to track important corporate events and regulatory filings for Korean stocks in real-time.

## Subtasks

- [ ] **DART API Integration**
  - [ ] Register for DART Open API access key
  - [ ] Implement API client with authentication
  - [ ] Handle API rate limits (100 requests/day for free tier)
  - [ ] Implement request retry logic with exponential backoff
  - [ ] Set up API response caching (5-minute TTL for real-time data)
- [ ] **Data Collection Service**
  - [ ] Create background job for periodic disclosure fetching
  - [ ] Implement incremental updates (fetch only new disclosures)
  - [ ] Parse disclosure XML/JSON responses
  - [ ] Normalize disclosure data to internal format
  - [ ] Handle Korean encoding (UTF-8, EUC-KR)
- [ ] **Database Schema**
  - [ ] Design `dart_disclosures` table schema
  - [ ] Create indexes for fast lookup (stock_code, disclosure_type, date)
  - [ ] Implement full-text search for Korean content
  - [ ] Set up data retention policy (keep 5 years of data)
- [ ] **Disclosure Type Categorization**
  - [ ] Map DART report codes to internal categories
  - [ ] Implement importance ranking algorithm
  - [ ] Create Korean-English terminology mapping
  - [ ] Set up disclosure type filters
- [ ] **Alert System**
  - [ ] Design user preference schema for disclosure alerts
  - [ ] Implement real-time notification service
  - [ ] Create email/push notification templates (Korean)
  - [ ] Add alert priority levels (critical, high, medium, low)
- [ ] **Localization**
  - [ ] Add Korean disclosure terminology to i18n resources
  - [ ] Implement Korean date formatting (YYYY년 MM월 DD일)
  - [ ] Format large numbers with Korean conventions (억원, 만주)
  - [ ] Ensure Hangul rendering with proper fonts

## Disclosure Types

### Periodic Reports
- Annual reports (사업보고서)
- Semi-annual reports (반기보고서)
- Quarterly reports (분기보고서)

### Major Event Reports
- Business matters (주요사항보고)
- Earnings announcements (영업실적)
- Corporate governance (지배구조)

### Issuance Disclosures
- Stock issuance (유상증자)
- Bond issuance (회사채발행)
- Stock retirement (자기주식소각)

### Ownership Disclosures
- Major shareholder changes (주요주주변동)
- Officer changes (임원변동)
- Treasury stock transactions (자기주식취득/처분)

### Other Major Business Matters
- Mergers & acquisitions (합병, 인수)
- Asset transactions (자산양수도)
- Legal proceedings (소송)
- Credit rating changes (신용등급변동)

## Implementation Details

### DART API Client

```python
from typing import List, Optional, Dict
import aiohttp
import asyncio
from datetime import datetime, date
from dataclasses import dataclass
import xml.etree.ElementTree as ET

@dataclass
class DartDisclosure:
    """DART disclosure data model"""
    corp_code: str
    corp_name: str
    stock_code: str
    report_nm: str  # Report name in Korean
    rcept_no: str   # Receipt number (unique ID)
    flr_nm: str     # Filer name
    rcept_dt: date  # Receipt date
    rm: Optional[str] = None  # Remarks

class DartAPIClient:
    """DART Open API client"""

    BASE_URL = "https://opendart.fss.or.kr/api"

    def __init__(self, api_key: str):
        self.api_key = api_key
        self.session: Optional[aiohttp.ClientSession] = None

    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    async def get_disclosures(
        self,
        corp_code: str,
        bgn_de: date,
        end_de: date,
        page_no: int = 1,
        page_count: int = 100
    ) -> List[DartDisclosure]:
        """
        Fetch disclosures for a specific company

        Args:
            corp_code: DART company code
            bgn_de: Start date
            end_de: End date
            page_no: Page number (1-based)
            page_count: Items per page (max 100)

        Returns:
            List of disclosures
        """
        params = {
            "crtfc_key": self.api_key,
            "corp_code": corp_code,
            "bgn_de": bgn_de.strftime("%Y%m%d"),
            "end_de": end_de.strftime("%Y%m%d"),
            "page_no": page_no,
            "page_count": page_count,
        }

        async with self.session.get(
            f"{self.BASE_URL}/list.xml",
            params=params
        ) as response:
            response.raise_for_status()
            content = await response.text()
            return self._parse_disclosure_list(content)

    def _parse_disclosure_list(self, xml_content: str) -> List[DartDisclosure]:
        """Parse XML response into disclosure objects"""
        root = ET.fromstring(xml_content)
        disclosures = []

        for item in root.findall(".//list"):
            disclosure = DartDisclosure(
                corp_code=item.findtext("corp_code", ""),
                corp_name=item.findtext("corp_name", ""),
                stock_code=item.findtext("stock_code", ""),
                report_nm=item.findtext("report_nm", ""),
                rcept_no=item.findtext("rcept_no", ""),
                flr_nm=item.findtext("flr_nm", ""),
                rcept_dt=datetime.strptime(
                    item.findtext("rcept_dt", "20000101"),
                    "%Y%m%d"
                ).date(),
                rm=item.findtext("rm"),
            )
            disclosures.append(disclosure)

        return disclosures

# Usage example
async def fetch_company_disclosures(stock_code: str):
    from datetime import timedelta

    api_key = os.getenv("DART_API_KEY")
    end_date = date.today()
    start_date = end_date - timedelta(days=30)

    async with DartAPIClient(api_key) as client:
        disclosures = await client.get_disclosures(
            corp_code=stock_code,
            bgn_de=start_date,
            end_de=end_date
        )

        for disclosure in disclosures:
            print(f"{disclosure.rcept_dt}: {disclosure.report_nm}")
```

### Database Schema

```sql
CREATE TABLE dart_disclosures (
    id BIGSERIAL PRIMARY KEY,
    stock_code VARCHAR(20) NOT NULL,
    corp_code VARCHAR(20) NOT NULL,
    corp_name_ko VARCHAR(200) NOT NULL,
    corp_name_en VARCHAR(200),

    -- Disclosure identification
    rcept_no VARCHAR(20) UNIQUE NOT NULL,
    report_code VARCHAR(10) NOT NULL,
    report_name_ko VARCHAR(200) NOT NULL,
    report_name_en VARCHAR(200),

    -- Disclosure metadata
    disclosure_type VARCHAR(50) NOT NULL,
    importance_level VARCHAR(20) DEFAULT 'medium',
    rcept_dt DATE NOT NULL,
    filer_name VARCHAR(200),
    remarks TEXT,

    -- Full content
    content_text TEXT,
    content_html TEXT,
    content_url VARCHAR(500),

    -- Korean-specific fields
    summary_ko TEXT,
    summary_en TEXT,

    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- Indexes
    CONSTRAINT fk_stock FOREIGN KEY (stock_code)
        REFERENCES stocks(stock_code) ON DELETE CASCADE
);

CREATE INDEX idx_dart_stock_date ON dart_disclosures(stock_code, rcept_dt DESC);
CREATE INDEX idx_dart_type_date ON dart_disclosures(disclosure_type, rcept_dt DESC);
CREATE INDEX idx_dart_importance ON dart_disclosures(importance_level, rcept_dt DESC);
CREATE INDEX idx_dart_rcept_no ON dart_disclosures(rcept_no);

-- Full-text search for Korean content
CREATE INDEX idx_dart_content_fts ON dart_disclosures
    USING gin(to_tsvector('korean', content_text));
```

### i18n Korean Terminology

```typescript
// frontend/src/locales/ko/dart.json
{
  "disclosure": {
    "types": {
      "annual_report": "사업보고서",
      "quarterly_report": "분기보고서",
      "major_event": "주요사항보고",
      "earnings": "영업실적",
      "capital_increase": "유상증자",
      "merger": "합병",
      "acquisition": "인수",
      "asset_transaction": "자산양수도"
    },
    "importance": {
      "critical": "매우 중요",
      "high": "높음",
      "medium": "보통",
      "low": "낮음"
    },
    "labels": {
      "recent_disclosures": "최근 공시",
      "view_details": "상세보기",
      "alert_settings": "공시 알림 설정",
      "received_date": "접수일",
      "company": "회사명",
      "report_type": "보고서 종류"
    },
    "financial_terms": {
      "billion_won": "억원",
      "trillion_won": "조원",
      "ten_thousand_shares": "만주",
      "percent": "퍼센트"
    }
  }
}
```

## Acceptance Criteria

- [ ] **DART API Integration Service**
  - Successfully authenticate with DART API
  - Handle all major disclosure types
  - Maintain 99% API success rate
  - Implement proper error handling and retry logic

- [ ] **Disclosure Data Storage**
  - Store all disclosure types with complete metadata
  - Support fast lookups by stock code and date
  - Enable full-text search in Korean
  - Maintain data integrity with foreign key constraints

- [ ] **Per-stock Disclosure History**
  - Display chronological disclosure list per stock
  - Show disclosure type, date, and importance level
  - Provide filtering by disclosure type and date range
  - Link to original DART documents

- [ ] **Real-time Disclosure Feed**
  - Update disclosures every 5 minutes during market hours
  - Display latest disclosures across all tracked stocks
  - Highlight critical/high importance disclosures
  - Sort by recency and importance

- [ ] **Disclosure Alert Settings**
  - Allow users to select stocks for monitoring
  - Configure alert criteria (disclosure types, importance)
  - Support email and push notifications
  - Deliver alerts within 5 minutes of disclosure publication

## Testing Strategy

### Unit Tests

```python
import pytest
from datetime import date
from dart_client import DartAPIClient, DartDisclosure

@pytest.mark.asyncio
async def test_dart_api_client_authentication():
    """Test DART API authentication"""
    async with DartAPIClient(api_key="test_key") as client:
        assert client.api_key == "test_key"
        assert client.session is not None

@pytest.mark.asyncio
async def test_get_disclosures_success():
    """Test successful disclosure fetching"""
    async with DartAPIClient(api_key="valid_key") as client:
        disclosures = await client.get_disclosures(
            corp_code="00126380",
            bgn_de=date(2025, 1, 1),
            end_de=date(2025, 1, 31)
        )

        assert len(disclosures) > 0
        assert all(isinstance(d, DartDisclosure) for d in disclosures)

def test_parse_disclosure_xml():
    """Test XML parsing of disclosure data"""
    xml_sample = """<?xml version="1.0" encoding="UTF-8"?>
    <result>
        <list>
            <corp_code>00126380</corp_code>
            <corp_name>삼성전자</corp_name>
            <stock_code>005930</stock_code>
            <report_nm>사업보고서</report_nm>
            <rcept_no>20250101000001</rcept_no>
            <rcept_dt>20250101</rcept_dt>
        </list>
    </result>
    """

    client = DartAPIClient("test_key")
    disclosures = client._parse_disclosure_list(xml_sample)

    assert len(disclosures) == 1
    assert disclosures[0].corp_name == "삼성전자"
    assert disclosures[0].stock_code == "005930"
```

### Integration Tests

```python
@pytest.mark.integration
async def test_disclosure_fetch_and_store():
    """Test end-to-end disclosure fetching and storage"""
    # Fetch from DART
    async with DartAPIClient(api_key=settings.DART_API_KEY) as client:
        disclosures = await client.get_disclosures(
            corp_code="00126380",
            bgn_de=date.today() - timedelta(days=7),
            end_de=date.today()
        )

    # Store in database
    async with AsyncSession() as session:
        for disclosure in disclosures:
            db_disclosure = DartDisclosureModel(**disclosure.__dict__)
            session.add(db_disclosure)
        await session.commit()

    # Verify storage
    async with AsyncSession() as session:
        result = await session.execute(
            select(DartDisclosureModel).where(
                DartDisclosureModel.stock_code == "005930"
            )
        )
        stored = result.scalars().all()
        assert len(stored) == len(disclosures)

@pytest.mark.integration
def test_korean_full_text_search():
    """Test full-text search for Korean content"""
    with Session() as session:
        results = session.execute(
            text("""
                SELECT * FROM dart_disclosures
                WHERE to_tsvector('korean', content_text) @@
                      to_tsquery('korean', '유상증자 | 합병')
                LIMIT 10
            """)
        ).fetchall()

        assert len(results) > 0
```

### E2E Tests

```typescript
describe('DART Disclosure Feature', () => {
  it('should display recent disclosures for a stock', async () => {
    await page.goto('/stock/005930');

    // Find disclosure section
    const disclosureSection = await page.locator('[data-testid="dart-disclosures"]');
    expect(await disclosureSection.isVisible()).toBe(true);

    // Check Korean labels
    expect(await page.textContent('h3')).toContain('최근 공시');

    // Verify disclosure items
    const items = await page.locator('[data-testid="disclosure-item"]').all();
    expect(items.length).toBeGreaterThan(0);

    // Check Korean date formatting
    const firstDate = await items[0].locator('.disclosure-date').textContent();
    expect(firstDate).toMatch(/\d{4}년 \d{1,2}월 \d{1,2}일/);
  });

  it('should set up disclosure alerts', async () => {
    await page.goto('/settings/alerts');

    // Enable DART alerts
    await page.click('[data-testid="enable-dart-alerts"]');

    // Select disclosure types
    await page.check('[data-testid="alert-type-earnings"]');
    await page.check('[data-testid="alert-type-merger"]');

    // Save settings
    await page.click('[data-testid="save-alert-settings"]');

    // Verify success message
    expect(await page.textContent('.success-message')).toContain('저장되었습니다');
  });
});
```

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| DART API rate limit exceeded | Medium | High | Implement request queuing, caching, and upgrade to paid tier if needed |
| API downtime or maintenance | Low | High | Implement fallback mechanism, cache historical data, monitor API status |
| Korean encoding issues (EUC-KR/UTF-8) | Medium | Medium | Implement robust encoding detection and conversion, test with various inputs |
| Large data volume (5 years × daily disclosures) | High | Medium | Implement data partitioning, archival strategy, and efficient indexing |
| Disclosure parsing failures (XML format changes) | Low | High | Monitor parsing errors, implement schema versioning, add comprehensive logging |
| User alert spam (too many notifications) | Medium | Low | Implement smart filtering, user-configurable throttling, digest mode |

## Performance Requirements

- **API Response Time**: < 2 seconds for disclosure list fetching
- **Database Query Time**: < 100ms for stock disclosure history (last 6 months)
- **Full-text Search**: < 500ms for Korean content search
- **Real-time Update Latency**: < 5 minutes from DART publication
- **Alert Delivery Time**: < 5 minutes from disclosure detection
- **Concurrent Users**: Support 1,000+ concurrent users viewing disclosures
- **Data Retention**: 5 years of disclosure history with fast access

## Security Considerations

- **API Key Protection**
  - Store DART API key in secure environment variables
  - Never expose API key in client-side code or logs
  - Rotate API key quarterly

- **Input Validation**
  - Validate all API responses against expected schema
  - Sanitize HTML content before rendering
  - Prevent XML/XXE injection attacks

- **Access Control**
  - Require authentication to set up disclosure alerts
  - Rate limit user requests to prevent abuse
  - Log all disclosure access for audit trails

- **Data Privacy**
  - Do not store sensitive user alert preferences without encryption
  - Comply with Korean Personal Information Protection Act (PIPA)
  - Allow users to delete their alert configurations

## Error Handling

```python
from typing import Optional
import logging
from tenacity import retry, stop_after_attempt, wait_exponential

logger = logging.getLogger(__name__)

class DartAPIError(Exception):
    """Base exception for DART API errors"""
    pass

class DartRateLimitError(DartAPIError):
    """Raised when API rate limit is exceeded"""
    pass

class DartAuthenticationError(DartAPIError):
    """Raised when API authentication fails"""
    pass

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=4, max=10)
)
async def fetch_disclosures_with_retry(
    client: DartAPIClient,
    corp_code: str,
    bgn_de: date,
    end_de: date
) -> Optional[List[DartDisclosure]]:
    """
    Fetch disclosures with automatic retry on failure

    Retries up to 3 times with exponential backoff
    """
    try:
        disclosures = await client.get_disclosures(
            corp_code=corp_code,
            bgn_de=bgn_de,
            end_de=end_de
        )
        return disclosures

    except aiohttp.ClientResponseError as e:
        if e.status == 429:
            logger.error(f"Rate limit exceeded for corp_code={corp_code}")
            raise DartRateLimitError("API rate limit exceeded") from e
        elif e.status == 401:
            logger.error("DART API authentication failed")
            raise DartAuthenticationError("Invalid API key") from e
        else:
            logger.error(f"DART API error: {e.status} - {e.message}")
            raise DartAPIError(f"API request failed: {e}") from e

    except ET.ParseError as e:
        logger.error(f"Failed to parse DART XML response: {e}")
        raise DartAPIError("Invalid XML response from DART") from e

    except Exception as e:
        logger.exception(f"Unexpected error fetching disclosures: {e}")
        raise

# Usage in background job
async def dart_disclosure_sync_job():
    """Background job to sync DART disclosures"""
    async with DartAPIClient(settings.DART_API_KEY) as client:
        for stock in active_korean_stocks:
            try:
                disclosures = await fetch_disclosures_with_retry(
                    client=client,
                    corp_code=stock.dart_corp_code,
                    bgn_de=last_sync_date,
                    end_de=date.today()
                )

                if disclosures:
                    await store_disclosures(disclosures)
                    logger.info(
                        f"Synced {len(disclosures)} disclosures for {stock.stock_code}"
                    )

            except DartRateLimitError:
                logger.warning("Rate limit hit, pausing sync job")
                await asyncio.sleep(3600)  # Wait 1 hour
                break

            except DartAPIError as e:
                logger.error(f"Skipping {stock.stock_code} due to error: {e}")
                continue
```

## Dependencies

- Backend: FastAPI, aiohttp, SQLAlchemy, alembic
- Frontend: React, react-intl, date-fns
- Infrastructure: PostgreSQL (with Korean full-text search), Redis (caching)
- External: DART Open API access

## References

- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 8: Korea Market Specialization
- [DART Open API Documentation](https://opendart.fss.or.kr/guide/main.do)
- [Korean Personal Information Protection Act (PIPA)](https://www.pipc.go.kr)
- [PostgreSQL Korean Full-text Search](https://www.postgresql.org/docs/current/textsearch-intro.html)

## Notes

- DART API free tier has 100 requests/day limit; consider upgrading for production
- Korean financial terms often use unit abbreviations (억원 = 100 million won, 만주 = 10,000 shares)
- Disclosure importance should consider both type and content (e.g., large capital increase vs. minor asset sale)
- Consider implementing AI summarization for long Korean disclosures (optional enhancement)
- Coordinate with KR-003 for insider trading disclosures overlap

## Progress

**0% - Not started**
