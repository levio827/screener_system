# KR-002: Theme Stock Categorization

## Metadata

| Field | Value |
|-------|-------|
| **ID** | KR-002 |
| **Title** | Implement Theme Stock (테마주) System |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P1 (High) |
| **Estimate** | 12 hours |
| **Sprint** | Sprint 7 |
| **Epic** | Korea Market Specialization |
| **Assignee** | TBD |
| **Created** | 2025-11-29 |
| **Tags** | i18n, korean-market, categorization, real-time-analysis |
| **Depends On** | KR-001 |

## Description

Implement a theme stock (테마주) categorization and analysis system tailored for the Korean stock market. Theme stocks refer to groups of stocks that move together based on shared themes such as policy changes, industry trends, or current events. This feature will help investors identify trending themes and related stocks, which is a popular investment strategy in Korea.

The system will automatically categorize stocks into themes, track theme strength based on collective performance, and provide real-time theme analysis dashboards.

## Subtasks

- [ ] **Theme Categorization Design**
  - [ ] Design theme taxonomy (policy, technology, events, global)
  - [ ] Create comprehensive theme definitions with Korean names
  - [ ] Define theme hierarchy (parent themes and sub-themes)
  - [ ] Establish theme lifecycle management (active, emerging, declining)
- [ ] **Stock-Theme Mapping System**
  - [ ] Design `theme_stocks` and `stock_themes` junction table
  - [ ] Implement many-to-many relationship (stocks can belong to multiple themes)
  - [ ] Add theme relevance scoring (0-100)
  - [ ] Create theme update history tracking
- [ ] **Theme Data Collection**
  - [ ] Integrate with news APIs for theme detection
  - [ ] Parse DART disclosures for theme relevance (from KR-001)
  - [ ] Implement manual theme tagging interface for admins
  - [ ] Create automated theme assignment using keywords
- [ ] **Theme Strength Calculation**
  - [ ] Calculate theme strength based on member stock performance
  - [ ] Implement weighted average by market cap
  - [ ] Track theme momentum (daily, weekly, monthly changes)
  - [ ] Identify theme leaders (top performing stocks in theme)
- [ ] **Theme Screening Filters**
  - [ ] Add theme filter to stock screener
  - [ ] Support multiple theme selection
  - [ ] Enable theme strength range filtering
  - [ ] Combine with existing fundamental/technical filters
- [ ] **Hot Themes Dashboard**
  - [ ] Create real-time trending themes widget
  - [ ] Display top 10 themes by strength
  - [ ] Show theme performance charts
  - [ ] List top stocks within each theme
- [ ] **Localization**
  - [ ] Add all theme names in Korean and English
  - [ ] Implement Korean financial terminology for themes
  - [ ] Format performance metrics with Korean conventions
  - [ ] Ensure proper Hangul rendering

## Theme Categories

### Policy/Regulation
- **Carbon Neutrality (탄소중립)**: Companies involved in renewable energy, carbon reduction, ESG
- **Green New Deal (그린뉴딜)**: Environmental infrastructure, green technology
- **Digital New Deal (디지털뉴딜)**: Digital transformation, data infrastructure, AI
- **Real Estate Policy (부동산정책)**: Construction, building materials affected by housing policies
- **Interest Rate Changes (금리정책)**: Financial institutions, REITs sensitive to rate changes

### Technology/Industry
- **AI/Semiconductors (인공지능/반도체)**: Chip makers, AI software, semiconductor equipment
- **Secondary Batteries (2차전지)**: Battery manufacturers, materials, EV components
- **Bio/Healthcare (바이오/헬스케어)**: Pharmaceuticals, medical devices, biotech
- **Robotics/Automation (로봇/자동화)**: Industrial robots, automation equipment
- **Aerospace (항공우주)**: Aerospace manufacturers, defense contractors
- **Metaverse (메타버스)**: VR/AR, digital content, gaming platforms
- **Hydrogen Economy (수소경제)**: Hydrogen production, fuel cells, infrastructure

### Issues/Events
- **Elections (선거)**: Industries affected by election outcomes
- **Olympics/Sports Events (올림픽/스포츠)**: Sports equipment, broadcasting, infrastructure
- **Inter-Korean Cooperation (남북협력)**: Companies with NK exposure or reunification themes
- **Endemic Transition (엔데믹)**: Tourism, airlines, offline retail recovery
- **Reopening (리오프닝)**: Travel, hospitality, entertainment recovery

### Global Themes
- **China-Related (중국테마)**: Companies with China exposure or supply chain
- **US-Related (미국테마)**: Export to US, US subsidiary companies
- **Commodity Themes (원자재)**: Oil, metals, agriculture-related stocks
- **K-Culture (K-컬처)**: Entertainment, content, beauty products

## Implementation Details

### Database Schema

```sql
-- Theme definitions table
CREATE TABLE themes (
    id SERIAL PRIMARY KEY,
    theme_code VARCHAR(50) UNIQUE NOT NULL,
    theme_name_ko VARCHAR(200) NOT NULL,
    theme_name_en VARCHAR(200) NOT NULL,
    category VARCHAR(50) NOT NULL,
    parent_theme_id INTEGER REFERENCES themes(id),
    description_ko TEXT,
    description_en TEXT,
    status VARCHAR(20) DEFAULT 'active',  -- active, emerging, declining, archived
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Stock-theme mapping table
CREATE TABLE stock_themes (
    id BIGSERIAL PRIMARY KEY,
    stock_code VARCHAR(20) NOT NULL,
    theme_id INTEGER NOT NULL,
    relevance_score INTEGER DEFAULT 50,  -- 0-100
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    assigned_by VARCHAR(50),  -- 'auto', 'admin', 'ml'
    notes TEXT,

    CONSTRAINT fk_stock FOREIGN KEY (stock_code)
        REFERENCES stocks(stock_code) ON DELETE CASCADE,
    CONSTRAINT fk_theme FOREIGN KEY (theme_id)
        REFERENCES themes(id) ON DELETE CASCADE,
    CONSTRAINT unique_stock_theme UNIQUE (stock_code, theme_id)
);

-- Theme performance tracking
CREATE TABLE theme_performance (
    id BIGSERIAL PRIMARY KEY,
    theme_id INTEGER NOT NULL,
    calculation_date DATE NOT NULL,
    member_count INTEGER DEFAULT 0,
    avg_price_change_pct DECIMAL(10, 2),
    total_market_cap BIGINT,
    theme_strength DECIMAL(10, 2),  -- Composite score 0-100
    top_performer_stock_code VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT fk_theme FOREIGN KEY (theme_id)
        REFERENCES themes(id) ON DELETE CASCADE,
    CONSTRAINT unique_theme_date UNIQUE (theme_id, calculation_date)
);

-- Indexes
CREATE INDEX idx_stock_themes_stock ON stock_themes(stock_code);
CREATE INDEX idx_stock_themes_theme ON stock_themes(theme_id);
CREATE INDEX idx_stock_themes_relevance ON stock_themes(relevance_score DESC);
CREATE INDEX idx_theme_perf_date ON theme_performance(calculation_date DESC);
CREATE INDEX idx_theme_perf_strength ON theme_performance(theme_strength DESC);
CREATE INDEX idx_themes_category ON themes(category);
CREATE INDEX idx_themes_status ON themes(status);
```

### Theme Strength Calculation

```python
from typing import List, Dict
from dataclasses import dataclass
from decimal import Decimal
from datetime import date, timedelta
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession

@dataclass
class ThemeStrength:
    """Theme strength metrics"""
    theme_id: int
    theme_name_ko: str
    member_count: int
    avg_price_change_pct: Decimal
    total_market_cap: int
    theme_strength: Decimal
    top_performers: List[str]
    momentum_1d: Decimal
    momentum_1w: Decimal
    momentum_1m: Decimal

class ThemeAnalyzer:
    """Calculate and analyze theme performance"""

    def __init__(self, session: AsyncSession):
        self.session = session

    async def calculate_theme_strength(
        self,
        theme_id: int,
        calculation_date: date
    ) -> ThemeStrength:
        """
        Calculate comprehensive theme strength metrics

        Theme strength is calculated using:
        1. Average price change of member stocks (weighted by market cap)
        2. Number of stocks in the theme showing positive movement
        3. Volume increase compared to average
        4. Recent news/disclosure activity
        """
        # Get theme member stocks
        query = select(StockTheme).where(
            StockTheme.theme_id == theme_id
        )
        result = await self.session.execute(query)
        stock_themes = result.scalars().all()

        if not stock_themes:
            raise ValueError(f"No stocks found for theme {theme_id}")

        stock_codes = [st.stock_code for st in stock_themes]

        # Get stock price data
        price_query = select(StockPrice).where(
            StockPrice.stock_code.in_(stock_codes),
            StockPrice.date == calculation_date
        )
        price_result = await self.session.execute(price_query)
        prices = {p.stock_code: p for p in price_result.scalars().all()}

        # Calculate weighted metrics
        total_market_cap = 0
        weighted_price_change = Decimal(0)
        positive_stocks = 0

        for stock_code in stock_codes:
            if stock_code not in prices:
                continue

            price = prices[stock_code]
            market_cap = price.close * price.shares_outstanding

            total_market_cap += market_cap
            weighted_price_change += price.change_pct * market_cap

            if price.change_pct > 0:
                positive_stocks += 1

        # Calculate average price change (market cap weighted)
        avg_price_change = (
            weighted_price_change / total_market_cap
            if total_market_cap > 0
            else Decimal(0)
        )

        # Calculate theme strength (composite score 0-100)
        strength_score = self._calculate_strength_score(
            avg_price_change=avg_price_change,
            positive_ratio=positive_stocks / len(stock_codes),
            member_count=len(stock_codes)
        )

        # Get top performers
        sorted_stocks = sorted(
            [(code, prices[code].change_pct) for code in stock_codes if code in prices],
            key=lambda x: x[1],
            reverse=True
        )
        top_performers = [code for code, _ in sorted_stocks[:5]]

        # Calculate momentum
        momentum_1d = avg_price_change
        momentum_1w = await self._calculate_momentum(theme_id, days=7)
        momentum_1m = await self._calculate_momentum(theme_id, days=30)

        return ThemeStrength(
            theme_id=theme_id,
            theme_name_ko=await self._get_theme_name(theme_id),
            member_count=len(stock_codes),
            avg_price_change_pct=avg_price_change,
            total_market_cap=total_market_cap,
            theme_strength=strength_score,
            top_performers=top_performers,
            momentum_1d=momentum_1d,
            momentum_1w=momentum_1w,
            momentum_1m=momentum_1m
        )

    def _calculate_strength_score(
        self,
        avg_price_change: Decimal,
        positive_ratio: float,
        member_count: int
    ) -> Decimal:
        """
        Calculate composite theme strength score (0-100)

        Components:
        - 50% weight: Average price change (normalized)
        - 30% weight: Positive stock ratio
        - 20% weight: Member count (log scale)
        """
        # Normalize price change to 0-50 range (assumes -10% to +10% typical range)
        price_score = max(0, min(50, (avg_price_change + 10) * 2.5))

        # Positive ratio score (0-30)
        positive_score = Decimal(positive_ratio * 30)

        # Member count score (0-20, log scale)
        import math
        member_score = Decimal(min(20, math.log(member_count + 1) * 5))

        return price_score + positive_score + member_score

    async def _calculate_momentum(self, theme_id: int, days: int) -> Decimal:
        """Calculate theme momentum over specified days"""
        end_date = date.today()
        start_date = end_date - timedelta(days=days)

        query = select(
            func.avg(ThemePerformance.avg_price_change_pct)
        ).where(
            ThemePerformance.theme_id == theme_id,
            ThemePerformance.calculation_date >= start_date,
            ThemePerformance.calculation_date <= end_date
        )

        result = await self.session.execute(query)
        return result.scalar() or Decimal(0)

# Background job to update theme strength
async def update_theme_strengths():
    """Daily job to calculate theme strengths"""
    async with AsyncSession() as session:
        # Get all active themes
        themes_query = select(Theme).where(Theme.status == 'active')
        result = await session.execute(themes_query)
        themes = result.scalars().all()

        analyzer = ThemeAnalyzer(session)
        today = date.today()

        for theme in themes:
            try:
                strength = await analyzer.calculate_theme_strength(
                    theme_id=theme.id,
                    calculation_date=today
                )

                # Save performance record
                perf_record = ThemePerformance(
                    theme_id=theme.id,
                    calculation_date=today,
                    member_count=strength.member_count,
                    avg_price_change_pct=strength.avg_price_change_pct,
                    total_market_cap=strength.total_market_cap,
                    theme_strength=strength.theme_strength,
                    top_performer_stock_code=strength.top_performers[0] if strength.top_performers else None
                )
                session.add(perf_record)

                logger.info(f"Updated theme {theme.theme_name_ko}: strength={strength.theme_strength}")

            except Exception as e:
                logger.error(f"Failed to update theme {theme.id}: {e}")
                continue

        await session.commit()
```

### Frontend Component Example

```typescript
// frontend/src/components/ThemeDashboard.tsx
import React, { useEffect, useState } from 'react';
import { useIntl, FormattedMessage, FormattedNumber } from 'react-intl';
import { Card, Table, Badge, Progress } from 'antd';

interface ThemeData {
  themeId: number;
  themeNameKo: string;
  themeNameEn: string;
  memberCount: number;
  avgPriceChangePct: number;
  themeStrength: number;
  topPerformers: string[];
  momentum1d: number;
  momentum1w: number;
  momentum1m: number;
}

export const ThemeDashboard: React.FC = () => {
  const intl = useIntl();
  const [hotThemes, setHotThemes] = useState<ThemeData[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchHotThemes();
  }, []);

  const fetchHotThemes = async () => {
    try {
      const response = await fetch('/api/themes/hot?limit=10');
      const data = await response.json();
      setHotThemes(data);
    } catch (error) {
      console.error('Failed to fetch hot themes:', error);
    } finally {
      setLoading(false);
    }
  };

  const columns = [
    {
      title: <FormattedMessage id="theme.rank" defaultMessage="순위" />,
      dataIndex: 'rank',
      render: (_: any, __: any, index: number) => index + 1,
    },
    {
      title: <FormattedMessage id="theme.name" defaultMessage="테마명" />,
      dataIndex: intl.locale === 'ko' ? 'themeNameKo' : 'themeNameEn',
      render: (text: string, record: ThemeData) => (
        <a href={`/themes/${record.themeId}`}>{text}</a>
      ),
    },
    {
      title: <FormattedMessage id="theme.member_count" defaultMessage="종목 수" />,
      dataIndex: 'memberCount',
      render: (count: number) => `${count}개`,
    },
    {
      title: <FormattedMessage id="theme.avg_change" defaultMessage="평균 등락률" />,
      dataIndex: 'avgPriceChangePct',
      render: (pct: number) => (
        <span style={{ color: pct >= 0 ? '#cf1322' : '#3f8600' }}>
          <FormattedNumber
            value={pct}
            style="percent"
            minimumFractionDigits={2}
            maximumFractionDigits={2}
          />
        </span>
      ),
    },
    {
      title: <FormattedMessage id="theme.strength" defaultMessage="테마 강도" />,
      dataIndex: 'themeStrength',
      render: (strength: number) => (
        <div style={{ width: 120 }}>
          <Progress
            percent={strength}
            size="small"
            strokeColor={strength > 70 ? '#cf1322' : strength > 40 ? '#faad14' : '#52c41a'}
          />
        </div>
      ),
    },
    {
      title: <FormattedMessage id="theme.momentum" defaultMessage="모멘텀" />,
      render: (_: any, record: ThemeData) => (
        <div>
          <div>1일: {record.momentum1d.toFixed(2)}%</div>
          <div>1주: {record.momentum1w.toFixed(2)}%</div>
        </div>
      ),
    },
  ];

  return (
    <Card
      title={<FormattedMessage id="theme.hot_themes" defaultMessage="오늘의 핫 테마" />}
      loading={loading}
    >
      <Table
        columns={columns}
        dataSource={hotThemes}
        rowKey="themeId"
        pagination={false}
      />
    </Card>
  );
};
```

## Acceptance Criteria

- [ ] **Theme Categorization System**
  - Define at least 30 distinct themes across 4 major categories
  - Support hierarchical themes (parent-child relationships)
  - Allow themes to have multiple language names (Korean/English)
  - Track theme lifecycle (emerging, active, declining)

- [ ] **Stock-Theme Mapping**
  - Support many-to-many relationship (stocks can belong to multiple themes)
  - Store relevance scores for each stock-theme pairing
  - Track assignment source (automatic, manual, ML-based)
  - Enable bulk theme assignments

- [ ] **Theme Screening Filters**
  - Add theme selector to stock screener UI
  - Support multiple theme selection with AND/OR logic
  - Filter by theme strength ranges
  - Combine with existing filters (technical, fundamental)

- [ ] **Theme Strength Indicator**
  - Calculate daily theme strength (0-100 composite score)
  - Track theme momentum (1d, 1w, 1m)
  - Identify top performers within each theme
  - Display historical theme performance charts

- [ ] **Hot Themes Dashboard**
  - Show real-time top 10 trending themes
  - Display theme strength, member count, average price change
  - List top 5 performing stocks per theme
  - Update every 5 minutes during market hours

- [ ] **Theme Alerts**
  - Alert when theme strength exceeds threshold
  - Notify when new stocks join user-watched themes
  - Send daily theme performance digest
  - Support email and push notifications

## Testing Strategy

### Unit Tests

```python
import pytest
from decimal import Decimal
from theme_analyzer import ThemeAnalyzer, ThemeStrength

@pytest.mark.asyncio
async def test_theme_strength_calculation():
    """Test theme strength calculation logic"""
    analyzer = ThemeAnalyzer(mock_session)

    strength = await analyzer.calculate_theme_strength(
        theme_id=1,
        calculation_date=date(2025, 1, 15)
    )

    assert isinstance(strength, ThemeStrength)
    assert 0 <= strength.theme_strength <= 100
    assert strength.member_count > 0
    assert len(strength.top_performers) <= 5

def test_strength_score_calculation():
    """Test composite strength score algorithm"""
    analyzer = ThemeAnalyzer(mock_session)

    # Test with strong theme (high price change, high positive ratio)
    score = analyzer._calculate_strength_score(
        avg_price_change=Decimal('5.0'),
        positive_ratio=0.8,
        member_count=20
    )
    assert score > 70

    # Test with weak theme
    score = analyzer._calculate_strength_score(
        avg_price_change=Decimal('-2.0'),
        positive_ratio=0.3,
        member_count=5
    )
    assert score < 40

@pytest.mark.asyncio
async def test_momentum_calculation():
    """Test theme momentum over different periods"""
    analyzer = ThemeAnalyzer(mock_session)

    momentum_1w = await analyzer._calculate_momentum(theme_id=1, days=7)
    momentum_1m = await analyzer._calculate_momentum(theme_id=1, days=30)

    assert isinstance(momentum_1w, Decimal)
    assert isinstance(momentum_1m, Decimal)
```

### Integration Tests

```python
@pytest.mark.integration
async def test_theme_assignment():
    """Test assigning stocks to themes"""
    async with AsyncSession() as session:
        # Create test theme
        theme = Theme(
            theme_code='TEST_AI',
            theme_name_ko='인공지능',
            theme_name_en='Artificial Intelligence',
            category='technology'
        )
        session.add(theme)
        await session.commit()

        # Assign stocks to theme
        stock_codes = ['005930', '000660', '035420']
        for stock_code in stock_codes:
            stock_theme = StockTheme(
                stock_code=stock_code,
                theme_id=theme.id,
                relevance_score=80,
                assigned_by='admin'
            )
            session.add(stock_theme)
        await session.commit()

        # Verify assignments
        query = select(StockTheme).where(StockTheme.theme_id == theme.id)
        result = await session.execute(query)
        assignments = result.scalars().all()

        assert len(assignments) == 3
        assert all(st.relevance_score == 80 for st in assignments)

@pytest.mark.integration
async def test_hot_themes_api():
    """Test hot themes API endpoint"""
    response = await client.get('/api/themes/hot?limit=10')

    assert response.status_code == 200
    themes = response.json()

    assert len(themes) <= 10
    assert all('themeId' in t for t in themes)
    assert all('themeStrength' in t for t in themes)

    # Verify ordering by strength
    strengths = [t['themeStrength'] for t in themes]
    assert strengths == sorted(strengths, reverse=True)
```

### E2E Tests

```typescript
describe('Theme Stock Features', () => {
  it('should display hot themes dashboard', async () => {
    await page.goto('/themes');

    // Check title in Korean
    expect(await page.textContent('h1')).toContain('오늘의 핫 테마');

    // Verify theme list
    const themeRows = await page.locator('table tbody tr').all();
    expect(themeRows.length).toBeGreaterThan(0);
    expect(themeRows.length).toBeLessThanOrEqual(10);

    // Check theme strength visualization
    const firstTheme = themeRows[0];
    const strengthBar = await firstTheme.locator('.ant-progress').isVisible();
    expect(strengthBar).toBe(true);
  });

  it('should filter stocks by theme', async () => {
    await page.goto('/screener');

    // Open theme filter
    await page.click('[data-testid="filter-theme"]');

    // Select AI theme
    await page.click('[data-testid="theme-ai"]');
    await page.click('[data-testid="apply-filter"]');

    // Verify results
    const results = await page.locator('[data-testid="stock-result"]').all();
    expect(results.length).toBeGreaterThan(0);

    // Check that results show theme tag
    const firstResult = results[0];
    expect(await firstResult.locator('.theme-badge').textContent()).toContain('인공지능');
  });

  it('should show theme performance chart', async () => {
    await page.goto('/themes/1');

    // Verify Korean labels
    expect(await page.textContent('h2')).toMatch(/테마 성과/);

    // Check chart rendering
    const chart = await page.locator('canvas').isVisible();
    expect(chart).toBe(true);

    // Verify member stocks list
    const memberStocks = await page.locator('[data-testid="member-stock"]').all();
    expect(memberStocks.length).toBeGreaterThan(0);
  });
});
```

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Theme definition subjectivity | High | Medium | Use multiple data sources (news, disclosures, expert input), allow user feedback |
| Outdated theme assignments | Medium | Medium | Implement automated re-evaluation, track news/disclosure changes, periodic manual review |
| Theme fragmentation (too many themes) | Medium | Low | Limit total themes to ~50, merge similar themes, require minimum member count |
| Performance degradation with many-to-many relationships | Low | Medium | Optimize queries with proper indexes, cache hot themes, use materialized views |
| Korean terminology inconsistency | Low | Medium | Maintain centralized terminology database, use standard financial Korean terms |
| Theme manipulation/gaming | Low | High | Implement admin approval for theme changes, log all modifications, detect anomalies |

## Performance Requirements

- **Theme Strength Calculation**: < 5 seconds for all active themes (daily batch job)
- **Hot Themes Query**: < 200ms for top 10 themes
- **Theme Filter Query**: < 500ms for stocks in selected themes
- **Theme Dashboard Load**: < 1 second for initial render
- **Real-time Updates**: Refresh hot themes every 5 minutes during market hours
- **Concurrent Users**: Support 1,000+ users viewing theme dashboards simultaneously

## Security Considerations

- **Admin Controls**
  - Restrict theme creation/modification to admin users
  - Log all theme assignment changes with user attribution
  - Implement approval workflow for bulk theme updates

- **Input Validation**
  - Validate theme names (Korean/English) against injection attacks
  - Sanitize user-generated theme descriptions
  - Limit theme description length to prevent abuse

- **Rate Limiting**
  - Limit theme API requests to 100/minute per user
  - Throttle theme strength recalculation requests
  - Prevent automated theme scraping

- **Data Integrity**
  - Ensure stock_code references valid stocks
  - Validate relevance_score range (0-100)
  - Prevent duplicate theme assignments

## Error Handling

```python
import logging
from typing import Optional

logger = logging.getLogger(__name__)

class ThemeError(Exception):
    """Base exception for theme-related errors"""
    pass

class ThemeNotFoundError(ThemeError):
    """Raised when theme does not exist"""
    pass

class InvalidThemeDataError(ThemeError):
    """Raised when theme data is invalid"""
    pass

async def get_theme_strength_safe(
    theme_id: int,
    calculation_date: date
) -> Optional[ThemeStrength]:
    """
    Safely get theme strength with error handling
    """
    try:
        async with AsyncSession() as session:
            analyzer = ThemeAnalyzer(session)
            strength = await analyzer.calculate_theme_strength(
                theme_id=theme_id,
                calculation_date=calculation_date
            )
            return strength

    except ValueError as e:
        logger.warning(f"Theme {theme_id} has no member stocks: {e}")
        return None

    except Exception as e:
        logger.error(f"Failed to calculate theme strength for {theme_id}: {e}")
        raise ThemeError(f"Theme strength calculation failed: {e}") from e

async def assign_stock_to_theme_safe(
    stock_code: str,
    theme_id: int,
    relevance_score: int,
    assigned_by: str
) -> bool:
    """
    Safely assign stock to theme with validation
    """
    # Validate inputs
    if not (0 <= relevance_score <= 100):
        raise InvalidThemeDataError(
            f"Relevance score must be 0-100, got {relevance_score}"
        )

    try:
        async with AsyncSession() as session:
            # Check if theme exists
            theme = await session.get(Theme, theme_id)
            if not theme:
                raise ThemeNotFoundError(f"Theme {theme_id} not found")

            # Check if stock exists
            stock = await session.get(Stock, stock_code)
            if not stock:
                raise InvalidThemeDataError(f"Stock {stock_code} not found")

            # Create or update assignment
            existing = await session.execute(
                select(StockTheme).where(
                    StockTheme.stock_code == stock_code,
                    StockTheme.theme_id == theme_id
                )
            )
            stock_theme = existing.scalar_one_or_none()

            if stock_theme:
                stock_theme.relevance_score = relevance_score
                stock_theme.assigned_by = assigned_by
                logger.info(f"Updated {stock_code} in theme {theme_id}")
            else:
                stock_theme = StockTheme(
                    stock_code=stock_code,
                    theme_id=theme_id,
                    relevance_score=relevance_score,
                    assigned_by=assigned_by
                )
                session.add(stock_theme)
                logger.info(f"Assigned {stock_code} to theme {theme_id}")

            await session.commit()
            return True

    except (ThemeNotFoundError, InvalidThemeDataError):
        raise

    except Exception as e:
        logger.exception(f"Failed to assign stock to theme: {e}")
        return False
```

## Dependencies

- Backend: FastAPI, SQLAlchemy, alembic, pandas (for analytics)
- Frontend: React, react-intl, Ant Design, recharts (for theme charts)
- Infrastructure: PostgreSQL, Redis (cache hot themes)
- External: News API (optional, for automated theme detection)
- Internal: KR-001 (DART integration for disclosure-based theme detection)

## References

- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 8: Korea Market Specialization
- [Korean Theme Stock Analysis Methods](https://www.investopedia.com)
- [KR-001: DART Integration](KR-001.md) - For disclosure-based theme detection

## Notes

- Theme stock investing is very popular in Korea - this feature can be a key differentiator
- Consider implementing AI/ML for automated theme detection from news and disclosures
- Theme strength should be recalculated daily after market close
- Some themes are short-lived (event-based), others are long-term (industry trends)
- Consider adding social sentiment analysis from Korean financial communities (optional)
- Coordinate with KR-001 for DART disclosure-based theme triggers

## Progress

**0% - Not started**
