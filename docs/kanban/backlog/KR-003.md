# KR-003: Insider Trading Monitor

## Metadata

| Field | Value |
|-------|-------|
| **ID** | KR-003 |
| **Title** | Track Insider and Major Shareholder Trades |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P2 (Medium) |
| **Estimate** | 12 hours |
| **Sprint** | Sprint 7 |
| **Epic** | Korea Market Specialization |
| **Assignee** | TBD |
| **Created** | 2025-11-29 |
| **Tags** | i18n, korean-market, insider-trading, regulatory |
| **Depends On** | KR-001 |

## Description

Implement a comprehensive insider and major shareholder trading monitoring system for Korean stocks. This feature tracks executive trades, major shareholder ownership changes, treasury stock transactions, and stock option exercises by parsing DART disclosures. Insider trading patterns are valuable signals for investors, as they often indicate company insiders' confidence in their company's future prospects.

The system will alert users to significant insider activities, display trading histories, and provide screening filters based on insider trading patterns.

## Subtasks

- [ ] **DART Disclosure Integration**
  - [ ] Parse executive trading disclosures from DART (임원 주요주주 특정증권등 소유상황보고서)
  - [ ] Parse major shareholder change reports (주요주주변동신고서)
  - [ ] Parse treasury stock disclosures (자기주식 취득/처분 신탁계약체결 신고서)
  - [ ] Parse stock option exercise reports (주식매수선택권 행사 결정)
  - [ ] Handle Korean encoding and terminology
- [ ] **Database Schema Design**
  - [ ] Create `insider_trades` table for all insider transactions
  - [ ] Create `major_shareholders` table for ownership tracking
  - [ ] Design indexes for fast lookup by stock, date, insider type
  - [ ] Implement data retention policy (5 years minimum)
- [ ] **Trading Activity Analysis**
  - [ ] Calculate aggregate insider buying/selling by period
  - [ ] Identify significant transactions (>1% ownership change)
  - [ ] Track insider sentiment (buy/sell ratio)
  - [ ] Detect unusual patterns (cluster of trades, large volumes)
- [ ] **Screening Filters**
  - [ ] Filter by insider buy/sell activity
  - [ ] Filter by major shareholder concentration
  - [ ] Filter by treasury stock buyback activity
  - [ ] Combine with price/fundamental filters
- [ ] **Alert System**
  - [ ] Alert on large insider purchases (>100M KRW)
  - [ ] Alert on major shareholder ownership changes (>5%)
  - [ ] Alert on treasury stock buyback announcements
  - [ ] Support email and push notifications
- [ ] **Localization**
  - [ ] Korean terminology for insider types (임원, 주요주주, 특수관계인)
  - [ ] Korean formatting for ownership percentages
  - [ ] Korean financial terms (취득, 처분, 신탁)
  - [ ] Proper Hangul rendering in UI

## Data Points

### Executive Trades (임원 매매)
- **Reporter**: Officer name and position (이사, 감사, 집행임원)
- **Transaction Type**: Buy (취득), Sell (처분)
- **Date**: Transaction date
- **Quantity**: Number of shares traded
- **Price**: Average transaction price
- **Value**: Total transaction value (KRW)
- **Ownership After**: Post-transaction ownership percentage

### Major Shareholder Changes (주요주주 변동)
- **Shareholder Name**: Individual or entity name
- **Relationship**: Relationship to company (최대주주, 특수관계인, 기타주요주주)
- **Change Type**: Increase or decrease
- **Shares Before/After**: Share count before and after
- **Ownership Before/After**: Ownership percentage before and after
- **Change Reason**: Reason for change (매매, 증여, 상속, etc.)

### Treasury Stock Transactions (자기주식)
- **Transaction Type**: Acquisition (취득), Disposal (처분), Trust (신탁)
- **Purpose**: Purpose of transaction (주가안정, 임직원상여, 소각)
- **Quantity**: Number of shares
- **Transaction Period**: Start and end dates
- **Total Amount**: Total transaction amount (KRW)

### Stock Option Exercise (주식매수선택권)
- **Grant Date**: When options were granted
- **Exercise Date**: When options were exercised
- **Exercise Price**: Strike price per share
- **Quantity**: Number of shares
- **Grantee**: Position/title of option recipient

## Implementation Details

### Database Schema

```sql
-- Insider trades table
CREATE TABLE insider_trades (
    id BIGSERIAL PRIMARY KEY,
    stock_code VARCHAR(20) NOT NULL,

    -- Insider information
    insider_name VARCHAR(200) NOT NULL,
    insider_type VARCHAR(50) NOT NULL,  -- executive, major_shareholder, related_party
    position VARCHAR(200),  -- For executives: 대표이사, 사내이사, etc.
    relationship VARCHAR(100),  -- For shareholders: 최대주주, 특수관계인, etc.

    -- Transaction details
    transaction_date DATE NOT NULL,
    transaction_type VARCHAR(20) NOT NULL,  -- buy, sell
    shares_traded BIGINT NOT NULL,
    avg_price DECIMAL(15, 2),
    transaction_value BIGINT,  -- KRW

    -- Ownership information
    shares_before BIGINT,
    shares_after BIGINT,
    ownership_before_pct DECIMAL(10, 4),
    ownership_after_pct DECIMAL(10, 4),

    -- Additional metadata
    change_reason VARCHAR(100),  -- 매매, 증여, 상속, etc.
    disclosure_url VARCHAR(500),
    notes TEXT,

    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT fk_stock FOREIGN KEY (stock_code)
        REFERENCES stocks(stock_code) ON DELETE CASCADE
);

-- Treasury stock transactions
CREATE TABLE treasury_stock_transactions (
    id BIGSERIAL PRIMARY KEY,
    stock_code VARCHAR(20) NOT NULL,

    -- Transaction details
    transaction_type VARCHAR(20) NOT NULL,  -- acquisition, disposal, trust
    purpose VARCHAR(100),  -- 주가안정, 임직원상여, 소각

    -- Amounts
    shares_quantity BIGINT NOT NULL,
    transaction_amount BIGINT,  -- Total KRW
    avg_price DECIMAL(15, 2),

    -- Dates
    start_date DATE NOT NULL,
    end_date DATE,
    disclosure_date DATE NOT NULL,

    -- Status
    status VARCHAR(20) DEFAULT 'planned',  -- planned, in_progress, completed, cancelled

    disclosure_url VARCHAR(500),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT fk_stock FOREIGN KEY (stock_code)
        REFERENCES stocks(stock_code) ON DELETE CASCADE
);

-- Major shareholders snapshot
CREATE TABLE major_shareholders (
    id BIGSERIAL PRIMARY KEY,
    stock_code VARCHAR(20) NOT NULL,

    shareholder_name VARCHAR(200) NOT NULL,
    relationship VARCHAR(100),  -- 최대주주, 특수관계인, etc.

    shares_held BIGINT NOT NULL,
    ownership_pct DECIMAL(10, 4) NOT NULL,

    -- Snapshot date
    snapshot_date DATE NOT NULL,

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT fk_stock FOREIGN KEY (stock_code)
        REFERENCES stocks(stock_code) ON DELETE CASCADE,
    CONSTRAINT unique_shareholder_date UNIQUE (stock_code, shareholder_name, snapshot_date)
);

-- Indexes
CREATE INDEX idx_insider_trades_stock_date ON insider_trades(stock_code, transaction_date DESC);
CREATE INDEX idx_insider_trades_type ON insider_trades(transaction_type, transaction_date DESC);
CREATE INDEX idx_insider_trades_value ON insider_trades(transaction_value DESC);
CREATE INDEX idx_insider_trades_insider ON insider_trades(insider_name);

CREATE INDEX idx_treasury_stock_code_date ON treasury_stock_transactions(stock_code, disclosure_date DESC);
CREATE INDEX idx_treasury_type ON treasury_stock_transactions(transaction_type, disclosure_date DESC);

CREATE INDEX idx_shareholders_stock ON major_shareholders(stock_code, snapshot_date DESC);
CREATE INDEX idx_shareholders_ownership ON major_shareholders(ownership_pct DESC);
```

### Insider Trading Analysis Service

```python
from typing import List, Dict, Optional
from dataclasses import dataclass
from datetime import date, timedelta
from decimal import Decimal
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession

@dataclass
class InsiderActivity:
    """Insider trading activity summary"""
    stock_code: str
    period_start: date
    period_end: date
    buy_count: int
    sell_count: int
    buy_volume: int
    sell_volume: int
    buy_value: int  # KRW
    sell_value: int  # KRW
    net_value: int  # buy_value - sell_value
    insider_sentiment: str  # bullish, bearish, neutral
    significant_trades: List[Dict]

class InsiderAnalyzer:
    """Analyze insider trading patterns"""

    SIGNIFICANT_VALUE_THRESHOLD = 100_000_000  # 100M KRW
    SIGNIFICANT_OWNERSHIP_CHANGE = 1.0  # 1% ownership change

    def __init__(self, session: AsyncSession):
        self.session = session

    async def get_insider_activity(
        self,
        stock_code: str,
        start_date: date,
        end_date: date
    ) -> InsiderActivity:
        """
        Get insider trading activity summary for a stock
        """
        query = select(InsiderTrade).where(
            InsiderTrade.stock_code == stock_code,
            InsiderTrade.transaction_date >= start_date,
            InsiderTrade.transaction_date <= end_date
        )

        result = await self.session.execute(query)
        trades = result.scalars().all()

        # Calculate buy/sell metrics
        buy_trades = [t for t in trades if t.transaction_type == 'buy']
        sell_trades = [t for t in trades if t.transaction_type == 'sell']

        buy_volume = sum(t.shares_traded for t in buy_trades)
        sell_volume = sum(t.shares_traded for t in sell_trades)

        buy_value = sum(t.transaction_value or 0 for t in buy_trades)
        sell_value = sum(t.transaction_value or 0 for t in sell_trades)

        net_value = buy_value - sell_value

        # Determine sentiment
        sentiment = self._calculate_sentiment(
            buy_value=buy_value,
            sell_value=sell_value,
            buy_count=len(buy_trades),
            sell_count=len(sell_trades)
        )

        # Identify significant trades
        significant = [
            {
                'insider_name': t.insider_name,
                'position': t.position,
                'transaction_type': t.transaction_type,
                'date': t.transaction_date,
                'value': t.transaction_value,
                'ownership_change': abs(
                    (t.ownership_after_pct or 0) - (t.ownership_before_pct or 0)
                )
            }
            for t in trades
            if (t.transaction_value or 0) >= self.SIGNIFICANT_VALUE_THRESHOLD
            or abs((t.ownership_after_pct or 0) - (t.ownership_before_pct or 0)) >= self.SIGNIFICANT_OWNERSHIP_CHANGE
        ]

        return InsiderActivity(
            stock_code=stock_code,
            period_start=start_date,
            period_end=end_date,
            buy_count=len(buy_trades),
            sell_count=len(sell_trades),
            buy_volume=buy_volume,
            sell_volume=sell_volume,
            buy_value=buy_value,
            sell_value=sell_value,
            net_value=net_value,
            insider_sentiment=sentiment,
            significant_trades=significant
        )

    def _calculate_sentiment(
        self,
        buy_value: int,
        sell_value: int,
        buy_count: int,
        sell_count: int
    ) -> str:
        """
        Calculate insider sentiment based on trading activity

        Bullish: Net buying > 50M KRW or buy count > 2x sell count
        Bearish: Net selling > 50M KRW or sell count > 2x buy count
        Neutral: Otherwise
        """
        net_value = buy_value - sell_value

        if net_value > 50_000_000 or (buy_count > 0 and buy_count > 2 * sell_count):
            return 'bullish'
        elif net_value < -50_000_000 or (sell_count > 0 and sell_count > 2 * buy_count):
            return 'bearish'
        else:
            return 'neutral'

    async def get_major_shareholder_changes(
        self,
        stock_code: str,
        lookback_days: int = 90
    ) -> List[Dict]:
        """
        Get recent major shareholder ownership changes
        """
        end_date = date.today()
        start_date = end_date - timedelta(days=lookback_days)

        # Get all shareholder snapshots in period
        query = select(MajorShareholder).where(
            MajorShareholder.stock_code == stock_code,
            MajorShareholder.snapshot_date >= start_date
        ).order_by(
            MajorShareholder.shareholder_name,
            MajorShareholder.snapshot_date
        )

        result = await self.session.execute(query)
        snapshots = result.scalars().all()

        # Track changes per shareholder
        changes = []
        shareholders = {}

        for snapshot in snapshots:
            name = snapshot.shareholder_name

            if name in shareholders:
                prev = shareholders[name]
                ownership_change = snapshot.ownership_pct - prev.ownership_pct

                if abs(ownership_change) >= 0.5:  # 0.5% threshold
                    changes.append({
                        'shareholder_name': name,
                        'relationship': snapshot.relationship,
                        'date': snapshot.snapshot_date,
                        'ownership_before': prev.ownership_pct,
                        'ownership_after': snapshot.ownership_pct,
                        'ownership_change': ownership_change,
                        'shares_change': snapshot.shares_held - prev.shares_held
                    })

            shareholders[name] = snapshot

        return sorted(changes, key=lambda x: abs(x['ownership_change']), reverse=True)

# Background job to parse DART insider disclosures
async def parse_dart_insider_disclosures():
    """
    Parse new insider trading disclosures from DART

    Disclosure types to monitor:
    - 임원ㆍ주요주주특정증권등소유상황보고서 (Officer/Major Shareholder Ownership Report)
    - 주요주주변동신고서 (Major Shareholder Change Report)
    - 자기주식취득결정 (Treasury Stock Acquisition Decision)
    - 주식매수선택권행사결정 (Stock Option Exercise Decision)
    """
    async with AsyncSession() as session:
        # Get recent DART disclosures related to insider trading
        disclosure_types = [
            '임원ㆍ주요주주특정증권등소유상황보고서',
            '주요주주변동신고서',
            '자기주식취득결정',
            '자기주식처분결정',
            '주식매수선택권행사결정'
        ]

        today = date.today()
        week_ago = today - timedelta(days=7)

        query = select(DartDisclosure).where(
            DartDisclosure.report_name_ko.in_(disclosure_types),
            DartDisclosure.rcept_dt >= week_ago
        )

        result = await session.execute(query)
        disclosures = result.scalars().all()

        for disclosure in disclosures:
            try:
                await parse_and_store_insider_trade(disclosure, session)
                logger.info(f"Parsed insider disclosure {disclosure.rcept_no}")
            except Exception as e:
                logger.error(f"Failed to parse disclosure {disclosure.rcept_no}: {e}")
                continue

        await session.commit()
```

### Frontend Component

```typescript
// frontend/src/components/InsiderTradingPanel.tsx
import React, { useEffect, useState } from 'react';
import { FormattedMessage, FormattedNumber, FormattedDate } from 'react-intl';
import { Table, Tag, Tooltip, Card } from 'antd';
import { ArrowUpOutlined, ArrowDownOutlined } from '@ant-design/icons';

interface InsiderTrade {
  insiderName: string;
  position: string;
  transactionType: 'buy' | 'sell';
  transactionDate: string;
  sharesTraded: number;
  transactionValue: number;
  ownershipChange: number;
}

export const InsiderTradingPanel: React.FC<{ stockCode: string }> = ({ stockCode }) => {
  const [trades, setTrades] = useState<InsiderTrade[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchInsiderTrades();
  }, [stockCode]);

  const fetchInsiderTrades = async () => {
    try {
      const response = await fetch(`/api/stocks/${stockCode}/insider-trades?days=90`);
      const data = await response.json();
      setTrades(data);
    } catch (error) {
      console.error('Failed to fetch insider trades:', error);
    } finally {
      setLoading(false);
    }
  };

  const columns = [
    {
      title: <FormattedMessage id="insider.name" defaultMessage="내부자" />,
      dataIndex: 'insiderName',
      render: (name: string, record: InsiderTrade) => (
        <div>
          <div>{name}</div>
          <div style={{ fontSize: 12, color: '#888' }}>{record.position}</div>
        </div>
      ),
    },
    {
      title: <FormattedMessage id="insider.transaction" defaultMessage="거래" />,
      dataIndex: 'transactionType',
      render: (type: string) => (
        <Tag color={type === 'buy' ? 'red' : 'blue'}>
          {type === 'buy' ? (
            <>
              <ArrowUpOutlined /> <FormattedMessage id="insider.buy" defaultMessage="취득" />
            </>
          ) : (
            <>
              <ArrowDownOutlined /> <FormattedMessage id="insider.sell" defaultMessage="처분" />
            </>
          )}
        </Tag>
      ),
    },
    {
      title: <FormattedMessage id="insider.date" defaultMessage="거래일" />,
      dataIndex: 'transactionDate',
      render: (date: string) => <FormattedDate value={date} />,
    },
    {
      title: <FormattedMessage id="insider.shares" defaultMessage="주식수" />,
      dataIndex: 'sharesTraded',
      render: (shares: number) => (
        <FormattedNumber value={shares} /> + '주'
      ),
    },
    {
      title: <FormattedMessage id="insider.value" defaultMessage="거래금액" />,
      dataIndex: 'transactionValue',
      render: (value: number) => (
        <Tooltip title={<FormattedNumber value={value} style="currency" currency="KRW" />}>
          {Math.floor(value / 100000000)}억원
        </Tooltip>
      ),
    },
    {
      title: <FormattedMessage id="insider.ownership_change" defaultMessage="지분변동" />,
      dataIndex: 'ownershipChange',
      render: (change: number) => (
        <span style={{ color: change > 0 ? '#cf1322' : '#3f8600' }}>
          {change > 0 ? '+' : ''}
          <FormattedNumber value={change} minimumFractionDigits={2} />%
        </span>
      ),
    },
  ];

  return (
    <Card
      title={<FormattedMessage id="insider.recent_trades" defaultMessage="최근 내부자 거래" />}
      loading={loading}
    >
      <Table
        columns={columns}
        dataSource={trades}
        pagination={{ pageSize: 10 }}
        rowKey={(record) => `${record.insiderName}-${record.transactionDate}`}
      />
    </Card>
  );
};
```

## Acceptance Criteria

- [ ] **DART Executive Trading Disclosure Parsing**
  - Successfully parse all officer trading reports from DART
  - Extract insider name, position, transaction details, ownership changes
  - Handle Korean terminology and encoding correctly
  - Store parsed data in structured format

- [ ] **Major Shareholder Change Tracking**
  - Track ownership changes for all major shareholders (>5%)
  - Calculate ownership percentage changes accurately
  - Identify significant changes (>1% movement)
  - Display shareholder relationship to company

- [ ] **Per-stock Trading History Display**
  - Show chronological list of insider trades per stock
  - Display transaction type, date, value, ownership impact
  - Filter by insider type (executive, major shareholder)
  - Support date range filtering

- [ ] **Large Buy/Sell Alerts**
  - Alert when insider purchase exceeds 100M KRW
  - Alert when insider sale exceeds 500M KRW
  - Alert when ownership change exceeds 1%
  - Deliver alerts within 1 hour of DART disclosure

- [ ] **Insider Trading Screening Filters**
  - Filter stocks with recent insider buying (30/60/90 days)
  - Filter by net insider buying value
  - Filter by major shareholder concentration
  - Combine with other screening criteria

## Testing Strategy

### Unit Tests

```python
import pytest
from datetime import date, timedelta
from insider_analyzer import InsiderAnalyzer, InsiderActivity

@pytest.mark.asyncio
async def test_insider_activity_calculation():
    """Test insider activity summary calculation"""
    analyzer = InsiderAnalyzer(mock_session)

    activity = await analyzer.get_insider_activity(
        stock_code='005930',
        start_date=date(2025, 1, 1),
        end_date=date(2025, 1, 31)
    )

    assert isinstance(activity, InsiderActivity)
    assert activity.stock_code == '005930'
    assert activity.buy_count >= 0
    assert activity.sell_count >= 0
    assert activity.insider_sentiment in ['bullish', 'bearish', 'neutral']

def test_sentiment_calculation():
    """Test insider sentiment calculation logic"""
    analyzer = InsiderAnalyzer(mock_session)

    # Test bullish case
    sentiment = analyzer._calculate_sentiment(
        buy_value=200_000_000,
        sell_value=50_000_000,
        buy_count=5,
        sell_count=1
    )
    assert sentiment == 'bullish'

    # Test bearish case
    sentiment = analyzer._calculate_sentiment(
        buy_value=50_000_000,
        sell_value=200_000_000,
        buy_count=1,
        sell_count=5
    )
    assert sentiment == 'bearish'

@pytest.mark.asyncio
async def test_major_shareholder_changes():
    """Test major shareholder change detection"""
    analyzer = InsiderAnalyzer(mock_session)

    changes = await analyzer.get_major_shareholder_changes(
        stock_code='005930',
        lookback_days=90
    )

    assert isinstance(changes, list)
    if changes:
        assert 'ownership_change' in changes[0]
        assert 'shareholder_name' in changes[0]
```

### Integration Tests

```python
@pytest.mark.integration
async def test_dart_insider_disclosure_parsing():
    """Test parsing DART insider disclosure"""
    # Mock DART disclosure
    disclosure = DartDisclosure(
        stock_code='005930',
        report_name_ko='임원ㆍ주요주주특정증권등소유상황보고서',
        content_text='Sample insider trading report...'
    )

    async with AsyncSession() as session:
        await parse_and_store_insider_trade(disclosure, session)
        await session.commit()

        # Verify insider trade was created
        query = select(InsiderTrade).where(
            InsiderTrade.stock_code == '005930'
        )
        result = await session.execute(query)
        trades = result.scalars().all()

        assert len(trades) > 0
```

### E2E Tests

```typescript
describe('Insider Trading Features', () => {
  it('should display insider trades for a stock', async () => {
    await page.goto('/stock/005930');

    // Find insider trading section
    const section = await page.locator('[data-testid="insider-trades"]');
    expect(await section.isVisible()).toBe(true);

    // Check Korean labels
    expect(await page.textContent('h3')).toContain('내부자 거래');

    // Verify trade items
    const trades = await page.locator('[data-testid="insider-trade"]').all();
    if (trades.length > 0) {
      // Check transaction type tag
      const firstTrade = trades[0];
      const typeTag = await firstTrade.locator('.ant-tag').textContent();
      expect(['취득', '처분']).toContain(typeTag);
    }
  });
});
```

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| DART disclosure parsing failures | Medium | High | Implement robust XML/text parsing, comprehensive error handling, manual review queue |
| Incomplete or delayed DART data | Low | Medium | Set up monitoring, fallback to historical data, display data freshness warnings |
| Korean terminology ambiguity | Low | Medium | Maintain terminology mapping table, consult DART documentation, manual verification |
| Privacy concerns with insider names | Low | High | Display public information only (already disclosed), comply with PIPA regulations |
| False positive alerts | Medium | Low | Implement smart filtering, allow user to configure alert thresholds, provide context |

## Performance Requirements

- **Disclosure Parsing**: < 5 seconds per disclosure
- **Insider Activity Query**: < 200ms for 90-day history
- **Major Shareholder Query**: < 300ms per stock
- **Alert Delivery**: < 1 hour from DART disclosure time
- **Dashboard Load**: < 1 second for insider trading panel
- **Concurrent Users**: Support 500+ users viewing insider data simultaneously

## Security Considerations

- **Data Privacy**
  - Display only publicly disclosed information from DART
  - Comply with Korean Personal Information Protection Act (PIPA)
  - Do not infer or speculate beyond disclosed data

- **Access Control**
  - Require authentication to access insider trading data
  - Log all insider data access for audit
  - Rate limit API requests to prevent scraping

- **Input Validation**
  - Validate all DART disclosure data before storing
  - Sanitize Korean text input to prevent injection
  - Verify data integrity with checksums

## Error Handling

```python
import logging

logger = logging.getLogger(__name__)

class InsiderDataError(Exception):
    """Base exception for insider data errors"""
    pass

async def parse_and_store_insider_trade(
    disclosure: DartDisclosure,
    session: AsyncSession
) -> bool:
    """
    Parse and store insider trade from DART disclosure
    """
    try:
        # Parse disclosure content
        trade_data = parse_insider_disclosure_content(disclosure.content_text)

        if not trade_data:
            logger.warning(f"No trade data found in disclosure {disclosure.rcept_no}")
            return False

        # Validate data
        if not validate_insider_trade_data(trade_data):
            logger.error(f"Invalid trade data in disclosure {disclosure.rcept_no}")
            return False

        # Store in database
        insider_trade = InsiderTrade(**trade_data)
        session.add(insider_trade)

        logger.info(f"Stored insider trade from disclosure {disclosure.rcept_no}")
        return True

    except Exception as e:
        logger.exception(f"Failed to parse insider disclosure {disclosure.rcept_no}: {e}")
        raise InsiderDataError(f"Insider disclosure parsing failed: {e}") from e
```

## Dependencies

- Backend: FastAPI, SQLAlchemy, alembic
- Frontend: React, react-intl, Ant Design
- Infrastructure: PostgreSQL, Redis (caching)
- Internal: KR-001 (DART integration for disclosure data)

## References

- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 8: Korea Market Specialization
- [KR-001: DART Integration](KR-001.md) - For DART disclosure access
- [DART Disclosure Types Guide](https://dart.fss.or.kr)
- [Korean PIPA Compliance](https://www.pipc.go.kr)

## Notes

- Insider trading data from DART is public information and legally safe to display
- Consider adding "confidence score" for insiders (based on historical accuracy of their trades)
- Some insider trades are reported with delay (up to 5 days after transaction)
- Treasury stock buybacks are often bullish signals but check the stated purpose
- Coordinate with KR-001 for DART disclosure parsing infrastructure

## Progress

**0% - Not started**
