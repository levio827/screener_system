# MOB-003: Stock Screener Screen

## Metadata

| Field | Value |
|-------|-------|
| **ID** | MOB-003 |
| **Title** | Build Mobile Stock Screener |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P0 (Critical) |
| **Estimate** | 16 hours |
| **Sprint** | Sprint 6 |
| **Epic** | Mobile Application |
| **Assignee** | TBD |
| **Depends On** | MOB-002 |
| **Blocks** | MOB-006 |
| **Created** | 2025-11-29 |
| **Tags** | #mobile #screener #filters #list #performance |

## Description

Implement a mobile-optimized stock screening interface featuring an intuitive filter selection system using Bottom Sheet, virtualized results list for performance, category-based filter organization, and comprehensive sorting options. The screen should seamlessly integrate with the existing backend API and provide a native mobile experience with gesture-based interactions.

## Subtasks

### Filter Selection UI
- [ ] Implement Filter Bottom Sheet
  - [ ] Create reusable Bottom Sheet component with `@gorhom/bottom-sheet`
  - [ ] Add snap points (25%, 50%, 75%, 100%)
  - [ ] Implement backdrop press to dismiss
  - [ ] Add gesture indicator handle
- [ ] Build filter category navigation
  - [ ] Horizontal category tabs (Valuation, Growth, Technical, etc.)
  - [ ] Category icons and labels
  - [ ] Active category indicator
  - [ ] Swipe between categories
- [ ] Create individual filter controls
  - [ ] Range slider for numeric filters (P/E, P/B, etc.)
  - [ ] Multi-select chips for categorical filters (Sector, Market)
  - [ ] Toggle switches for boolean filters
  - [ ] Date range picker for time-based filters
- [ ] Implement filter state management
  - [ ] Active filters summary badge
  - [ ] Clear all filters button
  - [ ] Filter preset save/load

### Search Results List
- [ ] Implement virtualized list with FlatList
  - [ ] Configure `getItemLayout` for fixed height rows
  - [ ] Set `windowSize` and `maxToRenderPerBatch` for optimization
  - [ ] Implement `keyExtractor` with stock code
- [ ] Create stock list item component
  - [ ] Stock name and code
  - [ ] Current price with change indicator
  - [ ] Key metrics preview (P/E, Change %)
  - [ ] Sparkline mini chart (optional)
  - [ ] Swipe actions (add to watchlist, set alert)
- [ ] Implement infinite scroll pagination
  - [ ] Load 20 items per page
  - [ ] Show loading indicator at bottom
  - [ ] Handle end of list gracefully
- [ ] Add pull-to-refresh
  - [ ] Native RefreshControl component
  - [ ] Reset pagination on refresh
  - [ ] Show last updated timestamp

### Sorting Options
- [ ] Create sort options modal/Bottom Sheet
  - [ ] Sort by: Name, Price, Change %, Volume, Market Cap, P/E, P/B
  - [ ] Ascending/Descending toggle
  - [ ] Remember last sort preference
- [ ] Implement sorting logic
  - [ ] Client-side sorting for loaded data
  - [ ] Server-side sorting for new queries
  - [ ] Sort indicator in list header

### Saved Screening Templates
- [ ] Template management UI
  - [ ] Save current filter as template
  - [ ] Template name input
  - [ ] Load existing templates
  - [ ] Delete template functionality
- [ ] Template persistence
  - [ ] Store in AsyncStorage
  - [ ] Sync with backend (logged-in users)
  - [ ] Default templates (Growth, Value, Dividend)

### Search and Quick Filter
- [ ] Implement search bar
  - [ ] Stock name/code autocomplete
  - [ ] Recent searches
  - [ ] Popular searches
- [ ] Quick filter chips
  - [ ] "Today's Gainers"
  - [ ] "High Volume"
  - [ ] "52-Week High"
  - [ ] Custom quick filters

## Implementation Details

### Filter Bottom Sheet
```typescript
// src/components/screener/FilterBottomSheet.tsx
import BottomSheet, { BottomSheetBackdrop, BottomSheetScrollView } from '@gorhom/bottom-sheet';
import { useCallback, useMemo, useRef } from 'react';

interface FilterBottomSheetProps {
  isOpen: boolean;
  onClose: () => void;
  filters: ScreenerFilters;
  onFiltersChange: (filters: ScreenerFilters) => void;
}

export function FilterBottomSheet({ isOpen, onClose, filters, onFiltersChange }: FilterBottomSheetProps) {
  const bottomSheetRef = useRef<BottomSheet>(null);
  const snapPoints = useMemo(() => ['25%', '50%', '90%'], []);

  const renderBackdrop = useCallback(
    (props) => (
      <BottomSheetBackdrop
        {...props}
        disappearsOnIndex={-1}
        appearsOnIndex={0}
        opacity={0.5}
      />
    ),
    []
  );

  const categories: FilterCategory[] = [
    { id: 'valuation', label: '가치', icon: 'analytics' },
    { id: 'growth', label: '성장', icon: 'trending-up' },
    { id: 'technical', label: '기술적', icon: 'stats-chart' },
    { id: 'financial', label: '재무', icon: 'wallet' },
    { id: 'sector', label: '섹터', icon: 'business' },
  ];

  return (
    <BottomSheet
      ref={bottomSheetRef}
      index={isOpen ? 1 : -1}
      snapPoints={snapPoints}
      enablePanDownToClose
      onClose={onClose}
      backdropComponent={renderBackdrop}
    >
      <BottomSheetScrollView style={styles.contentContainer}>
        <FilterCategoryTabs
          categories={categories}
          activeCategory={activeCategory}
          onCategoryChange={setActiveCategory}
        />
        <FilterControls
          category={activeCategory}
          filters={filters}
          onChange={onFiltersChange}
        />
        <View style={styles.actions}>
          <Button variant="outline" onPress={clearFilters}>
            필터 초기화
          </Button>
          <Button variant="primary" onPress={applyFilters}>
            {activeFilterCount}개 필터 적용
          </Button>
        </View>
      </BottomSheetScrollView>
    </BottomSheet>
  );
}
```

### Optimized Stock List
```typescript
// src/components/screener/StockList.tsx
import { FlatList, RefreshControl } from 'react-native';
import { useCallback, useMemo } from 'react';

interface StockListProps {
  stocks: Stock[];
  isLoading: boolean;
  onRefresh: () => void;
  onEndReached: () => void;
  onStockPress: (stockCode: string) => void;
}

const ITEM_HEIGHT = 72; // Fixed height for getItemLayout optimization

export function StockList({
  stocks,
  isLoading,
  onRefresh,
  onEndReached,
  onStockPress,
}: StockListProps) {
  const getItemLayout = useCallback(
    (_: unknown, index: number) => ({
      length: ITEM_HEIGHT,
      offset: ITEM_HEIGHT * index,
      index,
    }),
    []
  );

  const renderItem = useCallback(
    ({ item }: { item: Stock }) => (
      <StockListItem
        stock={item}
        onPress={() => onStockPress(item.code)}
      />
    ),
    [onStockPress]
  );

  const keyExtractor = useCallback((item: Stock) => item.code, []);

  const ListFooter = useMemo(
    () => isLoading ? <ActivityIndicator style={styles.loader} /> : null,
    [isLoading]
  );

  return (
    <FlatList
      data={stocks}
      renderItem={renderItem}
      keyExtractor={keyExtractor}
      getItemLayout={getItemLayout}
      windowSize={10}
      maxToRenderPerBatch={10}
      initialNumToRender={15}
      removeClippedSubviews
      onEndReached={onEndReached}
      onEndReachedThreshold={0.5}
      ListFooterComponent={ListFooter}
      refreshControl={
        <RefreshControl
          refreshing={isLoading && stocks.length === 0}
          onRefresh={onRefresh}
          tintColor={colors.primary}
        />
      }
      ItemSeparatorComponent={ListSeparator}
    />
  );
}

// Stock List Item with Swipe Actions
function StockListItem({ stock, onPress }: StockListItemProps) {
  const swipeableRef = useRef<Swipeable>(null);

  const renderRightActions = () => (
    <View style={styles.swipeActions}>
      <TouchableOpacity
        style={[styles.swipeAction, styles.watchlistAction]}
        onPress={() => addToWatchlist(stock.code)}
      >
        <Ionicons name="star-outline" size={20} color="white" />
      </TouchableOpacity>
      <TouchableOpacity
        style={[styles.swipeAction, styles.alertAction]}
        onPress={() => createAlert(stock.code)}
      >
        <Ionicons name="notifications-outline" size={20} color="white" />
      </TouchableOpacity>
    </View>
  );

  return (
    <Swipeable
      ref={swipeableRef}
      renderRightActions={renderRightActions}
      friction={2}
    >
      <TouchableOpacity onPress={onPress} style={styles.itemContainer}>
        <View style={styles.stockInfo}>
          <Text style={styles.stockName}>{stock.name}</Text>
          <Text style={styles.stockCode}>{stock.code}</Text>
        </View>
        <View style={styles.priceInfo}>
          <Text style={styles.price}>{formatPrice(stock.price)}</Text>
          <Text style={[styles.change, stock.changePercent >= 0 ? styles.positive : styles.negative]}>
            {formatPercent(stock.changePercent)}
          </Text>
        </View>
        <View style={styles.metrics}>
          <Text style={styles.metric}>P/E {stock.per?.toFixed(1) ?? '-'}</Text>
        </View>
      </TouchableOpacity>
    </Swipeable>
  );
}
```

### Screener Store with React Query
```typescript
// src/store/screenerStore.ts
import { create } from 'zustand';
import { useInfiniteQuery, useMutation } from '@tanstack/react-query';

interface ScreenerFilters {
  marketCap?: { min?: number; max?: number };
  per?: { min?: number; max?: number };
  pbr?: { min?: number; max?: number };
  dividendYield?: { min?: number; max?: number };
  sectors?: string[];
  markets?: ('KOSPI' | 'KOSDAQ')[];
  changePercent?: { min?: number; max?: number };
}

interface ScreenerState {
  filters: ScreenerFilters;
  sortBy: string;
  sortOrder: 'asc' | 'desc';
  setFilters: (filters: ScreenerFilters) => void;
  setSorting: (sortBy: string, sortOrder: 'asc' | 'desc') => void;
  clearFilters: () => void;
}

export const useScreenerStore = create<ScreenerState>((set) => ({
  filters: {},
  sortBy: 'marketCap',
  sortOrder: 'desc',
  setFilters: (filters) => set({ filters }),
  setSorting: (sortBy, sortOrder) => set({ sortBy, sortOrder }),
  clearFilters: () => set({ filters: {} }),
}));

// React Query hook for screener data
export function useScreenerQuery() {
  const { filters, sortBy, sortOrder } = useScreenerStore();

  return useInfiniteQuery({
    queryKey: ['screener', filters, sortBy, sortOrder],
    queryFn: async ({ pageParam = 1 }) => {
      const response = await screenerApi.search({
        filters,
        sortBy,
        sortOrder,
        page: pageParam,
        limit: 20,
      });
      return response;
    },
    getNextPageParam: (lastPage) =>
      lastPage.hasMore ? lastPage.page + 1 : undefined,
    staleTime: 30 * 1000, // 30 seconds
  });
}
```

### Filter Template Management
```typescript
// src/services/filterTemplates.ts
import AsyncStorage from '@react-native-async-storage/async-storage';

const TEMPLATES_KEY = 'screener_templates';

export interface FilterTemplate {
  id: string;
  name: string;
  filters: ScreenerFilters;
  createdAt: string;
  isDefault?: boolean;
}

export const filterTemplateService = {
  async getTemplates(): Promise<FilterTemplate[]> {
    const stored = await AsyncStorage.getItem(TEMPLATES_KEY);
    const userTemplates = stored ? JSON.parse(stored) : [];
    return [...DEFAULT_TEMPLATES, ...userTemplates];
  },

  async saveTemplate(name: string, filters: ScreenerFilters): Promise<FilterTemplate> {
    const templates = await this.getTemplates();
    const newTemplate: FilterTemplate = {
      id: uuid(),
      name,
      filters,
      createdAt: new Date().toISOString(),
    };
    const userTemplates = templates.filter((t) => !t.isDefault);
    await AsyncStorage.setItem(
      TEMPLATES_KEY,
      JSON.stringify([...userTemplates, newTemplate])
    );
    return newTemplate;
  },

  async deleteTemplate(id: string): Promise<void> {
    const templates = await this.getTemplates();
    const filtered = templates.filter((t) => t.id !== id && !t.isDefault);
    await AsyncStorage.setItem(TEMPLATES_KEY, JSON.stringify(filtered));
  },
};

const DEFAULT_TEMPLATES: FilterTemplate[] = [
  {
    id: 'default-value',
    name: '가치주',
    filters: { per: { max: 10 }, pbr: { max: 1 } },
    createdAt: '',
    isDefault: true,
  },
  {
    id: 'default-growth',
    name: '성장주',
    filters: { changePercent: { min: 0 } },
    createdAt: '',
    isDefault: true,
  },
  {
    id: 'default-dividend',
    name: '배당주',
    filters: { dividendYield: { min: 3 } },
    createdAt: '',
    isDefault: true,
  },
];
```

## Acceptance Criteria

- [ ] Filter Bottom Sheet opens/closes smoothly with gestures
- [ ] All filter categories are accessible and functional
- [ ] Range sliders work correctly for numeric filters
- [ ] Multi-select works for sector/market filters
- [ ] Active filters count badge updates in real-time
- [ ] Stock list loads initial 20 items quickly (< 500ms)
- [ ] Infinite scroll loads more items seamlessly
- [ ] Pull-to-refresh resets and reloads data
- [ ] Sort options work correctly (client and server-side)
- [ ] Swipe actions reveal watchlist/alert buttons
- [ ] Filter templates can be saved and loaded
- [ ] Search autocomplete shows relevant suggestions
- [ ] Empty state shows when no results match filters
- [ ] Error state displays with retry button

## Testing Strategy

### Unit Tests
- [ ] Filter state management (Zustand store)
- [ ] Filter template save/load/delete
- [ ] Sort logic (ascending/descending)
- [ ] Pagination logic

### Integration Tests
- [ ] Filter application and API call
- [ ] Infinite scroll pagination
- [ ] Pull-to-refresh functionality
- [ ] Search autocomplete with debounce

### Performance Tests
- [ ] FlatList scroll performance (60 fps)
- [ ] Memory usage with 1000+ items
- [ ] Filter change response time

### Manual Testing
- [ ] Test on low-end Android devices
- [ ] Test with slow network (3G)
- [ ] Test filter combinations
- [ ] Test landscape orientation

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| List performance issues on low-end devices | Medium | High | Use getItemLayout, remove clipped subviews |
| Complex filter state bugs | Medium | Medium | Comprehensive unit tests, state normalization |
| API response time for complex filters | Medium | Medium | Client-side caching, optimistic updates |
| Bottom Sheet gesture conflicts | Low | Medium | Thorough gesture handler testing |
| Memory leaks from virtualized list | Low | High | Proper cleanup, memory profiling |

## Performance Requirements

- Initial list render: < 500ms
- Filter application: < 200ms (UI), < 1s (API)
- Scroll frame rate: 60 fps consistently
- Memory usage: < 100MB with 500 items loaded
- Search autocomplete response: < 300ms

## Security Considerations

- [ ] Sanitize search input to prevent injection
- [ ] Validate filter values before API calls
- [ ] Rate limit filter changes to prevent API abuse
- [ ] Secure template storage for logged-in users

## Error Handling

```typescript
// src/components/screener/ScreenerErrorBoundary.tsx
export function ScreenerErrorBoundary({ children }: PropsWithChildren) {
  return (
    <ErrorBoundary
      fallback={({ error, resetError }) => (
        <View style={styles.errorContainer}>
          <Ionicons name="alert-circle" size={48} color={colors.error} />
          <Text style={styles.errorTitle}>스크리너를 불러올 수 없습니다</Text>
          <Text style={styles.errorMessage}>{error.message}</Text>
          <Button onPress={resetError}>다시 시도</Button>
        </View>
      )}
    >
      {children}
    </ErrorBoundary>
  );
}

// API Error States
const ERROR_MESSAGES = {
  NETWORK: '네트워크 연결을 확인해주세요.',
  TIMEOUT: '요청 시간이 초과되었습니다. 다시 시도해주세요.',
  SERVER: '서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요.',
  NO_RESULTS: '검색 조건에 맞는 종목이 없습니다.',
};
```

## Dependencies

- **Depends On**: MOB-002 (Navigation & Auth)
- **Blocks**: MOB-006 (Portfolio & Watchlist)
- **External**:
  - Backend screener API endpoints
  - `@gorhom/bottom-sheet` package
  - `react-native-gesture-handler`
  - `@tanstack/react-query`

## References

- **SDS.md**: Section 4.3 Mobile Screener Architecture
- [React Native FlatList Optimization](https://reactnative.dev/docs/optimizing-flatlist-configuration)
- [Bottom Sheet Library](https://gorhom.github.io/react-native-bottom-sheet/)
- [React Query Infinite Queries](https://tanstack.com/query/latest/docs/react/guides/infinite-queries)
- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 3: Mobile Application

## Progress

- **0%** - Not started

## Notes

- Consider implementing skeleton loading for better perceived performance
- Test filter persistence across app restarts
- Ensure filter UI is accessible (VoiceOver/TalkBack)
- Consider haptic feedback for filter interactions
- Monitor API response times for complex filter combinations
- Add analytics for popular filter combinations
