# MOB-006: Portfolio & Watchlist

## Metadata

| Field | Value |
|-------|-------|
| **ID** | MOB-006 |
| **Title** | Build Portfolio and Watchlist Screens |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P1 (High) |
| **Estimate** | 12 hours |
| **Sprint** | Sprint 7 |
| **Epic** | Mobile Application |
| **Assignee** | TBD |
| **Depends On** | MOB-003, MOB-004 |
| **Blocks** | MOB-007 |
| **Created** | 2025-11-29 |
| **Tags** | #mobile #portfolio #watchlist #returns #widget |

## Description

Implement comprehensive portfolio and watchlist management screens for mobile users. The portfolio feature should allow users to track their stock holdings, calculate real-time returns, and visualize their investment performance. The watchlist feature should enable users to organize stocks they're interested in with drag-and-drop sorting. Both features should support iOS and Android home screen widgets for quick access to key information.

## Subtasks

### Portfolio Screen
- [ ] Create portfolio list screen
  - [ ] Total portfolio value display
  - [ ] Daily/total gain/loss summary
  - [ ] Percentage allocation pie chart
  - [ ] Holdings list with current values
- [ ] Implement portfolio detail screen
  - [ ] Individual holding performance
  - [ ] Purchase history
  - [ ] Average cost basis
  - [ ] Realized vs unrealized gains
- [ ] Add/Edit holding flow
  - [ ] Stock search and selection
  - [ ] Purchase price input
  - [ ] Quantity input
  - [ ] Purchase date picker
  - [ ] Multiple lots support
- [ ] Delete holding functionality
  - [ ] Confirmation dialog
  - [ ] Undo option (toast)
- [ ] Return calculations
  - [ ] Real-time price updates
  - [ ] Cost basis methods (FIFO, average)
  - [ ] Currency formatting
  - [ ] Percentage and absolute returns

### Watchlist Screen
- [ ] Create watchlist list screen
  - [ ] Multiple watchlist support
  - [ ] Default watchlist creation
  - [ ] Watchlist overview (count, performance)
- [ ] Implement watchlist detail screen
  - [ ] Stock list with current prices
  - [ ] Mini charts for each stock
  - [ ] Quick metrics (change %, volume)
- [ ] Add/Remove stocks
  - [ ] Search and add from screener
  - [ ] Remove with swipe gesture
  - [ ] Quick add from stock detail
- [ ] Drag and drop sorting
  - [ ] Reorderable list with haptic feedback
  - [ ] Save order to backend/local storage
  - [ ] Smooth animations
- [ ] Watchlist management
  - [ ] Create new watchlist
  - [ ] Rename watchlist
  - [ ] Delete watchlist
  - [ ] Merge watchlists

### Home Screen Widgets
- [ ] iOS Widget implementation
  - [ ] Small widget (portfolio total)
  - [ ] Medium widget (top 3 holdings)
  - [ ] Large widget (full portfolio)
  - [ ] Use `expo-widgets` or native module
- [ ] Android Widget implementation
  - [ ] Small widget (portfolio total)
  - [ ] Medium widget (watchlist preview)
  - [ ] Widget refresh interval
  - [ ] Tap to open app
- [ ] Widget data provider
  - [ ] Background data refresh
  - [ ] Efficient data serialization
  - [ ] Cache management

### Data Synchronization
- [ ] Local storage with AsyncStorage
  - [ ] Offline portfolio viewing
  - [ ] Optimistic updates
  - [ ] Sync queue for offline changes
- [ ] Backend synchronization
  - [ ] Real-time sync with conflict resolution
  - [ ] Multi-device support
  - [ ] Backup and restore

## Implementation Details

### Portfolio Screen Structure
```typescript
// src/screens/PortfolioScreen.tsx
import { useQuery, useMutation } from '@tanstack/react-query';
import Animated, { Layout, FadeInDown } from 'react-native-reanimated';

export function PortfolioScreen() {
  const { data: portfolio, isLoading } = useQuery({
    queryKey: ['portfolio'],
    queryFn: portfolioApi.getPortfolio,
    refetchInterval: 60 * 1000, // Refresh every minute during market hours
  });

  const totalValue = useMemo(() =>
    portfolio?.holdings.reduce((sum, h) => sum + h.currentValue, 0) ?? 0,
    [portfolio]
  );

  const totalReturn = useMemo(() => {
    if (!portfolio) return { value: 0, percent: 0 };
    const totalCost = portfolio.holdings.reduce((sum, h) => sum + h.totalCost, 0);
    return {
      value: totalValue - totalCost,
      percent: totalCost > 0 ? ((totalValue - totalCost) / totalCost) * 100 : 0,
    };
  }, [portfolio, totalValue]);

  if (isLoading) return <PortfolioSkeleton />;

  return (
    <View style={styles.container}>
      <PortfolioSummary
        totalValue={totalValue}
        totalReturn={totalReturn}
        dailyChange={portfolio?.dailyChange}
      />
      <AllocationChart holdings={portfolio?.holdings ?? []} />
      <HoldingsList
        holdings={portfolio?.holdings ?? []}
        onHoldingPress={(id) => navigation.navigate('HoldingDetail', { id })}
        onAddPress={() => navigation.navigate('AddHolding')}
      />
    </View>
  );
}

function PortfolioSummary({ totalValue, totalReturn, dailyChange }) {
  return (
    <Animated.View entering={FadeInDown} style={styles.summary}>
      <Text style={styles.label}>총 자산</Text>
      <Text style={styles.totalValue}>{formatCurrency(totalValue)}</Text>
      <View style={styles.returns}>
        <ReturnBadge
          label="총 수익"
          value={totalReturn.value}
          percent={totalReturn.percent}
        />
        <ReturnBadge
          label="오늘"
          value={dailyChange?.value}
          percent={dailyChange?.percent}
        />
      </View>
    </Animated.View>
  );
}
```

### Holdings List with Swipe Actions
```typescript
// src/components/portfolio/HoldingsList.tsx
import { SwipeListView } from 'react-native-swipe-list-view';

export function HoldingsList({ holdings, onHoldingPress, onDeleteHolding }) {
  const renderItem = useCallback(({ item }: { item: Holding }) => (
    <TouchableHighlight
      onPress={() => onHoldingPress(item.id)}
      underlayColor={colors.highlight}
    >
      <View style={styles.holdingItem}>
        <View style={styles.stockInfo}>
          <Text style={styles.stockName}>{item.stockName}</Text>
          <Text style={styles.stockCode}>{item.stockCode}</Text>
          <Text style={styles.shares}>{item.shares}주</Text>
        </View>
        <View style={styles.valueInfo}>
          <Text style={styles.currentValue}>{formatCurrency(item.currentValue)}</Text>
          <Text style={[styles.return, item.returnPercent >= 0 ? styles.positive : styles.negative]}>
            {formatPercent(item.returnPercent)}
          </Text>
          <Text style={styles.returnValue}>
            {item.returnValue >= 0 ? '+' : ''}{formatCurrency(item.returnValue)}
          </Text>
        </View>
      </View>
    </TouchableHighlight>
  ), [onHoldingPress]);

  const renderHiddenItem = useCallback(({ item }: { item: Holding }) => (
    <View style={styles.hiddenRow}>
      <TouchableOpacity
        style={styles.editButton}
        onPress={() => navigation.navigate('EditHolding', { id: item.id })}
      >
        <Ionicons name="create-outline" size={24} color="white" />
      </TouchableOpacity>
      <TouchableOpacity
        style={styles.deleteButton}
        onPress={() => confirmDelete(item)}
      >
        <Ionicons name="trash-outline" size={24} color="white" />
      </TouchableOpacity>
    </View>
  ), []);

  return (
    <SwipeListView
      data={holdings}
      renderItem={renderItem}
      renderHiddenItem={renderHiddenItem}
      rightOpenValue={-150}
      disableRightSwipe
      keyExtractor={(item) => item.id}
      ItemSeparatorComponent={Separator}
    />
  );
}
```

### Add/Edit Holding Form
```typescript
// src/screens/AddHoldingScreen.tsx
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const holdingSchema = z.object({
  stockCode: z.string().min(1, '종목을 선택해주세요'),
  shares: z.number().min(1, '1주 이상 입력해주세요'),
  purchasePrice: z.number().min(0, '매수가를 입력해주세요'),
  purchaseDate: z.date(),
});

type HoldingFormData = z.infer<typeof holdingSchema>;

export function AddHoldingScreen() {
  const { control, handleSubmit, formState: { errors } } = useForm<HoldingFormData>({
    resolver: zodResolver(holdingSchema),
    defaultValues: {
      purchaseDate: new Date(),
    },
  });

  const addMutation = useMutation({
    mutationFn: portfolioApi.addHolding,
    onSuccess: () => {
      queryClient.invalidateQueries(['portfolio']);
      navigation.goBack();
      showToast('보유 종목이 추가되었습니다');
    },
  });

  const onSubmit = (data: HoldingFormData) => {
    addMutation.mutate(data);
  };

  return (
    <KeyboardAvoidingView style={styles.container}>
      <ScrollView>
        <Controller
          name="stockCode"
          control={control}
          render={({ field }) => (
            <StockSearchInput
              value={field.value}
              onSelect={(stock) => field.onChange(stock.code)}
              error={errors.stockCode?.message}
            />
          )}
        />
        <Controller
          name="shares"
          control={control}
          render={({ field }) => (
            <NumberInput
              label="수량"
              value={field.value}
              onChange={field.onChange}
              suffix="주"
              error={errors.shares?.message}
            />
          )}
        />
        <Controller
          name="purchasePrice"
          control={control}
          render={({ field }) => (
            <CurrencyInput
              label="매수가"
              value={field.value}
              onChange={field.onChange}
              error={errors.purchasePrice?.message}
            />
          )}
        />
        <Controller
          name="purchaseDate"
          control={control}
          render={({ field }) => (
            <DatePicker
              label="매수일"
              value={field.value}
              onChange={field.onChange}
              maximumDate={new Date()}
            />
          )}
        />
      </ScrollView>
      <Button
        title="추가하기"
        onPress={handleSubmit(onSubmit)}
        loading={addMutation.isPending}
      />
    </KeyboardAvoidingView>
  );
}
```

### Drag and Drop Watchlist
```typescript
// src/components/watchlist/DraggableWatchlist.tsx
import DraggableFlatList, { RenderItemParams, ScaleDecorator } from 'react-native-draggable-flatlist';
import * as Haptics from 'expo-haptics';

export function DraggableWatchlist({ watchlistId, stocks, onReorder }) {
  const reorderMutation = useMutation({
    mutationFn: (newOrder: string[]) =>
      watchlistApi.reorder(watchlistId, newOrder),
    onMutate: async (newOrder) => {
      await queryClient.cancelQueries(['watchlist', watchlistId]);
      const previousData = queryClient.getQueryData(['watchlist', watchlistId]);
      queryClient.setQueryData(['watchlist', watchlistId], (old) => ({
        ...old,
        stocks: newOrder.map((code) => old.stocks.find((s) => s.code === code)),
      }));
      return { previousData };
    },
    onError: (err, variables, context) => {
      queryClient.setQueryData(['watchlist', watchlistId], context.previousData);
    },
  });

  const handleDragEnd = useCallback(({ data }: { data: WatchlistStock[] }) => {
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    const newOrder = data.map((s) => s.code);
    reorderMutation.mutate(newOrder);
    onReorder?.(data);
  }, [reorderMutation, onReorder]);

  const renderItem = useCallback(({ item, drag, isActive }: RenderItemParams<WatchlistStock>) => (
    <ScaleDecorator>
      <TouchableOpacity
        onLongPress={() => {
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
          drag();
        }}
        disabled={isActive}
        style={[styles.item, isActive && styles.activeItem]}
      >
        <WatchlistStockItem stock={item} />
        <Ionicons name="reorder-three" size={20} color={colors.secondary} />
      </TouchableOpacity>
    </ScaleDecorator>
  ), []);

  return (
    <DraggableFlatList
      data={stocks}
      renderItem={renderItem}
      keyExtractor={(item) => item.code}
      onDragEnd={handleDragEnd}
    />
  );
}
```

### iOS Widget (using expo-widgets or native)
```typescript
// src/widgets/PortfolioWidget.tsx (concept - requires native module)
interface WidgetData {
  totalValue: number;
  dailyChange: number;
  dailyChangePercent: number;
  holdings: Array<{
    name: string;
    code: string;
    value: number;
    changePercent: number;
  }>;
  lastUpdated: string;
}

// Widget data provider
export async function getWidgetData(): Promise<WidgetData> {
  try {
    const portfolio = await portfolioApi.getPortfolio();
    return {
      totalValue: portfolio.totalValue,
      dailyChange: portfolio.dailyChange.value,
      dailyChangePercent: portfolio.dailyChange.percent,
      holdings: portfolio.holdings.slice(0, 5).map((h) => ({
        name: h.stockName,
        code: h.stockCode,
        value: h.currentValue,
        changePercent: h.dailyChangePercent,
      })),
      lastUpdated: new Date().toISOString(),
    };
  } catch (error) {
    // Return cached data on error
    return await AsyncStorage.getItem('widgetData').then(JSON.parse);
  }
}

// Background task for widget refresh
export async function refreshWidgetData() {
  const data = await getWidgetData();
  await AsyncStorage.setItem('widgetData', JSON.stringify(data));
  // Notify native widget to reload
  NativeModules.WidgetModule?.reloadAllWidgets();
}
```

## Acceptance Criteria

- [ ] Portfolio screen shows accurate total value and returns
- [ ] Holdings list displays all stocks with current prices
- [ ] Add holding form validates input correctly
- [ ] Edit holding updates values correctly
- [ ] Delete holding removes from portfolio with undo
- [ ] Return calculations match actual performance
- [ ] Watchlist supports multiple lists
- [ ] Drag and drop reordering works with haptic feedback
- [ ] Stock can be added/removed from watchlist
- [ ] Watchlist order persists across sessions
- [ ] iOS widget shows portfolio summary
- [ ] Android widget shows portfolio/watchlist
- [ ] Widgets update automatically
- [ ] Tapping widget opens relevant screen
- [ ] Offline mode shows cached data

## Testing Strategy

### Unit Tests
- [ ] Return calculation formulas
- [ ] Cost basis methods (FIFO, average)
- [ ] Currency formatting
- [ ] Data transformation for widgets

### Integration Tests
- [ ] Add/edit/delete holding flows
- [ ] Watchlist CRUD operations
- [ ] Drag and drop reorder persistence
- [ ] Sync with backend

### E2E Tests
- [ ] Full portfolio management flow
- [ ] Watchlist creation and management
- [ ] Widget data accuracy

### Manual Testing
- [ ] Test widgets on various device sizes
- [ ] Test offline functionality
- [ ] Test multi-device sync
- [ ] Test with large number of holdings

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Inaccurate return calculations | Medium | High | Comprehensive unit tests, audit formula |
| Widget sync issues | Medium | Medium | Robust caching, error handling |
| Drag and drop performance | Low | Medium | Use native driver, limit list size |
| Data loss during sync | Low | Critical | Conflict resolution, backup |
| Widget memory constraints | Medium | Medium | Efficient data structure, lazy loading |

## Performance Requirements

- Portfolio screen load: < 500ms
- Holding add/edit save: < 1 second
- Return recalculation: < 100ms
- Drag and drop: 60 fps
- Widget update: < 2 seconds background
- Offline data retrieval: < 100ms

## Security Considerations

- [ ] Encrypt portfolio data at rest
- [ ] Secure multi-device sync authentication
- [ ] Validate all monetary inputs
- [ ] Audit logging for portfolio changes
- [ ] Don't expose sensitive data in widgets
- [ ] Implement data export with authentication

## Error Handling

```typescript
// src/utils/portfolioErrors.ts
export const PORTFOLIO_ERRORS = {
  ADD_FAILED: '종목 추가에 실패했습니다. 다시 시도해주세요.',
  UPDATE_FAILED: '수정에 실패했습니다. 다시 시도해주세요.',
  DELETE_FAILED: '삭제에 실패했습니다. 다시 시도해주세요.',
  SYNC_FAILED: '동기화에 실패했습니다. 인터넷 연결을 확인해주세요.',
  PRICE_FETCH_FAILED: '가격 정보를 가져올 수 없습니다.',
  INVALID_INPUT: '입력 값을 확인해주세요.',
};

// Undo functionality
export function useUndoDelete(queryKey: string[]) {
  const [deletedItem, setDeletedItem] = useState<any>(null);
  const timeoutRef = useRef<NodeJS.Timeout>();

  const handleDelete = useCallback((item: any, deleteFn: () => Promise<void>) => {
    setDeletedItem(item);
    // Optimistic delete
    queryClient.setQueryData(queryKey, (old) => /* remove item */);

    showToast({
      message: '삭제되었습니다',
      action: {
        label: '실행 취소',
        onPress: () => {
          clearTimeout(timeoutRef.current);
          // Restore item
          queryClient.setQueryData(queryKey, (old) => /* restore item */);
          setDeletedItem(null);
        },
      },
    });

    timeoutRef.current = setTimeout(async () => {
      await deleteFn();
      setDeletedItem(null);
    }, 5000);
  }, [queryKey]);

  return { handleDelete };
}
```

## Dependencies

- **Depends On**: MOB-003 (Screener), MOB-004 (Stock Detail)
- **Blocks**: MOB-007 (App Store Submission)
- **External**:
  - Backend portfolio/watchlist API
  - `react-native-draggable-flatlist`
  - `react-native-swipe-list-view`
  - `expo-haptics`
  - Native widget modules (iOS/Android)

## References

- **SDS.md**: Section 4.6 Portfolio Management
- [React Native Draggable FlatList](https://github.com/computerjazz/react-native-draggable-flatlist)
- [Expo Haptics](https://docs.expo.dev/versions/latest/sdk/haptics/)
- [iOS WidgetKit](https://developer.apple.com/documentation/widgetkit)
- [Android App Widgets](https://developer.android.com/develop/ui/views/appwidgets)
- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 3: Mobile Application

## Progress

- **0%** - Not started

## Notes

- Consider implementing Quick Actions (3D Touch / long press)
- Widget development may require ejecting from Expo
- Test portfolio with various edge cases (stock splits, dividends)
- Consider implementing portfolio import from brokerage
- Add support for multiple currencies if needed
- Implement data export for tax purposes
