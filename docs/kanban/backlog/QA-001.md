# QA-001: Fix WebSocket Flaky Tests

## Metadata

| Field | Value |
|-------|-------|
| **ID** | QA-001 |
| **Title** | Fix WebSocket Flaky Tests in CI Environment |
| **Type** | Bug Fix |
| **Status** | BACKLOG |
| **Priority** | P2 (Medium) |
| **Estimate** | 6 hours |
| **Sprint** | Sprint 7 |
| **Epic** | Quality Assurance |
| **Assignee** | TBD |
| **Created** | 2025-11-30 |
| **Tags** | #backend #testing #websocket #ci #flaky-tests #asyncio |

## Description

Fix 4 flaky WebSocket tests that are failing intermittently in CI environment due to async event loop issues. These tests pass locally but fail in GitHub Actions CI due to event loop timing and cleanup issues.

### Failing Tests

1. `tests/api/test_websocket.py::TestWebSocketPhase3::test_reconnect_with_user_mismatch`
   - Error: `RuntimeError: Event loop is closed`

2. `tests/api/test_websocket.py::TestPhase4Features::test_batch_flush_loop`
   - Error: `AssertionError: assert 3 == 0` (message queue not properly cleaned between tests)

3. `tests/api/test_websocket.py::TestWebSocketSubscriptionLimits::test_subscribe_too_many_targets`
   - Error: `RuntimeError: Event loop is closed`

4. `tests/api/test_websocket.py::TestWebSocketSubscriptionLimits::test_subscribe_exceeds_total_limit`
   - Error: `AssertionError: assert 'pong' == 'subscribed'` (race condition)

## Subtasks

### Root Cause Analysis
- [ ] Analyze event loop lifecycle in test fixtures
  - [ ] Review `pytest-asyncio` configuration
  - [ ] Check event loop scope (function vs session)
  - [ ] Identify where event loop is prematurely closed
- [ ] Analyze test isolation issues
  - [ ] Check if ConnectionManager state persists between tests
  - [ ] Verify message queue cleanup
  - [ ] Review Redis mock behavior
- [ ] Analyze race conditions
  - [ ] Review async timing in subscription tests
  - [ ] Check await points and message handling order

### Event Loop Fixes
- [ ] Configure proper event loop scope
  - [ ] Consider `pytest.mark.asyncio(loop_scope="class")` for WebSocket tests
  - [ ] Or use `@pytest.fixture(scope="class")` for event loop
- [ ] Ensure proper event loop cleanup
  - [ ] Add explicit cleanup in fixture teardown
  - [ ] Handle pending tasks before loop closure
- [ ] Fix event loop closed errors
  - [ ] Wrap async operations in proper try/finally
  - [ ] Use `asyncio.get_running_loop()` instead of `asyncio.get_event_loop()`

### Test Isolation Fixes
- [ ] Reset ConnectionManager state between tests
  - [ ] Clear `_connections` dict
  - [ ] Clear `_message_queues` dict
  - [ ] Clear `_subscriptions` dict
- [ ] Ensure proper fixture scope
  - [ ] Create fresh ConnectionManager for each test
  - [ ] Or properly reset state in fixture setup
- [ ] Add explicit state verification
  - [ ] Assert clean state at test start
  - [ ] Verify cleanup at test end

### Race Condition Fixes
- [ ] Add proper synchronization
  - [ ] Use `asyncio.Event` for coordination
  - [ ] Add timeouts with proper error messages
- [ ] Fix subscription timing issues
  - [ ] Wait for subscription confirmation before sending messages
  - [ ] Use `asyncio.wait_for()` with appropriate timeout
- [ ] Handle message ordering
  - [ ] Ensure deterministic message processing
  - [ ] Add sequence verification

### Testing
- [ ] Run tests in isolation
  - [ ] Verify each test passes individually
  - [ ] Verify tests pass in sequence
- [ ] Run tests multiple times
  - [ ] Execute 10+ runs to verify no flakiness
  - [ ] Use `pytest-repeat` for automated repetition
- [ ] Test in CI environment
  - [ ] Verify fixes work in GitHub Actions
  - [ ] Check different Python versions

## Implementation Details

### Current pytest-asyncio Configuration
```python
# pytest.ini or pyproject.toml
[tool.pytest.ini_options]
asyncio_mode = "auto"
```

### Proposed Event Loop Fixture
```python
# tests/conftest.py
import pytest
import asyncio

@pytest.fixture(scope="class")
def event_loop():
    """Create event loop with class scope for WebSocket tests."""
    loop = asyncio.new_event_loop()
    yield loop
    # Clean up pending tasks
    pending = asyncio.all_tasks(loop)
    for task in pending:
        task.cancel()
    loop.run_until_complete(asyncio.gather(*pending, return_exceptions=True))
    loop.close()
```

### ConnectionManager Reset Fixture
```python
# tests/api/test_websocket.py
@pytest.fixture(autouse=True)
async def reset_connection_manager():
    """Reset ConnectionManager state before each test."""
    from app.core.websocket import connection_manager

    # Store original state
    original_connections = connection_manager._connections.copy()
    original_queues = connection_manager._message_queues.copy()
    original_subs = connection_manager._subscriptions.copy()

    # Clear state
    connection_manager._connections.clear()
    connection_manager._message_queues.clear()
    connection_manager._subscriptions.clear()

    yield

    # Restore or verify cleanup
    connection_manager._connections.clear()
    connection_manager._message_queues.clear()
    connection_manager._subscriptions.clear()
```

### Subscription Test Fix Example
```python
@pytest.mark.asyncio
async def test_subscribe_exceeds_total_limit(client):
    """Test subscription limit with proper synchronization."""
    async with client.websocket_connect("/ws") as websocket:
        # Wait for connection acknowledgment
        ack = await asyncio.wait_for(websocket.receive_json(), timeout=5.0)
        assert ack["type"] == "connected"

        # Subscribe with explicit wait for confirmation
        await websocket.send_json({"type": "subscribe", "targets": [....]})

        # Wait for subscription response (not just any message)
        response = await asyncio.wait_for(websocket.receive_json(), timeout=5.0)
        while response.get("type") == "pong":
            response = await asyncio.wait_for(websocket.receive_json(), timeout=5.0)

        assert response["type"] == "subscribed"
```

## Acceptance Criteria

- [ ] All 4 WebSocket tests pass consistently in CI
- [ ] Tests pass 10+ consecutive runs without failure
- [ ] No changes to test assertions (only fixture/setup changes)
- [ ] Event loop warnings/errors are eliminated
- [ ] Test execution time not significantly increased
- [ ] Fix doesn't break other async tests

## Testing Strategy

### Unit Tests
- [ ] Verify event loop fixture lifecycle
- [ ] Verify ConnectionManager state reset
- [ ] Verify async timing helpers work correctly

### Integration Tests
- [ ] Run full WebSocket test suite locally (10+ times)
- [ ] Run in Docker environment (mimics CI)
- [ ] Run in GitHub Actions

### Regression Tests
- [ ] Ensure other async tests still pass
- [ ] Verify no performance degradation
- [ ] Check test isolation with parallel execution

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Fix breaks other tests | Medium | High | Run full test suite before merge |
| Fix doesn't work in CI | Medium | Medium | Test in Docker first |
| Event loop changes affect app code | Low | High | Only change test fixtures |
| Race conditions still occur | Medium | Low | Run multiple iterations |

## Performance Requirements

- Test execution time should not increase by more than 10%
- Individual WebSocket test should complete within 30 seconds
- Full test suite should still complete within 5 minutes

## Security Considerations

- No security implications (test-only changes)
- Ensure test fixtures don't expose sensitive data

## Error Handling

```python
# Proper async error handling pattern
async def safe_websocket_receive(websocket, timeout=5.0):
    """Receive with timeout and proper error handling."""
    try:
        return await asyncio.wait_for(websocket.receive_json(), timeout=timeout)
    except asyncio.TimeoutError:
        pytest.fail(f"WebSocket receive timed out after {timeout}s")
    except Exception as e:
        pytest.fail(f"WebSocket receive failed: {e}")
```

## Dependencies

- **External**:
  - `pytest-asyncio` >= 0.21.0
  - `pytest-repeat` (optional, for flakiness verification)

## References

- [pytest-asyncio documentation](https://pytest-asyncio.readthedocs.io/)
- [Python asyncio event loop](https://docs.python.org/3/library/asyncio-eventloop.html)
- [Fixing Flaky Tests](https://docs.pytest.org/en/latest/writing_plugins.html#dealing-with-flaky-tests)
- GitHub Actions CI logs from PR #198

## Progress

- **0%** - Not started

## Notes

- These tests were discovered failing during PR #198 fixes
- Tests pass locally but fail in CI - indicates environment-specific timing
- ConnectionManager is a singleton, which complicates test isolation
- Consider using `pytest-xdist` with `--dist=loadscope` for class-based isolation
- May need to review pytest-asyncio version compatibility (0.21.1 in requirements)
- Alternative: Mark tests as `@pytest.mark.skip` until fixed (not recommended)
