# SOC-001: Strategy Publishing System

## Metadata

| Field | Value |
|-------|-------|
| **ID** | SOC-001 |
| **Title** | Implement Strategy Publishing Feature |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P1 (High) |
| **Estimate** | 16 hours |
| **Sprint** | Sprint 7 |
| **Epic** | Social & Community Features |
| **Assignee** | TBD |
| **Created** | 2025-11-29 |
| **Tags** | social, strategy-sharing, community, content-moderation |
| **Blocks** | SOC-002, SOC-004, SOC-005 |

## Description

Feature allowing users to share their screening strategies with the community. Users can publish their custom stock screening strategies, making them discoverable by other users who can view, copy, and track performance. This feature includes privacy controls, strategy metadata management, performance tracking, and community engagement features like copying and searching strategies.

The system should support both public and private strategies, with proper content moderation to ensure quality and prevent spam or malicious content.

## Acceptance Criteria

- [ ] Strategy public/private settings with privacy controls
- [ ] Strategy description and tags with content validation
- [ ] Automatic strategy performance tracking (daily updates)
- [ ] Strategy copy feature with attribution tracking
- [ ] Strategy search and filter by tags, performance, popularity
- [ ] Popular/recent strategy sorting with pagination
- [ ] Content moderation system for inappropriate content
- [ ] Rate limiting for strategy publishing to prevent spam
- [ ] Strategy edit history and versioning

## Subtasks

- [ ] Backend Development
  - [ ] Create database schema for published_strategies and strategy_performance
  - [ ] Implement strategy publishing API endpoints
    - [ ] POST /api/strategies - Create new strategy
    - [ ] PUT /api/strategies/:id - Update existing strategy
    - [ ] DELETE /api/strategies/:id - Delete strategy
    - [ ] GET /api/strategies/:id - Get strategy details
    - [ ] GET /api/strategies - List strategies with filters
  - [ ] Add validation for strategy data (name, description, tags)
  - [ ] Implement privacy settings logic (public/private/unlisted)
  - [ ] Create performance tracking background job
  - [ ] Add content moderation rules and filters
  - [ ] Implement rate limiting (max 5 strategies per user per day)
- [ ] Frontend Development
  - [ ] Create strategy publishing form with rich text editor
  - [ ] Add privacy settings UI toggle
  - [ ] Implement tag input component with autocomplete
  - [ ] Build strategy card component for list view
  - [ ] Create strategy detail page with performance charts
  - [ ] Add search and filter interface
  - [ ] Implement copy strategy button with confirmation dialog
  - [ ] Build user's published strategies management page
- [ ] Performance Tracking
  - [ ] Design performance calculation algorithm
  - [ ] Create daily batch job for performance updates
  - [ ] Implement caching for performance metrics
  - [ ] Add performance comparison visualization
- [ ] Testing
  - [ ] Write unit tests for strategy CRUD operations
  - [ ] Add integration tests for privacy settings
  - [ ] Create E2E tests for publishing workflow
  - [ ] Test performance tracking accuracy
  - [ ] Validate content moderation rules

## Implementation Details

### Strategy Publishing Service (TypeScript)

```typescript
// services/StrategyPublishingService.ts
import { Strategy, StrategyVisibility } from '../types/strategy';
import { ContentModerator } from './ContentModerator';
import { RateLimiter } from '../utils/RateLimiter';

export class StrategyPublishingService {
  private contentModerator: ContentModerator;
  private rateLimiter: RateLimiter;

  constructor() {
    this.contentModerator = new ContentModerator();
    this.rateLimiter = new RateLimiter({
      maxStrategies: 5,
      windowMs: 24 * 60 * 60 * 1000 // 24 hours
    });
  }

  async publishStrategy(
    userId: string,
    strategyData: Partial<Strategy>
  ): Promise<Strategy> {
    // Check rate limit
    if (!await this.rateLimiter.checkLimit(userId)) {
      throw new Error('Daily strategy publishing limit exceeded');
    }

    // Validate content
    const moderationResult = await this.contentModerator.check({
      name: strategyData.name,
      description: strategyData.description
    });

    if (!moderationResult.approved) {
      throw new Error(`Content moderation failed: ${moderationResult.reason}`);
    }

    // Sanitize tags
    const sanitizedTags = this.sanitizeTags(strategyData.tags || []);

    // Create strategy
    const strategy = await db.publishedStrategies.create({
      data: {
        userId,
        name: strategyData.name,
        description: strategyData.description,
        filters: strategyData.filters,
        isPublic: strategyData.isPublic ?? true,
        tags: sanitizedTags,
        copyCount: 0,
        createdAt: new Date(),
        updatedAt: new Date()
      }
    });

    // Track initial performance
    await this.initializePerformanceTracking(strategy.id);

    return strategy;
  }

  async updateStrategy(
    strategyId: string,
    userId: string,
    updates: Partial<Strategy>
  ): Promise<Strategy> {
    // Verify ownership
    const strategy = await this.getStrategy(strategyId);
    if (strategy.userId !== userId) {
      throw new Error('Unauthorized: Cannot update another user\'s strategy');
    }

    // Content moderation for updates
    if (updates.description || updates.name) {
      const moderationResult = await this.contentModerator.check({
        name: updates.name,
        description: updates.description
      });

      if (!moderationResult.approved) {
        throw new Error(`Content moderation failed: ${moderationResult.reason}`);
      }
    }

    // Update with version tracking
    return await db.publishedStrategies.update({
      where: { id: strategyId },
      data: {
        ...updates,
        updatedAt: new Date(),
        version: { increment: 1 }
      }
    });
  }

  async searchStrategies(params: {
    query?: string;
    tags?: string[];
    sortBy?: 'popular' | 'recent' | 'performance';
    page?: number;
    limit?: number;
  }): Promise<{ strategies: Strategy[]; total: number }> {
    const { query, tags, sortBy = 'recent', page = 1, limit = 20 } = params;

    const where: any = { isPublic: true };

    if (query) {
      where.OR = [
        { name: { contains: query, mode: 'insensitive' } },
        { description: { contains: query, mode: 'insensitive' } }
      ];
    }

    if (tags && tags.length > 0) {
      where.tags = { hasSome: tags };
    }

    const orderBy = this.getOrderByClause(sortBy);

    const [strategies, total] = await Promise.all([
      db.publishedStrategies.findMany({
        where,
        orderBy,
        skip: (page - 1) * limit,
        take: limit,
        include: {
          user: {
            select: { id: true, username: true, avatarUrl: true }
          },
          _count: {
            select: { copies: true }
          }
        }
      }),
      db.publishedStrategies.count({ where })
    ]);

    return { strategies, total };
  }

  private sanitizeTags(tags: string[]): string[] {
    return tags
      .map(tag => tag.trim().toLowerCase())
      .filter(tag => tag.length > 0 && tag.length <= 30)
      .filter(tag => /^[a-z0-9-]+$/.test(tag))
      .slice(0, 10); // Max 10 tags
  }

  private getOrderByClause(sortBy: string) {
    switch (sortBy) {
      case 'popular':
        return { copyCount: 'desc' };
      case 'performance':
        return { performance: { cumulativeReturn: 'desc' } };
      case 'recent':
      default:
        return { createdAt: 'desc' };
    }
  }

  private async initializePerformanceTracking(strategyId: string): Promise<void> {
    await db.strategyPerformance.create({
      data: {
        strategyId,
        date: new Date(),
        cumulativeReturn: 0,
        dailyReturn: 0
      }
    });
  }
}
```

### Content Moderator (TypeScript)

```typescript
// services/ContentModerator.ts
export interface ModerationResult {
  approved: boolean;
  reason?: string;
  flaggedWords?: string[];
}

export class ContentModerator {
  private blockedWords: Set<string>;
  private spamPatterns: RegExp[];

  constructor() {
    this.blockedWords = new Set([
      // Add prohibited words
      'spam', 'scam', 'guarantee', 'risk-free'
    ]);

    this.spamPatterns = [
      /(\w)\1{5,}/, // Repeated characters
      /(https?:\/\/[^\s]+){3,}/, // Multiple URLs
      /[A-Z]{10,}/ // Excessive caps
    ];
  }

  async check(content: { name?: string; description?: string }): Promise<ModerationResult> {
    const text = `${content.name || ''} ${content.description || ''}`.toLowerCase();

    // Check for blocked words
    const flaggedWords: string[] = [];
    for (const word of this.blockedWords) {
      if (text.includes(word)) {
        flaggedWords.push(word);
      }
    }

    if (flaggedWords.length > 0) {
      return {
        approved: false,
        reason: 'Content contains prohibited words',
        flaggedWords
      };
    }

    // Check for spam patterns
    for (const pattern of this.spamPatterns) {
      if (pattern.test(text)) {
        return {
          approved: false,
          reason: 'Content matches spam pattern'
        };
      }
    }

    // Check length constraints
    if (content.name && content.name.length > 100) {
      return {
        approved: false,
        reason: 'Strategy name too long (max 100 characters)'
      };
    }

    if (content.description && content.description.length > 5000) {
      return {
        approved: false,
        reason: 'Description too long (max 5000 characters)'
      };
    }

    return { approved: true };
  }
}
```

### Performance Tracking Job (Python)

```python
# jobs/strategy_performance_tracker.py
from datetime import datetime, timedelta
from typing import List, Dict
import asyncio
from decimal import Decimal

class StrategyPerformanceTracker:
    """Daily job to update performance metrics for published strategies."""

    def __init__(self, db_connection, market_data_service):
        self.db = db_connection
        self.market_data = market_data_service

    async def update_all_strategies(self) -> Dict[str, int]:
        """Update performance for all active published strategies."""
        strategies = await self.get_active_strategies()

        results = {
            'updated': 0,
            'failed': 0,
            'skipped': 0
        }

        for strategy in strategies:
            try:
                await self.update_strategy_performance(strategy)
                results['updated'] += 1
            except Exception as e:
                print(f"Failed to update strategy {strategy['id']}: {e}")
                results['failed'] += 1

        return results

    async def update_strategy_performance(self, strategy: Dict) -> None:
        """Calculate and update performance metrics for a single strategy."""
        # Apply strategy filters to get current stock list
        stocks = await self.apply_strategy_filters(strategy['filters'])

        # Get historical prices
        yesterday = datetime.now() - timedelta(days=1)
        prices = await self.market_data.get_prices(
            symbols=[s['symbol'] for s in stocks],
            date=yesterday
        )

        # Calculate returns
        daily_return = self.calculate_daily_return(stocks, prices)

        # Get previous cumulative return
        previous_performance = await self.db.strategy_performance.find_one({
            'strategy_id': strategy['id'],
            'date': {'$lt': yesterday}
        }, sort=[('date', -1)])

        previous_cumulative = Decimal(previous_performance['cumulative_return']) \
            if previous_performance else Decimal('0')

        # Calculate new cumulative return
        cumulative_return = previous_cumulative + daily_return

        # Store performance record
        await self.db.strategy_performance.insert_one({
            'strategy_id': strategy['id'],
            'date': yesterday,
            'daily_return': float(daily_return),
            'cumulative_return': float(cumulative_return),
            'stock_count': len(stocks),
            'created_at': datetime.now()
        })

        # Update strategy's latest performance
        await self.db.published_strategies.update_one(
            {'id': strategy['id']},
            {
                '$set': {
                    'latest_return': float(cumulative_return),
                    'performance_updated_at': datetime.now()
                }
            }
        )

    async def get_active_strategies(self) -> List[Dict]:
        """Get all published strategies that need performance tracking."""
        return await self.db.published_strategies.find({
            'is_public': True,
            'deleted_at': None
        }).to_list(None)

    async def apply_strategy_filters(self, filters: Dict) -> List[Dict]:
        """Apply strategy filters to get matching stocks."""
        # Implementation depends on filter structure
        # This is a placeholder
        query = self.build_filter_query(filters)
        return await self.db.stocks.find(query).to_list(None)

    def calculate_daily_return(self, stocks: List[Dict], prices: Dict) -> Decimal:
        """Calculate equal-weighted daily return for stock list."""
        if not stocks:
            return Decimal('0')

        total_return = Decimal('0')
        valid_stocks = 0

        for stock in stocks:
            symbol = stock['symbol']
            if symbol in prices:
                price_data = prices[symbol]
                daily_change = (price_data['close'] - price_data['open']) / price_data['open']
                total_return += Decimal(str(daily_change))
                valid_stocks += 1

        if valid_stocks == 0:
            return Decimal('0')

        return total_return / Decimal(str(valid_stocks))

    def build_filter_query(self, filters: Dict) -> Dict:
        """Convert strategy filters to database query."""
        query = {}

        if 'market_cap' in filters:
            mc = filters['market_cap']
            if 'min' in mc:
                query.setdefault('market_cap', {})['$gte'] = mc['min']
            if 'max' in mc:
                query.setdefault('market_cap', {})['$lte'] = mc['max']

        if 'pe_ratio' in filters:
            pe = filters['pe_ratio']
            if 'min' in pe:
                query.setdefault('pe_ratio', {})['$gte'] = pe['min']
            if 'max' in pe:
                query.setdefault('pe_ratio', {})['$lte'] = pe['max']

        # Add more filter conditions as needed

        return query
```

## Testing Strategy

### Unit Tests

```typescript
// tests/unit/StrategyPublishingService.test.ts
describe('StrategyPublishingService', () => {
  let service: StrategyPublishingService;
  let mockDb: jest.Mocked<Database>;

  beforeEach(() => {
    mockDb = createMockDatabase();
    service = new StrategyPublishingService(mockDb);
  });

  describe('publishStrategy', () => {
    it('should create a new strategy with valid data', async () => {
      const userId = 'user-123';
      const strategyData = {
        name: 'Growth Stock Strategy',
        description: 'Focuses on high-growth tech stocks',
        filters: { marketCap: { min: 1000000000 } },
        isPublic: true,
        tags: ['growth', 'tech']
      };

      const result = await service.publishStrategy(userId, strategyData);

      expect(result).toHaveProperty('id');
      expect(result.name).toBe(strategyData.name);
      expect(result.userId).toBe(userId);
      expect(mockDb.publishedStrategies.create).toHaveBeenCalled();
    });

    it('should reject strategy with blocked words', async () => {
      const strategyData = {
        name: 'Guaranteed Returns Strategy',
        description: 'Risk-free profits guaranteed!',
        filters: {}
      };

      await expect(
        service.publishStrategy('user-123', strategyData)
      ).rejects.toThrow('Content moderation failed');
    });

    it('should enforce rate limiting', async () => {
      const userId = 'user-123';
      const strategyData = { name: 'Test', description: 'Test', filters: {} };

      // Publish 5 strategies (limit)
      for (let i = 0; i < 5; i++) {
        await service.publishStrategy(userId, { ...strategyData, name: `Test ${i}` });
      }

      // 6th should fail
      await expect(
        service.publishStrategy(userId, strategyData)
      ).rejects.toThrow('Daily strategy publishing limit exceeded');
    });

    it('should sanitize tags correctly', async () => {
      const strategyData = {
        name: 'Test Strategy',
        description: 'Test',
        filters: {},
        tags: ['  Growth  ', 'TECH', 'invalid tag!', 'a'.repeat(50)]
      };

      const result = await service.publishStrategy('user-123', strategyData);

      expect(result.tags).toEqual(['growth', 'tech']);
    });
  });

  describe('searchStrategies', () => {
    it('should search by query text', async () => {
      const results = await service.searchStrategies({ query: 'growth' });

      expect(mockDb.publishedStrategies.findMany).toHaveBeenCalledWith(
        expect.objectContaining({
          where: expect.objectContaining({
            OR: expect.arrayContaining([
              { name: { contains: 'growth', mode: 'insensitive' } }
            ])
          })
        })
      );
    });

    it('should filter by tags', async () => {
      await service.searchStrategies({ tags: ['tech', 'growth'] });

      expect(mockDb.publishedStrategies.findMany).toHaveBeenCalledWith(
        expect.objectContaining({
          where: expect.objectContaining({
            tags: { hasSome: ['tech', 'growth'] }
          })
        })
      );
    });
  });
});
```

### Integration Tests

```typescript
// tests/integration/strategy-publishing.test.ts
describe('Strategy Publishing Integration', () => {
  let app: Express;
  let testUser: User;

  beforeAll(async () => {
    app = await createTestApp();
    testUser = await createTestUser();
  });

  it('should complete full strategy publishing workflow', async () => {
    // Publish strategy
    const publishResponse = await request(app)
      .post('/api/strategies')
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({
        name: 'Value Dividend Strategy',
        description: 'Focus on undervalued dividend-paying stocks',
        filters: {
          peRatio: { max: 15 },
          dividendYield: { min: 3 }
        },
        isPublic: true,
        tags: ['value', 'dividend']
      });

    expect(publishResponse.status).toBe(201);
    const strategyId = publishResponse.body.id;

    // Verify strategy appears in search
    const searchResponse = await request(app)
      .get('/api/strategies')
      .query({ tags: 'dividend' });

    expect(searchResponse.status).toBe(200);
    expect(searchResponse.body.strategies).toContainEqual(
      expect.objectContaining({ id: strategyId })
    );

    // Update strategy
    const updateResponse = await request(app)
      .put(`/api/strategies/${strategyId}`)
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({ description: 'Updated description' });

    expect(updateResponse.status).toBe(200);
    expect(updateResponse.body.description).toBe('Updated description');

    // Delete strategy
    const deleteResponse = await request(app)
      .delete(`/api/strategies/${strategyId}`)
      .set('Authorization', `Bearer ${testUser.token}`);

    expect(deleteResponse.status).toBe(204);
  });
});
```

### E2E Tests

```typescript
// tests/e2e/strategy-publishing.spec.ts
describe('Strategy Publishing E2E', () => {
  it('should allow user to publish and share strategy', async () => {
    await page.goto('/strategies/new');

    // Fill in strategy form
    await page.fill('[name="name"]', 'E2E Test Strategy');
    await page.fill('[name="description"]', 'This is a test strategy');

    // Add tags
    await page.click('[data-testid="tag-input"]');
    await page.type('[data-testid="tag-input"]', 'test');
    await page.press('[data-testid="tag-input"]', 'Enter');

    // Set privacy
    await page.check('[name="isPublic"]');

    // Configure filters
    await page.fill('[name="marketCap.min"]', '1000000000');

    // Submit
    await page.click('[data-testid="publish-button"]');

    // Verify success
    await page.waitForSelector('[data-testid="success-message"]');
    expect(await page.textContent('[data-testid="success-message"]'))
      .toContain('Strategy published successfully');

    // Verify appears in user's strategies
    await page.goto('/profile/strategies');
    expect(await page.textContent('body')).toContain('E2E Test Strategy');
  });
});
```

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Spam strategies flooding the platform | Medium | High | Implement rate limiting (5/day), content moderation, user reputation system |
| Inappropriate or misleading strategy names/descriptions | Medium | Medium | Automated content filtering, user reporting system, manual review queue |
| Performance tracking calculation errors | Low | High | Comprehensive unit tests, validate against known results, monitoring alerts |
| Privacy leaks exposing private strategies | Low | Critical | Strict access control checks, audit logging, security testing |
| Database performance degradation with many strategies | Medium | Medium | Implement pagination, caching, database indexing on search fields |
| Users gaming the system with fake performance | Medium | High | Verify performance calculations server-side, audit trails, anomaly detection |
| Strategy filters causing expensive queries | Medium | Medium | Query optimization, timeout limits, query complexity analysis |
| Content moderation false positives | High | Low | Allow appeal process, human review option, adjustable sensitivity |

## Performance Requirements

- **Strategy Search Response Time**: < 200ms for 90th percentile queries
- **Strategy Publishing**: < 500ms end-to-end
- **Performance Tracking Job**: Complete all strategies within 2 hours daily window
- **Database Queries**:
  - Strategy list with filters: < 100ms
  - Strategy detail fetch: < 50ms
- **Concurrent Users**: Support 100 simultaneous strategy publishes
- **Storage**: Efficiently handle 100,000+ published strategies
- **Cache Hit Rate**: > 80% for popular strategies list
- **API Rate Limits**:
  - Strategy publish: 5 per user per day
  - Strategy search: 100 requests per user per minute
  - Strategy view: 1000 requests per user per minute

## Security Considerations

### User Data Privacy

- **Private Strategies**: Enforce strict access control - only owner can view
- **User Profile Data**: Only expose necessary user information (username, avatar)
- **Activity Tracking**: Log strategy views and copies for analytics, but anonymize data
- **Data Retention**: Allow users to permanently delete strategies and associated data

### Content Moderation

```typescript
// Content moderation rules
const MODERATION_RULES = {
  // Blocked words and phrases
  blockedTerms: [
    'guaranteed returns',
    'risk-free',
    'get rich quick',
    'insider information'
  ],

  // Maximum lengths
  maxNameLength: 100,
  maxDescriptionLength: 5000,
  maxTagLength: 30,
  maxTags: 10,

  // Rate limits
  maxStrategiesPerDay: 5,
  maxStrategiesPerUser: 50,

  // Spam detection
  minTimeBetweenPublishes: 60, // seconds
  maxSimilarStrategies: 3 // per user
};
```

### Input Validation

- Sanitize all user inputs to prevent XSS attacks
- Validate filter configurations to prevent SQL injection
- Limit filter complexity to prevent DoS via expensive queries
- Validate tag formats (alphanumeric and hyphens only)

### Access Control

```typescript
// Authorization middleware
async function authorizeStrategyAccess(
  userId: string,
  strategyId: string,
  action: 'view' | 'edit' | 'delete'
): Promise<boolean> {
  const strategy = await db.publishedStrategies.findUnique({
    where: { id: strategyId }
  });

  if (!strategy) {
    return false;
  }

  // Owner can do anything
  if (strategy.userId === userId) {
    return true;
  }

  // Others can only view public strategies
  if (action === 'view' && strategy.isPublic) {
    return true;
  }

  return false;
}
```

## Error Handling

```typescript
// API error handling for strategy publishing
app.post('/api/strategies', async (req, res) => {
  try {
    const userId = req.user.id;
    const strategyData = req.body;

    // Validate input
    const validation = validateStrategyData(strategyData);
    if (!validation.valid) {
      return res.status(400).json({
        error: 'VALIDATION_ERROR',
        message: 'Invalid strategy data',
        details: validation.errors
      });
    }

    // Publish strategy
    const strategy = await strategyService.publishStrategy(userId, strategyData);

    res.status(201).json(strategy);

  } catch (error) {
    if (error.message.includes('rate limit')) {
      return res.status(429).json({
        error: 'RATE_LIMIT_EXCEEDED',
        message: 'Daily strategy publishing limit exceeded',
        retryAfter: error.retryAfter
      });
    }

    if (error.message.includes('moderation')) {
      return res.status(400).json({
        error: 'CONTENT_MODERATION_FAILED',
        message: error.message,
        flaggedWords: error.flaggedWords
      });
    }

    if (error.name === 'DatabaseError') {
      console.error('Database error publishing strategy:', error);
      return res.status(503).json({
        error: 'SERVICE_UNAVAILABLE',
        message: 'Unable to publish strategy at this time'
      });
    }

    // Unknown error
    console.error('Unexpected error publishing strategy:', error);
    res.status(500).json({
      error: 'INTERNAL_ERROR',
      message: 'An unexpected error occurred'
    });
  }
});

// Frontend error handling
async function publishStrategy(strategyData: StrategyFormData): Promise<void> {
  try {
    const response = await fetch('/api/strategies', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(strategyData)
    });

    if (!response.ok) {
      const error = await response.json();

      switch (error.error) {
        case 'RATE_LIMIT_EXCEEDED':
          showNotification('You have reached your daily limit for publishing strategies', 'warning');
          break;
        case 'CONTENT_MODERATION_FAILED':
          showNotification(`Content issue: ${error.message}`, 'error');
          highlightFlaggedContent(error.flaggedWords);
          break;
        case 'VALIDATION_ERROR':
          displayValidationErrors(error.details);
          break;
        default:
          showNotification('Failed to publish strategy. Please try again.', 'error');
      }

      return;
    }

    const strategy = await response.json();
    showNotification('Strategy published successfully!', 'success');
    navigateTo(`/strategies/${strategy.id}`);

  } catch (error) {
    console.error('Network error publishing strategy:', error);
    showNotification('Network error. Please check your connection.', 'error');
  }
}
```

## Database Schema

```sql
CREATE TABLE published_strategies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    strategy_name VARCHAR(100) NOT NULL,
    description TEXT,
    filters JSONB NOT NULL,
    is_public BOOLEAN DEFAULT true,
    tags VARCHAR(30)[] DEFAULT '{}',
    copy_count INTEGER DEFAULT 0,
    view_count INTEGER DEFAULT 0,
    version INTEGER DEFAULT 1,
    latest_return DECIMAL(10, 4),
    performance_updated_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP,

    CONSTRAINT valid_name_length CHECK (char_length(strategy_name) > 0),
    CONSTRAINT valid_description_length CHECK (char_length(description) <= 5000),
    CONSTRAINT valid_tags CHECK (array_length(tags, 1) <= 10)
);

CREATE TABLE strategy_performance (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    strategy_id UUID REFERENCES published_strategies(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    cumulative_return DECIMAL(10, 4) NOT NULL,
    daily_return DECIMAL(10, 4) NOT NULL,
    stock_count INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(strategy_id, date)
);

CREATE TABLE strategy_copies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    original_strategy_id UUID REFERENCES published_strategies(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    copied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(original_strategy_id, user_id)
);

-- Indexes for performance
CREATE INDEX idx_strategies_public ON published_strategies(is_public) WHERE deleted_at IS NULL;
CREATE INDEX idx_strategies_user ON published_strategies(user_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_strategies_tags ON published_strategies USING GIN(tags);
CREATE INDEX idx_strategies_copy_count ON published_strategies(copy_count DESC);
CREATE INDEX idx_strategies_created ON published_strategies(created_at DESC);
CREATE INDEX idx_performance_strategy ON strategy_performance(strategy_id, date DESC);
CREATE INDEX idx_performance_date ON strategy_performance(date);

-- Full text search
CREATE INDEX idx_strategies_search ON published_strategies USING GIN(
    to_tsvector('english', strategy_name || ' ' || COALESCE(description, ''))
);
```

## Dependencies

- User authentication system (AUTH-001)
- Portfolio management module (PRT-001)
- Market data service for performance tracking
- Database (PostgreSQL with JSONB support)
- Redis for caching and rate limiting
- Background job processor (for performance tracking)

## References

- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 4: Social & Community Features
- [API Documentation](../../api/strategies.md) - Strategy API endpoints
- [Content Moderation Guidelines](../../security/content-moderation.md)
- [Performance Tracking Algorithm](../../algorithms/strategy-performance.md)

## Notes

### Implementation Tips

1. **Start with MVP features**: Focus on basic publish/search first, then add advanced filtering
2. **Performance optimization**: Use database indexes heavily - this will be a read-heavy feature
3. **Caching strategy**: Cache popular strategies list, trending tags, and leaderboard data
4. **Content moderation**: Start with simple rule-based filtering, plan for ML-based moderation later
5. **Rate limiting**: Use Redis for distributed rate limiting across multiple servers
6. **Privacy by default**: Make strategies private by default, require explicit action to publish publicly

### Future Enhancements

- AI-powered strategy recommendations based on user preferences
- Strategy templates and wizards for beginners
- Community voting and quality scores
- Strategy backtesting visualization
- Social sharing to external platforms (Twitter, LinkedIn)
- Strategy competitions and challenges
- Premium analytics for strategy creators
- API access for third-party integrations

### Technical Debt

- Consider migrating performance tracking to time-series database (InfluxDB/TimescaleDB) if scale requires
- Evaluate need for full-text search engine (Elasticsearch) for complex strategy searches
- Plan for CDN integration for strategy images/charts in future iterations

## Progress

**0% - Not started**
