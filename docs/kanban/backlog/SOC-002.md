# SOC-002: User Follow System

## Metadata

| Field | Value |
|-------|-------|
| **ID** | SOC-002 |
| **Title** | Implement User Follow Feature |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P2 (Medium) |
| **Estimate** | 12 hours |
| **Sprint** | Sprint 7 |
| **Epic** | Social & Community Features |
| **Assignee** | TBD |
| **Depends On** | SOC-001 |
| **Created** | 2025-11-29 |
| **Tags** | social, follow-system, notifications, user-relationships |
| **Blocks** | SOC-003, SOC-005 |

## Description

Implement a user follow system that enables users to follow other traders, track their activities, and receive notifications about their published strategies and updates. This feature creates a social graph within the platform, allowing users to build their network of trusted traders and stay informed about the strategies and insights from people they follow.

The system should include privacy controls, notification preferences, and an activity feed that aggregates content from followed users. This feature is essential for building community engagement and enabling users to discover valuable strategies from successful traders.

## Acceptance Criteria

- [ ] Follow/unfollow functionality with optimistic UI updates
- [ ] Follower/following list with pagination and search
- [ ] Activity feed from followed users with real-time updates
- [ ] Follow notifications (in-app and email options)
- [ ] User profile page with follower/following counts
- [ ] Privacy settings to hide follower lists
- [ ] Notification preferences management
- [ ] Mutual follow detection and badge display
- [ ] Block user functionality to prevent following
- [ ] Rate limiting to prevent follow spam

## Subtasks

- [ ] Backend Development
  - [ ] Create database schema for user_follows table
  - [ ] Implement follow/unfollow API endpoints
    - [ ] POST /api/users/:id/follow - Follow a user
    - [ ] DELETE /api/users/:id/follow - Unfollow a user
    - [ ] GET /api/users/:id/followers - Get user's followers
    - [ ] GET /api/users/:id/following - Get users being followed
    - [ ] GET /api/users/:id/activity - Get activity feed
  - [ ] Add validation to prevent self-following
  - [ ] Implement privacy settings for follower visibility
  - [ ] Create notification service for follow events
  - [ ] Build activity aggregation service
  - [ ] Add rate limiting for follow actions
  - [ ] Implement mutual follow detection
- [ ] Frontend Development
  - [ ] Create follow/unfollow button component with loading states
  - [ ] Build followers/following list modal with infinite scroll
  - [ ] Implement user profile page with statistics
  - [ ] Create activity feed component
  - [ ] Add notification preferences UI
  - [ ] Build user search and discovery interface
  - [ ] Implement suggested users feature
  - [ ] Add mutual follow indicator badges
- [ ] Notification System
  - [ ] Design notification templates for follow events
  - [ ] Implement in-app notification delivery
  - [ ] Create email notification system (optional)
  - [ ] Add notification preferences storage
  - [ ] Build notification batching for multiple follows
- [ ] Testing
  - [ ] Write unit tests for follow/unfollow logic
  - [ ] Add integration tests for notification delivery
  - [ ] Create E2E tests for follow workflow
  - [ ] Test privacy settings enforcement
  - [ ] Validate rate limiting behavior

## Implementation Details

### Follow Service (TypeScript)

```typescript
// services/FollowService.ts
import { NotificationService } from './NotificationService';
import { ActivityService } from './ActivityService';
import { RateLimiter } from '../utils/RateLimiter';

export interface FollowStats {
  followerCount: number;
  followingCount: number;
  mutualFollowCount: number;
}

export class FollowService {
  private notificationService: NotificationService;
  private activityService: ActivityService;
  private rateLimiter: RateLimiter;

  constructor() {
    this.notificationService = new NotificationService();
    this.activityService = new ActivityService();
    this.rateLimiter = new RateLimiter({
      maxFollows: 100,
      windowMs: 60 * 60 * 1000 // 1 hour
    });
  }

  async followUser(followerId: string, followeeId: string): Promise<void> {
    // Validate
    if (followerId === followeeId) {
      throw new Error('Cannot follow yourself');
    }

    // Check if already following
    const existingFollow = await db.userFollows.findUnique({
      where: {
        followerId_followeeId: {
          followerId,
          followeeId
        }
      }
    });

    if (existingFollow) {
      throw new Error('Already following this user');
    }

    // Check rate limit
    if (!await this.rateLimiter.checkLimit(followerId)) {
      throw new Error('Follow rate limit exceeded');
    }

    // Check if blocked
    const isBlocked = await this.isUserBlocked(followerId, followeeId);
    if (isBlocked) {
      throw new Error('Cannot follow this user');
    }

    // Create follow relationship
    await db.userFollows.create({
      data: {
        followerId,
        followeeId,
        createdAt: new Date()
      }
    });

    // Update follower counts (denormalized for performance)
    await Promise.all([
      db.users.update({
        where: { id: followerId },
        data: { followingCount: { increment: 1 } }
      }),
      db.users.update({
        where: { id: followeeId },
        data: { followerCount: { increment: 1 } }
      })
    ]);

    // Check if mutual follow
    const isMutual = await this.checkMutualFollow(followerId, followeeId);

    // Send notification
    await this.notificationService.sendFollowNotification({
      recipientId: followeeId,
      followerId,
      isMutual
    });

    // Log activity
    await this.activityService.logActivity({
      userId: followerId,
      type: 'FOLLOW',
      targetUserId: followeeId,
      timestamp: new Date()
    });
  }

  async unfollowUser(followerId: string, followeeId: string): Promise<void> {
    const follow = await db.userFollows.findUnique({
      where: {
        followerId_followeeId: {
          followerId,
          followeeId
        }
      }
    });

    if (!follow) {
      throw new Error('Not following this user');
    }

    // Delete follow relationship
    await db.userFollows.delete({
      where: {
        followerId_followeeId: {
          followerId,
          followeeId
        }
      }
    });

    // Update follower counts
    await Promise.all([
      db.users.update({
        where: { id: followerId },
        data: { followingCount: { decrement: 1 } }
      }),
      db.users.update({
        where: { id: followeeId },
        data: { followerCount: { decrement: 1 } }
      })
    ]);

    // Log activity
    await this.activityService.logActivity({
      userId: followerId,
      type: 'UNFOLLOW',
      targetUserId: followeeId,
      timestamp: new Date()
    });
  }

  async getFollowers(
    userId: string,
    options: {
      page?: number;
      limit?: number;
      search?: string;
    } = {}
  ): Promise<{ users: User[]; total: number; hasMore: boolean }> {
    const { page = 1, limit = 20, search } = options;

    // Check privacy settings
    const user = await db.users.findUnique({
      where: { id: userId },
      select: { privacySettings: true }
    });

    if (user?.privacySettings?.hideFollowers) {
      // Only the user themselves can see their followers
      const requesterId = this.getCurrentUserId();
      if (requesterId !== userId) {
        return { users: [], total: 0, hasMore: false };
      }
    }

    const where: any = {
      followeeId: userId
    };

    if (search) {
      where.follower = {
        OR: [
          { username: { contains: search, mode: 'insensitive' } },
          { displayName: { contains: search, mode: 'insensitive' } }
        ]
      };
    }

    const [follows, total] = await Promise.all([
      db.userFollows.findMany({
        where,
        skip: (page - 1) * limit,
        take: limit,
        include: {
          follower: {
            select: {
              id: true,
              username: true,
              displayName: true,
              avatarUrl: true,
              followerCount: true,
              followingCount: true
            }
          }
        },
        orderBy: { createdAt: 'desc' }
      }),
      db.userFollows.count({ where })
    ]);

    const users = follows.map(f => f.follower);
    const hasMore = total > page * limit;

    return { users, total, hasMore };
  }

  async getFollowing(
    userId: string,
    options: { page?: number; limit?: number; search?: string } = {}
  ): Promise<{ users: User[]; total: number; hasMore: boolean }> {
    const { page = 1, limit = 20, search } = options;

    const where: any = {
      followerId: userId
    };

    if (search) {
      where.followee = {
        OR: [
          { username: { contains: search, mode: 'insensitive' } },
          { displayName: { contains: search, mode: 'insensitive' } }
        ]
      };
    }

    const [follows, total] = await Promise.all([
      db.userFollows.findMany({
        where,
        skip: (page - 1) * limit,
        take: limit,
        include: {
          followee: {
            select: {
              id: true,
              username: true,
              displayName: true,
              avatarUrl: true,
              followerCount: true,
              followingCount: true
            }
          }
        },
        orderBy: { createdAt: 'desc' }
      }),
      db.userFollows.count({ where })
    ]);

    const users = follows.map(f => f.followee);
    const hasMore = total > page * limit;

    return { users, total, hasMore };
  }

  async getFollowStats(userId: string): Promise<FollowStats> {
    const [followerCount, followingCount, mutualFollows] = await Promise.all([
      db.userFollows.count({ where: { followeeId: userId } }),
      db.userFollows.count({ where: { followerId: userId } }),
      this.getMutualFollowCount(userId)
    ]);

    return {
      followerCount,
      followingCount,
      mutualFollowCount: mutualFollows
    };
  }

  async getActivityFeed(
    userId: string,
    options: { page?: number; limit?: number } = {}
  ): Promise<{ activities: Activity[]; hasMore: boolean }> {
    const { page = 1, limit = 20 } = options;

    // Get list of users being followed
    const following = await db.userFollows.findMany({
      where: { followerId: userId },
      select: { followeeId: true }
    });

    const followingIds = following.map(f => f.followeeId);

    // Get activities from followed users
    const activities = await db.activities.findMany({
      where: {
        userId: { in: followingIds },
        type: {
          in: [
            'STRATEGY_PUBLISHED',
            'STRATEGY_UPDATED',
            'COMMENT_ADDED',
            'STRATEGY_COPIED'
          ]
        }
      },
      skip: (page - 1) * limit,
      take: limit + 1, // Fetch one extra to check if there are more
      include: {
        user: {
          select: {
            id: true,
            username: true,
            displayName: true,
            avatarUrl: true
          }
        },
        strategy: {
          select: {
            id: true,
            name: true,
            description: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    const hasMore = activities.length > limit;
    if (hasMore) {
      activities.pop(); // Remove the extra item
    }

    return { activities, hasMore };
  }

  async checkMutualFollow(userId1: string, userId2: string): Promise<boolean> {
    const [follow1, follow2] = await Promise.all([
      db.userFollows.findUnique({
        where: {
          followerId_followeeId: {
            followerId: userId1,
            followeeId: userId2
          }
        }
      }),
      db.userFollows.findUnique({
        where: {
          followerId_followeeId: {
            followerId: userId2,
            followeeId: userId1
          }
        }
      })
    ]);

    return !!(follow1 && follow2);
  }

  async getSuggestedUsers(
    userId: string,
    limit: number = 10
  ): Promise<User[]> {
    // Algorithm: Suggest users who:
    // 1. Are followed by people you follow (mutual connections)
    // 2. Have high follower counts
    // 3. Have published popular strategies
    // 4. Are not already followed by the user

    const following = await db.userFollows.findMany({
      where: { followerId: userId },
      select: { followeeId: true }
    });

    const followingIds = following.map(f => f.followeeId);

    // Find users followed by people you follow
    const suggestions = await db.users.findMany({
      where: {
        AND: [
          { id: { notIn: [...followingIds, userId] } },
          {
            followers: {
              some: {
                followerId: { in: followingIds }
              }
            }
          }
        ]
      },
      take: limit,
      select: {
        id: true,
        username: true,
        displayName: true,
        avatarUrl: true,
        followerCount: true,
        _count: {
          select: {
            publishedStrategies: true
          }
        }
      },
      orderBy: [
        { followerCount: 'desc' },
        { createdAt: 'desc' }
      ]
    });

    return suggestions;
  }

  private async getMutualFollowCount(userId: string): Promise<number> {
    const result = await db.$queryRaw`
      SELECT COUNT(*) as count
      FROM user_follows uf1
      INNER JOIN user_follows uf2
        ON uf1.follower_id = uf2.followee_id
        AND uf1.followee_id = uf2.follower_id
      WHERE uf1.follower_id = ${userId}
    `;

    return parseInt(result[0]?.count || '0');
  }

  private async isUserBlocked(
    userId: string,
    targetUserId: string
  ): Promise<boolean> {
    const block = await db.userBlocks.findUnique({
      where: {
        blockerId_blockedId: {
          blockerId: targetUserId,
          blockedId: userId
        }
      }
    });

    return !!block;
  }

  private getCurrentUserId(): string | null {
    // Implementation depends on authentication context
    // This is a placeholder
    return null;
  }
}
```

### Notification Service (TypeScript)

```typescript
// services/NotificationService.ts
import { EmailService } from './EmailService';

export interface FollowNotification {
  recipientId: string;
  followerId: string;
  isMutual: boolean;
}

export class NotificationService {
  private emailService: EmailService;

  constructor() {
    this.emailService = new EmailService();
  }

  async sendFollowNotification(params: FollowNotification): Promise<void> {
    const { recipientId, followerId, isMutual } = params;

    // Get user notification preferences
    const recipient = await db.users.findUnique({
      where: { id: recipientId },
      select: {
        id: true,
        username: true,
        email: true,
        notificationPreferences: true
      }
    });

    if (!recipient) {
      return;
    }

    // Check if user wants follow notifications
    const prefs = recipient.notificationPreferences || {};
    if (prefs.followNotifications === false) {
      return;
    }

    // Get follower info
    const follower = await db.users.findUnique({
      where: { id: followerId },
      select: {
        id: true,
        username: true,
        displayName: true,
        avatarUrl: true
      }
    });

    if (!follower) {
      return;
    }

    // Create in-app notification
    await db.notifications.create({
      data: {
        userId: recipientId,
        type: isMutual ? 'MUTUAL_FOLLOW' : 'NEW_FOLLOWER',
        title: isMutual
          ? `${follower.displayName} is now following you too!`
          : `${follower.displayName} started following you`,
        message: isMutual
          ? `You and ${follower.displayName} are now following each other`
          : `${follower.displayName} (@${follower.username}) is now following you`,
        actionUrl: `/profile/${follower.username}`,
        metadata: {
          followerId: follower.id,
          isMutual
        },
        read: false,
        createdAt: new Date()
      }
    });

    // Send email notification if enabled
    if (prefs.emailNotifications !== false && recipient.email) {
      await this.emailService.sendFollowEmail({
        to: recipient.email,
        recipientName: recipient.username,
        followerName: follower.displayName || follower.username,
        followerUsername: follower.username,
        followerAvatar: follower.avatarUrl,
        isMutual,
        profileUrl: `${process.env.APP_URL}/profile/${follower.username}`
      });
    }
  }

  async batchFollowNotifications(
    recipientId: string,
    followerIds: string[]
  ): Promise<void> {
    // If user receives multiple follows in a short time, batch them
    if (followerIds.length === 0) {
      return;
    }

    const followers = await db.users.findMany({
      where: { id: { in: followerIds } },
      select: {
        id: true,
        username: true,
        displayName: true,
        avatarUrl: true
      }
    });

    await db.notifications.create({
      data: {
        userId: recipientId,
        type: 'MULTIPLE_FOLLOWERS',
        title: `${followerIds.length} new followers`,
        message: `${followers.map(f => f.displayName).join(', ')} and others started following you`,
        actionUrl: `/profile/followers`,
        metadata: {
          followerIds,
          count: followerIds.length
        },
        read: false,
        createdAt: new Date()
      }
    });
  }
}
```

### Activity Feed Component (React/TypeScript)

```typescript
// components/ActivityFeed.tsx
import React, { useEffect, useState } from 'react';
import { useInfiniteScroll } from '../hooks/useInfiniteScroll';
import { Activity } from '../types/activity';

export const ActivityFeed: React.FC = () => {
  const [activities, setActivities] = useState<Activity[]>([]);
  const [hasMore, setHasMore] = useState(true);
  const [loading, setLoading] = useState(false);

  const loadMoreActivities = async (page: number) => {
    setLoading(true);
    try {
      const response = await fetch(`/api/activity/feed?page=${page}&limit=20`);
      const data = await response.json();

      setActivities(prev => [...prev, ...data.activities]);
      setHasMore(data.hasMore);
    } catch (error) {
      console.error('Failed to load activities:', error);
    } finally {
      setLoading(false);
    }
  };

  const { page, observerRef } = useInfiniteScroll({
    hasMore,
    loading,
    onLoadMore: loadMoreActivities
  });

  const renderActivity = (activity: Activity) => {
    switch (activity.type) {
      case 'STRATEGY_PUBLISHED':
        return (
          <div className="activity-item">
            <img src={activity.user.avatarUrl} alt={activity.user.username} />
            <div>
              <strong>{activity.user.displayName}</strong> published a new strategy
              <a href={`/strategies/${activity.strategy.id}`}>
                {activity.strategy.name}
              </a>
              <span className="time">{formatTime(activity.createdAt)}</span>
            </div>
          </div>
        );

      case 'STRATEGY_UPDATED':
        return (
          <div className="activity-item">
            <img src={activity.user.avatarUrl} alt={activity.user.username} />
            <div>
              <strong>{activity.user.displayName}</strong> updated their strategy
              <a href={`/strategies/${activity.strategy.id}`}>
                {activity.strategy.name}
              </a>
              <span className="time">{formatTime(activity.createdAt)}</span>
            </div>
          </div>
        );

      case 'STRATEGY_COPIED':
        return (
          <div className="activity-item">
            <img src={activity.user.avatarUrl} alt={activity.user.username} />
            <div>
              <strong>{activity.user.displayName}</strong> copied a strategy
              <a href={`/strategies/${activity.strategy.id}`}>
                {activity.strategy.name}
              </a>
              <span className="time">{formatTime(activity.createdAt)}</span>
            </div>
          </div>
        );

      default:
        return null;
    }
  };

  return (
    <div className="activity-feed">
      <h2>Activity Feed</h2>
      {activities.length === 0 && !loading && (
        <div className="empty-state">
          <p>No activities yet. Follow users to see their updates here!</p>
        </div>
      )}

      {activities.map(activity => (
        <React.Fragment key={activity.id}>
          {renderActivity(activity)}
        </React.Fragment>
      ))}

      {loading && <div className="loading">Loading...</div>}

      <div ref={observerRef} style={{ height: '20px' }} />
    </div>
  );
};

function formatTime(date: string): string {
  const now = new Date();
  const activityDate = new Date(date);
  const diffMs = now.getTime() - activityDate.getTime();
  const diffMins = Math.floor(diffMs / 60000);

  if (diffMins < 1) return 'just now';
  if (diffMins < 60) return `${diffMins}m ago`;

  const diffHours = Math.floor(diffMins / 60);
  if (diffHours < 24) return `${diffHours}h ago`;

  const diffDays = Math.floor(diffHours / 24);
  if (diffDays < 7) return `${diffDays}d ago`;

  return activityDate.toLocaleDateString();
}
```

## Testing Strategy

### Unit Tests

```typescript
// tests/unit/FollowService.test.ts
describe('FollowService', () => {
  let service: FollowService;
  let mockDb: jest.Mocked<Database>;

  beforeEach(() => {
    mockDb = createMockDatabase();
    service = new FollowService(mockDb);
  });

  describe('followUser', () => {
    it('should create follow relationship successfully', async () => {
      const followerId = 'user-1';
      const followeeId = 'user-2';

      mockDb.userFollows.findUnique.mockResolvedValue(null);
      mockDb.userFollows.create.mockResolvedValue({
        followerId,
        followeeId,
        createdAt: new Date()
      });

      await service.followUser(followerId, followeeId);

      expect(mockDb.userFollows.create).toHaveBeenCalledWith(
        expect.objectContaining({
          data: expect.objectContaining({
            followerId,
            followeeId
          })
        })
      );
    });

    it('should prevent self-following', async () => {
      const userId = 'user-1';

      await expect(
        service.followUser(userId, userId)
      ).rejects.toThrow('Cannot follow yourself');
    });

    it('should prevent duplicate follows', async () => {
      mockDb.userFollows.findUnique.mockResolvedValue({
        followerId: 'user-1',
        followeeId: 'user-2',
        createdAt: new Date()
      });

      await expect(
        service.followUser('user-1', 'user-2')
      ).rejects.toThrow('Already following this user');
    });

    it('should detect and notify mutual follows', async () => {
      const followerId = 'user-1';
      const followeeId = 'user-2';

      // Mock existing reverse follow
      mockDb.userFollows.findUnique
        .mockResolvedValueOnce(null) // No existing follow
        .mockResolvedValueOnce({ // Reverse follow exists
          followerId: followeeId,
          followeeId: followerId,
          createdAt: new Date()
        });

      const notificationSpy = jest.spyOn(service['notificationService'], 'sendFollowNotification');

      await service.followUser(followerId, followeeId);

      expect(notificationSpy).toHaveBeenCalledWith(
        expect.objectContaining({
          isMutual: true
        })
      );
    });
  });

  describe('getActivityFeed', () => {
    it('should return activities from followed users only', async () => {
      const userId = 'user-1';

      mockDb.userFollows.findMany.mockResolvedValue([
        { followerId: userId, followeeId: 'user-2', createdAt: new Date() },
        { followerId: userId, followeeId: 'user-3', createdAt: new Date() }
      ]);

      mockDb.activities.findMany.mockResolvedValue([
        { id: 'act-1', userId: 'user-2', type: 'STRATEGY_PUBLISHED', createdAt: new Date() },
        { id: 'act-2', userId: 'user-3', type: 'STRATEGY_UPDATED', createdAt: new Date() }
      ]);

      const result = await service.getActivityFeed(userId);

      expect(result.activities).toHaveLength(2);
      expect(mockDb.activities.findMany).toHaveBeenCalledWith(
        expect.objectContaining({
          where: expect.objectContaining({
            userId: { in: ['user-2', 'user-3'] }
          })
        })
      );
    });
  });
});
```

### Integration Tests

```typescript
// tests/integration/follow-system.test.ts
describe('Follow System Integration', () => {
  let app: Express;
  let user1: User;
  let user2: User;

  beforeAll(async () => {
    app = await createTestApp();
    user1 = await createTestUser({ username: 'trader1' });
    user2 = await createTestUser({ username: 'trader2' });
  });

  it('should complete full follow workflow', async () => {
    // User1 follows User2
    const followResponse = await request(app)
      .post(`/api/users/${user2.id}/follow`)
      .set('Authorization', `Bearer ${user1.token}`);

    expect(followResponse.status).toBe(200);

    // Verify follow relationship
    const followingResponse = await request(app)
      .get(`/api/users/${user1.id}/following`)
      .set('Authorization', `Bearer ${user1.token}`);

    expect(followingResponse.status).toBe(200);
    expect(followingResponse.body.users).toContainEqual(
      expect.objectContaining({ id: user2.id })
    );

    // Verify notification sent
    const notificationsResponse = await request(app)
      .get('/api/notifications')
      .set('Authorization', `Bearer ${user2.token}`);

    expect(notificationsResponse.body.notifications).toContainEqual(
      expect.objectContaining({
        type: 'NEW_FOLLOWER',
        metadata: expect.objectContaining({
          followerId: user1.id
        })
      })
    );

    // User1 unfollows User2
    const unfollowResponse = await request(app)
      .delete(`/api/users/${user2.id}/follow`)
      .set('Authorization', `Bearer ${user1.token}`);

    expect(unfollowResponse.status).toBe(200);
  });

  it('should detect mutual follows', async () => {
    // User1 follows User2
    await request(app)
      .post(`/api/users/${user2.id}/follow`)
      .set('Authorization', `Bearer ${user1.token}`);

    // User2 follows User1 back
    const mutualFollowResponse = await request(app)
      .post(`/api/users/${user1.id}/follow`)
      .set('Authorization', `Bearer ${user2.token}`);

    expect(mutualFollowResponse.status).toBe(200);

    // Check User1's notification for mutual follow
    const notificationsResponse = await request(app)
      .get('/api/notifications')
      .set('Authorization', `Bearer ${user1.token}`);

    expect(notificationsResponse.body.notifications).toContainEqual(
      expect.objectContaining({
        type: 'MUTUAL_FOLLOW'
      })
    );
  });
});
```

### E2E Tests

```typescript
// tests/e2e/follow-system.spec.ts
describe('Follow System E2E', () => {
  it('should allow user to follow and view activity feed', async () => {
    // Login as user1
    await page.goto('/login');
    await page.fill('[name="username"]', 'trader1');
    await page.fill('[name="password"]', 'password123');
    await page.click('[type="submit"]');

    // Navigate to user2's profile
    await page.goto('/profile/trader2');

    // Follow user2
    await page.click('[data-testid="follow-button"]');
    await page.waitForSelector('[data-testid="following-button"]');

    expect(await page.textContent('[data-testid="following-button"]'))
      .toBe('Following');

    // Navigate to activity feed
    await page.goto('/feed');

    // Verify feed shows activities from followed user
    await page.waitForSelector('.activity-item');
    const activities = await page.$$('.activity-item');
    expect(activities.length).toBeGreaterThan(0);

    // Unfollow
    await page.goto('/profile/trader2');
    await page.click('[data-testid="following-button"]');
    await page.waitForSelector('[data-testid="follow-button"]');

    expect(await page.textContent('[data-testid="follow-button"]'))
      .toBe('Follow');
  });
});
```

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Follow spam and bot accounts | Medium | Medium | Rate limiting (100/hour), CAPTCHA for suspicious behavior, account verification |
| Privacy concerns with follower lists | Low | Medium | Configurable privacy settings, option to hide follower lists from public |
| Notification fatigue from too many follow alerts | High | Low | Batch notifications, user-configurable notification preferences, digest emails |
| Performance issues with large follower counts | Medium | High | Denormalized counts, pagination, database indexing, caching layer |
| Activity feed scaling with many followed users | Medium | High | Fanout-on-write or fanout-on-read strategy, Redis caching, pagination |
| Mutual follow detection overhead | Low | Low | Efficient database queries with indexes, cache mutual follow status |
| Users gaming follower counts | Medium | Medium | Detect and flag suspicious follow patterns, limit daily follows, account penalties |
| Notification delivery failures | Low | Medium | Retry logic, queue-based notification system, monitoring and alerts |

## Performance Requirements

- **Follow/Unfollow Actions**: < 200ms response time
- **Follower List Loading**: < 300ms for first page (20 users)
- **Activity Feed Loading**: < 500ms for first page
- **Notification Delivery**: < 1 second for in-app notifications
- **Database Queries**:
  - Follow relationship check: < 50ms
  - Follower count fetch: < 10ms (cached)
  - Activity feed aggregation: < 400ms
- **Concurrent Operations**: Support 500 simultaneous follow actions
- **Scalability**: Handle users with 10,000+ followers efficiently
- **Cache Hit Rate**: > 90% for follow status checks
- **API Rate Limits**:
  - Follow/unfollow: 100 actions per user per hour
  - Follower list view: 300 requests per user per minute
  - Activity feed: 60 requests per user per minute

## Security Considerations

### User Privacy

- **Follower Visibility**: Allow users to make follower/following lists private
- **Block Functionality**: Users can block others from following them
- **Activity Privacy**: Respect user privacy settings in activity feed
- **Data Minimization**: Only expose necessary user information in follower lists

### Anti-Spam Measures

```typescript
// Anti-spam configuration
const ANTI_SPAM_CONFIG = {
  maxFollowsPerHour: 100,
  maxFollowsPerDay: 500,
  minTimeBetweenFollows: 1000, // 1 second
  suspiciousPatternThreshold: {
    rapidFollows: 20, // 20 follows in 1 minute
    followUnfollowCycles: 5 // Same user followed/unfollowed 5 times
  }
};

// Detect suspicious behavior
async function detectSuspiciousFollowBehavior(userId: string): Promise<boolean> {
  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);

  const recentFollows = await db.userFollows.count({
    where: {
      followerId: userId,
      createdAt: { gte: oneHourAgo }
    }
  });

  return recentFollows > ANTI_SPAM_CONFIG.suspiciousPatternThreshold.rapidFollows;
}
```

### Data Protection

- Encrypt sensitive user data in transit and at rest
- Implement GDPR-compliant data deletion for follow relationships
- Audit logging for follow/unfollow actions
- Rate limiting to prevent enumeration attacks

## Error Handling

```typescript
// API error handling
app.post('/api/users/:userId/follow', async (req, res) => {
  try {
    const followerId = req.user.id;
    const followeeId = req.params.userId;

    await followService.followUser(followerId, followeeId);

    res.status(200).json({ success: true });

  } catch (error) {
    if (error.message === 'Cannot follow yourself') {
      return res.status(400).json({
        error: 'INVALID_FOLLOW',
        message: 'You cannot follow yourself'
      });
    }

    if (error.message === 'Already following this user') {
      return res.status(409).json({
        error: 'ALREADY_FOLLOWING',
        message: 'You are already following this user'
      });
    }

    if (error.message === 'Follow rate limit exceeded') {
      return res.status(429).json({
        error: 'RATE_LIMIT_EXCEEDED',
        message: 'You have exceeded the follow rate limit. Please try again later.'
      });
    }

    if (error.message === 'Cannot follow this user') {
      return res.status(403).json({
        error: 'FOLLOW_BLOCKED',
        message: 'You are not allowed to follow this user'
      });
    }

    console.error('Error following user:', error);
    res.status(500).json({
      error: 'INTERNAL_ERROR',
      message: 'An error occurred while processing your request'
    });
  }
});

// Frontend error handling
async function handleFollowClick(userId: string): Promise<void> {
  setLoading(true);
  try {
    const response = await fetch(`/api/users/${userId}/follow`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      const error = await response.json();

      switch (error.error) {
        case 'RATE_LIMIT_EXCEEDED':
          showNotification('You are following too many users. Please slow down.', 'warning');
          break;
        case 'ALREADY_FOLLOWING':
          // Update UI state optimistically
          setIsFollowing(true);
          break;
        case 'FOLLOW_BLOCKED':
          showNotification('You cannot follow this user', 'error');
          break;
        default:
          showNotification('Failed to follow user. Please try again.', 'error');
      }

      return;
    }

    setIsFollowing(true);
    showNotification('You are now following this user', 'success');

  } catch (error) {
    console.error('Network error following user:', error);
    showNotification('Network error. Please check your connection.', 'error');
  } finally {
    setLoading(false);
  }
}
```

## Database Schema

```sql
CREATE TABLE user_follows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    follower_id UUID REFERENCES users(id) ON DELETE CASCADE,
    followee_id UUID REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(follower_id, followee_id),
    CONSTRAINT no_self_follow CHECK (follower_id != followee_id)
);

CREATE TABLE user_blocks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    blocker_id UUID REFERENCES users(id) ON DELETE CASCADE,
    blocked_id UUID REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(blocker_id, blocked_id)
);

CREATE TABLE activities (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL,
    target_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    strategy_id UUID REFERENCES published_strategies(id) ON DELETE CASCADE,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL,
    title VARCHAR(200) NOT NULL,
    message TEXT NOT NULL,
    action_url VARCHAR(500),
    metadata JSONB,
    read BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Add columns to users table
ALTER TABLE users ADD COLUMN follower_count INTEGER DEFAULT 0;
ALTER TABLE users ADD COLUMN following_count INTEGER DEFAULT 0;
ALTER TABLE users ADD COLUMN privacy_settings JSONB DEFAULT '{}';
ALTER TABLE users ADD COLUMN notification_preferences JSONB DEFAULT '{}';

-- Indexes for performance
CREATE INDEX idx_follows_follower ON user_follows(follower_id, created_at DESC);
CREATE INDEX idx_follows_followee ON user_follows(followee_id, created_at DESC);
CREATE INDEX idx_follows_mutual ON user_follows(follower_id, followee_id);
CREATE INDEX idx_blocks_blocker ON user_blocks(blocker_id);
CREATE INDEX idx_blocks_blocked ON user_blocks(blocked_id);
CREATE INDEX idx_activities_user ON activities(user_id, created_at DESC);
CREATE INDEX idx_activities_type ON activities(type, created_at DESC);
CREATE INDEX idx_notifications_user ON notifications(user_id, read, created_at DESC);
CREATE INDEX idx_notifications_unread ON notifications(user_id) WHERE read = false;
```

## Dependencies

- SOC-001: Strategy Publishing System (for activity feed content)
- User authentication system (AUTH-001)
- Notification service (email and in-app)
- Redis for caching and rate limiting
- WebSocket server for real-time updates (optional)

## References

- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 4: Social & Community Features
- [API Documentation](../../api/follow-system.md) - Follow system API endpoints
- [Notification Service](../../services/notifications.md) - Notification delivery system
- [Activity Feed Architecture](../../architecture/activity-feed.md) - Feed design patterns

## Notes

### Implementation Tips

1. **Denormalize follower counts**: Store counts directly on user records for fast access
2. **Use optimistic UI updates**: Update UI immediately, rollback on error
3. **Batch notifications**: Group multiple follows into digest notifications
4. **Cache follower status**: Cache follow relationships for frequently checked users
5. **Implement fanout strategy**: Choose fanout-on-write for small networks, fanout-on-read for large
6. **Rate limiting**: Be strict with rate limits to prevent abuse

### Activity Feed Strategies

**Fanout-on-Write** (Recommended for MVP):
- When user publishes activity, write to all followers' feeds
- Pros: Fast reads, simple implementation
- Cons: Expensive writes for users with many followers
- Best for: Most users with < 1000 followers

**Fanout-on-Read**:
- Aggregate activities when user requests feed
- Pros: Efficient writes, works for celebrity accounts
- Cons: Slower reads, more complex queries
- Best for: Users with 10,000+ followers

### Future Enhancements

- Follow recommendations based on ML algorithms
- Trending users and strategies
- Mutual connections visualization
- Follow requests for private accounts
- Custom lists and groups of followed users
- Export follower/following data
- Follow activity analytics for users
- Verified badges for notable traders

### Technical Debt

- Consider using Redis for activity feed storage at scale
- Evaluate graph database (Neo4j) for complex relationship queries
- Plan for eventual consistency in distributed follow counts
- Consider dedicated notification microservice as platform grows

## Progress

**0% - Not started**
