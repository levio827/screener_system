# SOC-003: Community Feed

## Metadata

| Field | Value |
|-------|-------|
| **ID** | SOC-003 |
| **Title** | Build Community Activity Feed |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P2 (Medium) |
| **Estimate** | 16 hours |
| **Sprint** | Sprint 8 |
| **Epic** | Social & Community Features |
| **Assignee** | TBD |
| **Depends On** | SOC-002 |
| **Created** | 2025-11-29 |
| **Tags** | social, community-feed, real-time, content-moderation, websocket |
| **Blocks** | None |

## Description

Build a comprehensive community activity feed and stock analysis sharing platform that allows users to post stock analyses, comment on strategies, and engage with the community. The feed aggregates activities from followed users and the broader community, supports real-time updates via WebSocket, includes like/comment functionality, hashtag support for discovery, and content filtering options.

This feature creates a dynamic, engaging social experience where users can share insights, learn from others, and build their reputation in the trading community.

## Acceptance Criteria

- [ ] Activity feed displaying posts from followed users and global community
- [ ] Stock analysis post creation with rich text editor and chart attachments
- [ ] Like/comment functionality on posts with real-time count updates
- [ ] Hashtag support with clickable tags and trending hashtags
- [ ] Feed filtering options (following only, all users, specific hashtags)
- [ ] Real-time updates using WebSocket for new posts and interactions
- [ ] Content moderation for posts and comments
- [ ] Post edit and delete functionality with history tracking
- [ ] Image and chart upload support
- [ ] Infinite scroll pagination for feed
- [ ] Share post functionality (copy link, share to external platforms)

## Subtasks

- [ ] Backend Development
  - [ ] Create database schema for posts, comments, likes, hashtags
  - [ ] Implement post API endpoints
    - [ ] POST /api/posts - Create new post
    - [ ] PUT /api/posts/:id - Update post
    - [ ] DELETE /api/posts/:id - Delete post
    - [ ] GET /api/posts - Get feed with filters
    - [ ] GET /api/posts/:id - Get single post with comments
  - [ ] Implement comment API endpoints
    - [ ] POST /api/posts/:id/comments - Add comment
    - [ ] DELETE /api/comments/:id - Delete comment
  - [ ] Implement like/unlike endpoints
    - [ ] POST /api/posts/:id/like - Like post
    - [ ] DELETE /api/posts/:id/like - Unlike post
  - [ ] Add hashtag extraction and indexing
  - [ ] Create trending hashtags calculation
  - [ ] Implement content moderation service
  - [ ] Build image upload and storage service
  - [ ] Set up WebSocket server for real-time updates
- [ ] Frontend Development
  - [ ] Create post composer with rich text editor
  - [ ] Build feed component with infinite scroll
  - [ ] Implement post card component with actions
  - [ ] Create comment section with threaded replies
  - [ ] Add hashtag input and autocomplete
  - [ ] Build filter controls for feed
  - [ ] Implement WebSocket client for real-time updates
  - [ ] Create trending hashtags sidebar
  - [ ] Add image preview and upload UI
- [ ] Real-time Features
  - [ ] Set up WebSocket connection management
  - [ ] Implement real-time post broadcasting
  - [ ] Add real-time like/comment count updates
  - [ ] Handle online user presence
- [ ] Testing
  - [ ] Write unit tests for post/comment CRUD
  - [ ] Add integration tests for feed aggregation
  - [ ] Create E2E tests for posting workflow
  - [ ] Test WebSocket real-time functionality
  - [ ] Validate content moderation

## Implementation Details

### Post Service (TypeScript)

```typescript
// services/PostService.ts
import { ContentModerator } from './ContentModerator';
import { ImageUploadService } from './ImageUploadService';
import { WebSocketService } from './WebSocketService';

export interface Post {
  id: string;
  userId: string;
  content: string;
  stockSymbol?: string;
  images?: string[];
  hashtags: string[];
  likeCount: number;
  commentCount: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreatePostData {
  content: string;
  stockSymbol?: string;
  images?: File[];
  hashtags?: string[];
}

export class PostService {
  private contentModerator: ContentModerator;
  private imageService: ImageUploadService;
  private wsService: WebSocketService;

  constructor() {
    this.contentModerator = new ContentModerator();
    this.imageService = new ImageUploadService();
    this.wsService = new WebSocketService();
  }

  async createPost(userId: string, data: CreatePostData): Promise<Post> {
    // Content moderation
    const moderationResult = await this.contentModerator.check({
      content: data.content
    });

    if (!moderationResult.approved) {
      throw new Error(`Content moderation failed: ${moderationResult.reason}`);
    }

    // Upload images if provided
    let imageUrls: string[] = [];
    if (data.images && data.images.length > 0) {
      imageUrls = await this.imageService.uploadMultiple(data.images, {
        maxFiles: 4,
        maxSizePerFile: 5 * 1024 * 1024, // 5MB
        allowedTypes: ['image/jpeg', 'image/png', 'image/gif']
      });
    }

    // Extract hashtags from content
    const extractedHashtags = this.extractHashtags(data.content);
    const allHashtags = [...new Set([...extractedHashtags, ...(data.hashtags || [])])];

    // Create post
    const post = await db.posts.create({
      data: {
        userId,
        content: data.content,
        stockSymbol: data.stockSymbol?.toUpperCase(),
        images: imageUrls,
        hashtags: allHashtags,
        likeCount: 0,
        commentCount: 0,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      include: {
        user: {
          select: {
            id: true,
            username: true,
            displayName: true,
            avatarUrl: true
          }
        }
      }
    });

    // Update hashtag counts
    await this.updateHashtagCounts(allHashtags);

    // Broadcast to followers via WebSocket
    await this.broadcastNewPost(post);

    // Log activity
    await db.activities.create({
      data: {
        userId,
        type: 'POST_CREATED',
        metadata: { postId: post.id },
        createdAt: new Date()
      }
    });

    return post;
  }

  async getFeed(options: {
    userId?: string;
    filter?: 'following' | 'all' | 'trending';
    hashtag?: string;
    stockSymbol?: string;
    page?: number;
    limit?: number;
  }): Promise<{ posts: Post[]; hasMore: boolean }> {
    const { userId, filter = 'all', hashtag, stockSymbol, page = 1, limit = 20 } = options;

    let where: any = {
      deleted: false
    };

    // Apply filters
    if (filter === 'following' && userId) {
      const following = await db.userFollows.findMany({
        where: { followerId: userId },
        select: { followeeId: true }
      });
      where.userId = { in: following.map(f => f.followeeId) };
    }

    if (hashtag) {
      where.hashtags = { has: hashtag.toLowerCase() };
    }

    if (stockSymbol) {
      where.stockSymbol = stockSymbol.toUpperCase();
    }

    // Fetch posts
    const posts = await db.posts.findMany({
      where,
      skip: (page - 1) * limit,
      take: limit + 1,
      include: {
        user: {
          select: {
            id: true,
            username: true,
            displayName: true,
            avatarUrl: true,
            verified: true
          }
        },
        _count: {
          select: {
            likes: true,
            comments: true
          }
        }
      },
      orderBy: filter === 'trending'
        ? [{ likeCount: 'desc' }, { createdAt: 'desc' }]
        : { createdAt: 'desc' }
    });

    const hasMore = posts.length > limit;
    if (hasMore) {
      posts.pop();
    }

    // Check if current user liked each post
    if (userId) {
      const postIds = posts.map(p => p.id);
      const userLikes = await db.postLikes.findMany({
        where: {
          userId,
          postId: { in: postIds }
        },
        select: { postId: true }
      });

      const likedPostIds = new Set(userLikes.map(l => l.postId));
      posts.forEach(post => {
        (post as any).likedByCurrentUser = likedPostIds.has(post.id);
      });
    }

    return { posts, hasMore };
  }

  async likePost(userId: string, postId: string): Promise<void> {
    // Check if already liked
    const existingLike = await db.postLikes.findUnique({
      where: {
        userId_postId: { userId, postId }
      }
    });

    if (existingLike) {
      throw new Error('Post already liked');
    }

    // Create like
    await db.postLikes.create({
      data: { userId, postId, createdAt: new Date() }
    });

    // Update like count
    const post = await db.posts.update({
      where: { id: postId },
      data: { likeCount: { increment: 1 } },
      include: {
        user: { select: { id: true } }
      }
    });

    // Notify post author
    if (post.user.id !== userId) {
      await this.notifyPostAuthor(post.user.id, userId, postId, 'like');
    }

    // Broadcast real-time update
    this.wsService.broadcast({
      type: 'POST_LIKED',
      postId,
      likeCount: post.likeCount
    });
  }

  async addComment(userId: string, postId: string, content: string): Promise<Comment> {
    // Content moderation
    const moderationResult = await this.contentModerator.check({ content });

    if (!moderationResult.approved) {
      throw new Error(`Comment moderation failed: ${moderationResult.reason}`);
    }

    // Create comment
    const comment = await db.comments.create({
      data: {
        userId,
        postId,
        content,
        createdAt: new Date()
      },
      include: {
        user: {
          select: {
            id: true,
            username: true,
            displayName: true,
            avatarUrl: true
          }
        }
      }
    });

    // Update comment count
    await db.posts.update({
      where: { id: postId },
      data: { commentCount: { increment: 1 } }
    });

    // Notify post author
    const post = await db.posts.findUnique({
      where: { id: postId },
      select: { userId: true }
    });

    if (post && post.userId !== userId) {
      await this.notifyPostAuthor(post.userId, userId, postId, 'comment');
    }

    // Broadcast real-time update
    this.wsService.broadcast({
      type: 'NEW_COMMENT',
      postId,
      comment
    });

    return comment;
  }

  async getTrendingHashtags(limit: number = 10): Promise<Array<{ tag: string; count: number }>> {
    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);

    const trending = await db.posts.findMany({
      where: {
        createdAt: { gte: oneDayAgo },
        deleted: false
      },
      select: { hashtags: true }
    });

    // Count hashtag occurrences
    const tagCounts = new Map<string, number>();
    trending.forEach(post => {
      post.hashtags.forEach(tag => {
        tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
      });
    });

    // Sort and return top tags
    return Array.from(tagCounts.entries())
      .map(([tag, count]) => ({ tag, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, limit);
  }

  private extractHashtags(content: string): string[] {
    const hashtagRegex = /#(\w+)/g;
    const matches = content.match(hashtagRegex) || [];
    return matches.map(tag => tag.slice(1).toLowerCase());
  }

  private async updateHashtagCounts(hashtags: string[]): Promise<void> {
    for (const tag of hashtags) {
      await db.hashtags.upsert({
        where: { tag },
        create: {
          tag,
          count: 1,
          lastUsed: new Date()
        },
        update: {
          count: { increment: 1 },
          lastUsed: new Date()
        }
      });
    }
  }

  private async broadcastNewPost(post: Post): Promise<void> {
    // Get followers of post author
    const followers = await db.userFollows.findMany({
      where: { followeeId: post.userId },
      select: { followerId: true }
    });

    // Broadcast to all followers
    followers.forEach(follower => {
      this.wsService.sendToUser(follower.followerId, {
        type: 'NEW_POST',
        post
      });
    });
  }

  private async notifyPostAuthor(
    authorId: string,
    actorId: string,
    postId: string,
    action: 'like' | 'comment'
  ): Promise<void> {
    const actor = await db.users.findUnique({
      where: { id: actorId },
      select: { username: true, displayName: true }
    });

    if (!actor) return;

    await db.notifications.create({
      data: {
        userId: authorId,
        type: action === 'like' ? 'POST_LIKED' : 'POST_COMMENTED',
        title: action === 'like'
          ? `${actor.displayName} liked your post`
          : `${actor.displayName} commented on your post`,
        message: action === 'like'
          ? `${actor.displayName} (@${actor.username}) liked your post`
          : `${actor.displayName} (@${actor.username}) commented on your post`,
        actionUrl: `/posts/${postId}`,
        metadata: { postId, actorId },
        read: false,
        createdAt: new Date()
      }
    });
  }
}
```

### WebSocket Service (TypeScript)

```typescript
// services/WebSocketService.ts
import WebSocket from 'ws';

interface WebSocketMessage {
  type: string;
  [key: string]: any;
}

export class WebSocketService {
  private wss: WebSocket.Server;
  private userConnections: Map<string, Set<WebSocket>>;

  constructor(server: any) {
    this.wss = new WebSocket.Server({ server });
    this.userConnections = new Map();

    this.wss.on('connection', this.handleConnection.bind(this));
  }

  private handleConnection(ws: WebSocket, req: any): void {
    // Extract user ID from auth token
    const userId = this.authenticateConnection(req);

    if (!userId) {
      ws.close(1008, 'Unauthorized');
      return;
    }

    // Store connection
    if (!this.userConnections.has(userId)) {
      this.userConnections.set(userId, new Set());
    }
    this.userConnections.get(userId)!.add(ws);

    console.log(`User ${userId} connected`);

    // Handle messages
    ws.on('message', (data: string) => {
      try {
        const message = JSON.parse(data);
        this.handleMessage(userId, message, ws);
      } catch (error) {
        console.error('Invalid WebSocket message:', error);
      }
    });

    // Handle disconnection
    ws.on('close', () => {
      const connections = this.userConnections.get(userId);
      if (connections) {
        connections.delete(ws);
        if (connections.size === 0) {
          this.userConnections.delete(userId);
        }
      }
      console.log(`User ${userId} disconnected`);
    });

    // Send initial connection success
    this.sendToSocket(ws, { type: 'CONNECTED', userId });
  }

  sendToUser(userId: string, message: WebSocketMessage): void {
    const connections = this.userConnections.get(userId);
    if (connections) {
      connections.forEach(ws => {
        if (ws.readyState === WebSocket.OPEN) {
          this.sendToSocket(ws, message);
        }
      });
    }
  }

  broadcast(message: WebSocketMessage): void {
    this.wss.clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN) {
        this.sendToSocket(client, message);
      }
    });
  }

  private sendToSocket(ws: WebSocket, message: WebSocketMessage): void {
    ws.send(JSON.stringify(message));
  }

  private handleMessage(userId: string, message: any, ws: WebSocket): void {
    switch (message.type) {
      case 'PING':
        this.sendToSocket(ws, { type: 'PONG' });
        break;

      case 'SUBSCRIBE_POST':
        // Subscribe to specific post updates
        // Implementation depends on requirements
        break;

      default:
        console.log('Unknown message type:', message.type);
    }
  }

  private authenticateConnection(req: any): string | null {
    // Extract and verify JWT token from query params or headers
    const token = req.url.split('token=')[1];
    if (!token) return null;

    try {
      // Verify token and return user ID
      // Implementation depends on auth system
      return 'user-id'; // Placeholder
    } catch (error) {
      return null;
    }
  }
}
```

## Testing Strategy

### Unit Tests

```typescript
// tests/unit/PostService.test.ts
describe('PostService', () => {
  let service: PostService;
  let mockDb: jest.Mocked<Database>;

  beforeEach(() => {
    mockDb = createMockDatabase();
    service = new PostService(mockDb);
  });

  describe('createPost', () => {
    it('should create post with extracted hashtags', async () => {
      const userId = 'user-123';
      const postData = {
        content: 'Great stock analysis #tech #growth',
        stockSymbol: 'AAPL'
      };

      const result = await service.createPost(userId, postData);

      expect(result.hashtags).toContain('tech');
      expect(result.hashtags).toContain('growth');
      expect(mockDb.posts.create).toHaveBeenCalled();
    });

    it('should reject posts with inappropriate content', async () => {
      const postData = {
        content: 'Guaranteed returns with this scam strategy'
      };

      await expect(
        service.createPost('user-123', postData)
      ).rejects.toThrow('Content moderation failed');
    });
  });

  describe('getFeed', () => {
    it('should filter feed by following', async () => {
      const userId = 'user-1';

      mockDb.userFollows.findMany.mockResolvedValue([
        { followerId: userId, followeeId: 'user-2' }
      ]);

      await service.getFeed({ userId, filter: 'following' });

      expect(mockDb.posts.findMany).toHaveBeenCalledWith(
        expect.objectContaining({
          where: expect.objectContaining({
            userId: { in: ['user-2'] }
          })
        })
      );
    });

    it('should filter feed by hashtag', async () => {
      await service.getFeed({ hashtag: 'tech' });

      expect(mockDb.posts.findMany).toHaveBeenCalledWith(
        expect.objectContaining({
          where: expect.objectContaining({
            hashtags: { has: 'tech' }
          })
        })
      );
    });
  });
});
```

### Integration Tests

```typescript
// tests/integration/community-feed.test.ts
describe('Community Feed Integration', () => {
  let app: Express;
  let user: User;

  beforeAll(async () => {
    app = await createTestApp();
    user = await createTestUser();
  });

  it('should create post and appear in feed', async () => {
    const postResponse = await request(app)
      .post('/api/posts')
      .set('Authorization', `Bearer ${user.token}`)
      .send({
        content: 'Great analysis of $AAPL #tech',
        stockSymbol: 'AAPL'
      });

    expect(postResponse.status).toBe(201);
    const postId = postResponse.body.id;

    const feedResponse = await request(app)
      .get('/api/posts')
      .set('Authorization', `Bearer ${user.token}`);

    expect(feedResponse.body.posts).toContainEqual(
      expect.objectContaining({ id: postId })
    );
  });

  it('should handle like and comment workflow', async () => {
    const post = await createTestPost(user);

    // Like post
    const likeResponse = await request(app)
      .post(`/api/posts/${post.id}/like`)
      .set('Authorization', `Bearer ${user.token}`);

    expect(likeResponse.status).toBe(200);

    // Add comment
    const commentResponse = await request(app)
      .post(`/api/posts/${post.id}/comments`)
      .set('Authorization', `Bearer ${user.token}`)
      .send({ content: 'Great analysis!' });

    expect(commentResponse.status).toBe(201);

    // Verify counts updated
    const postResponse = await request(app)
      .get(`/api/posts/${post.id}`)
      .set('Authorization', `Bearer ${user.token}`);

    expect(postResponse.body.likeCount).toBe(1);
    expect(postResponse.body.commentCount).toBe(1);
  });
});
```

### E2E Tests

```typescript
// tests/e2e/community-feed.spec.ts
describe('Community Feed E2E', () => {
  it('should create post and see real-time updates', async () => {
    await page.goto('/feed');

    // Create new post
    await page.click('[data-testid="new-post-button"]');
    await page.fill('[data-testid="post-content"]', 'Test post #tech');
    await page.click('[data-testid="submit-post"]');

    // Verify post appears in feed
    await page.waitForSelector('[data-testid="post-card"]');
    expect(await page.textContent('[data-testid="post-card"]'))
      .toContain('Test post');

    // Like the post
    await page.click('[data-testid="like-button"]');
    await page.waitForSelector('[data-testid="like-count"]:has-text("1")');

    // Add comment
    await page.fill('[data-testid="comment-input"]', 'Great post!');
    await page.click('[data-testid="submit-comment"]');

    // Verify comment appears
    await page.waitForSelector('[data-testid="comment"]');
    expect(await page.textContent('[data-testid="comment"]'))
      .toContain('Great post!');
  });
});
```

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Spam posts flooding the feed | High | High | Rate limiting (10 posts/hour), content moderation, user reporting, auto-flagging suspicious patterns |
| Inappropriate or offensive content | Medium | High | Automated content filtering, user reporting, moderator review queue, AI-based moderation |
| WebSocket connection overhead | Medium | Medium | Connection pooling, automatic reconnection, fallback to polling, horizontal scaling |
| Feed performance with high activity | Medium | High | Pagination, caching, database indexes, fanout optimization |
| Image upload abuse (large files, inappropriate images) | Medium | Medium | File size limits (5MB), image compression, content scanning, virus checking |
| Hashtag spam or manipulation | Medium | Low | Limit hashtags per post (10 max), ignore uncommon variations, trending algorithm weights |
| Real-time delivery failures | Low | Medium | Message queuing, retry logic, graceful degradation to polling |
| Database write contention on like/comment counts | Low | Medium | Use atomic increments, consider eventual consistency, optimize indexes |

## Performance Requirements

- **Post Creation**: < 500ms including image upload
- **Feed Loading**: < 400ms for first page (20 posts)
- **Like/Comment Actions**: < 100ms response time
- **WebSocket Message Delivery**: < 50ms latency
- **Image Upload**: < 2 seconds for 5MB image
- **Database Queries**:
  - Feed aggregation: < 300ms
  - Hashtag search: < 200ms
  - Post detail with comments: < 250ms
- **Concurrent Users**: Support 1000+ simultaneous WebSocket connections
- **Feed Updates**: Real-time delivery within 1 second
- **Trending Hashtags**: Update every 5 minutes
- **API Rate Limits**:
  - Post creation: 10 per user per hour
  - Like/comment: 300 actions per user per hour
  - Feed refresh: 120 requests per user per minute

## Security Considerations

### Content Moderation

- Automated filtering for prohibited words and spam patterns
- User reporting system for inappropriate content
- Moderator review queue for flagged content
- Rate limiting to prevent content flood
- Image content scanning for inappropriate material

### User Data Privacy

- Posts visible based on privacy settings
- User can delete their own posts and comments
- Soft delete for audit trail and moderation
- GDPR-compliant data export and deletion

### Input Validation

```typescript
const POST_VALIDATION = {
  maxContentLength: 5000,
  maxHashtags: 10,
  maxImages: 4,
  maxImageSize: 5 * 1024 * 1024, // 5MB
  allowedImageTypes: ['image/jpeg', 'image/png', 'image/gif'],
  rateLimit: {
    postsPerHour: 10,
    commentsPerHour: 100,
    likesPerHour: 300
  }
};
```

## Error Handling

```typescript
// API error handling
app.post('/api/posts', async (req, res) => {
  try {
    const userId = req.user.id;
    const postData = req.body;

    const post = await postService.createPost(userId, postData);
    res.status(201).json(post);

  } catch (error) {
    if (error.message.includes('moderation')) {
      return res.status(400).json({
        error: 'CONTENT_MODERATION_FAILED',
        message: error.message
      });
    }

    if (error.message.includes('rate limit')) {
      return res.status(429).json({
        error: 'RATE_LIMIT_EXCEEDED',
        message: 'You have exceeded the posting rate limit'
      });
    }

    console.error('Error creating post:', error);
    res.status(500).json({
      error: 'INTERNAL_ERROR',
      message: 'Failed to create post'
    });
  }
});
```

## Database Schema

```sql
CREATE TABLE posts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    stock_symbol VARCHAR(10),
    images TEXT[],
    hashtags VARCHAR(50)[],
    like_count INTEGER DEFAULT 0,
    comment_count INTEGER DEFAULT 0,
    deleted BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT valid_content_length CHECK (char_length(content) <= 5000),
    CONSTRAINT valid_hashtag_count CHECK (array_length(hashtags, 1) <= 10)
);

CREATE TABLE comments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    post_id UUID REFERENCES posts(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    deleted BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT valid_comment_length CHECK (char_length(content) <= 1000)
);

CREATE TABLE post_likes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    post_id UUID REFERENCES posts(id) ON DELETE CASCADE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(user_id, post_id)
);

CREATE TABLE hashtags (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tag VARCHAR(50) UNIQUE NOT NULL,
    count INTEGER DEFAULT 0,
    last_used TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX idx_posts_user ON posts(user_id, created_at DESC) WHERE deleted = false;
CREATE INDEX idx_posts_created ON posts(created_at DESC) WHERE deleted = false;
CREATE INDEX idx_posts_hashtags ON posts USING GIN(hashtags) WHERE deleted = false;
CREATE INDEX idx_posts_stock ON posts(stock_symbol) WHERE deleted = false;
CREATE INDEX idx_posts_trending ON posts(like_count DESC, created_at DESC) WHERE deleted = false;
CREATE INDEX idx_comments_post ON comments(post_id, created_at DESC) WHERE deleted = false;
CREATE INDEX idx_likes_post ON post_likes(post_id);
CREATE INDEX idx_likes_user ON post_likes(user_id);
CREATE INDEX idx_hashtags_trending ON hashtags(count DESC, last_used DESC);
```

## Dependencies

- SOC-002: User Follow System (for personalized feed)
- SOC-001: Strategy Publishing System (for linking strategies in posts)
- Image upload and storage service (S3 or similar)
- WebSocket server infrastructure
- Content moderation service
- Redis for caching and rate limiting

## References

- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 4: Social & Community Features
- [WebSocket Architecture](../../architecture/websocket.md) - Real-time communication
- [Content Moderation Guidelines](../../security/content-moderation.md)

## Notes

### Implementation Tips

1. Start with basic post/comment functionality, add real-time later
2. Use database transactions for like/comment count updates
3. Implement optimistic UI updates for better UX
4. Cache trending hashtags and popular posts
5. Use CDN for image delivery
6. Consider message queue for activity broadcasting at scale

### Future Enhancements

- Threaded comment replies
- Post bookmarking
- Share to external platforms
- Polls and surveys
- Video upload support
- Live streaming integration
- Advanced search with filters
- Personalized feed ranking with ML

## Progress

**0% - Not started**
