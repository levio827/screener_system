# SOC-004: Leaderboard

## Metadata

| Field | Value |
|-------|-------|
| **ID** | SOC-004 |
| **Title** | Implement Trader Leaderboard |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P2 (Medium) |
| **Estimate** | 12 hours |
| **Sprint** | Sprint 8 |
| **Epic** | Social & Community Features |
| **Assignee** | TBD |
| **Depends On** | SOC-001 |
| **Created** | 2025-11-29 |
| **Tags** | social, leaderboard, rankings, gamification, performance-tracking |
| **Blocks** | None |

## Description

Implement a comprehensive trader leaderboard system that ranks users based on their published strategy performance. The leaderboard supports multiple time periods (weekly, monthly, yearly, all-time), category-based rankings (growth stocks, value stocks, dividend stocks), and displays ranking changes, top trader profiles, and personal rankings.

This feature drives engagement through gamification, helps users discover successful traders to follow, and provides recognition for top-performing community members.

## Acceptance Criteria

- [ ] Period-based leaderboard (weekly, monthly, yearly, all-time) with performance metrics
- [ ] Category-based leaderboard (growth stocks, value stocks, dividend stocks, etc.)
- [ ] Leaderboard ranking changes display (up/down arrows with position change)
- [ ] Top trader profile highlight with badges and achievements
- [ ] My ranking display showing user's position and nearby competitors
- [ ] Leaderboard filtering by strategy type and market segment
- [ ] Performance trend charts for top traders
- [ ] Fair ranking algorithm accounting for risk and sample size
- [ ] Caching for performance optimization
- [ ] Historical ranking tracking

## Subtasks

- [ ] Backend Development
  - [ ] Create database schema for leaderboard rankings and history
  - [ ] Implement ranking calculation service
    - [ ] Calculate returns with risk-adjusted metrics (Sharpe ratio)
    - [ ] Weight by strategy age and sample size
    - [ ] Handle ties and edge cases
  - [ ] Create leaderboard API endpoints
    - [ ] GET /api/leaderboard - Get rankings with filters
    - [ ] GET /api/leaderboard/me - Get current user's rank
    - [ ] GET /api/leaderboard/:userId - Get user's historical rankings
  - [ ] Build daily ranking update job
  - [ ] Implement category classification logic
  - [ ] Add ranking history tracking
  - [ ] Create caching layer for leaderboards
- [ ] Frontend Development
  - [ ] Build leaderboard table component
  - [ ] Create period selector (weekly/monthly/yearly/all-time)
  - [ ] Implement category filter dropdown
  - [ ] Add ranking change indicators
  - [ ] Build top trader profile cards
  - [ ] Create "My Ranking" widget
  - [ ] Add performance trend charts
  - [ ] Implement infinite scroll for rankings
- [ ] Analytics & Tracking
  - [ ] Track leaderboard view events
  - [ ] Monitor ranking calculation performance
  - [ ] Log user ranking changes
- [ ] Testing
  - [ ] Write unit tests for ranking algorithms
  - [ ] Add integration tests for leaderboard API
  - [ ] Create E2E tests for leaderboard views
  - [ ] Test ranking edge cases (ties, new users)
  - [ ] Validate caching behavior

## Implementation Details

### Leaderboard Service (TypeScript)

```typescript
// services/LeaderboardService.ts
export interface LeaderboardEntry {
  rank: number;
  userId: string;
  username: string;
  displayName: string;
  avatarUrl: string;
  totalReturn: number;
  sharpeRatio: number;
  strategyCount: number;
  followerCount: number;
  rankChange: number; // Positive for up, negative for down
  badge?: string;
}

export interface LeaderboardFilters {
  period: 'weekly' | 'monthly' | 'yearly' | 'all-time';
  category?: 'growth' | 'value' | 'dividend' | 'momentum';
  limit?: number;
  offset?: number;
}

export class LeaderboardService {
  async getLeaderboard(filters: LeaderboardFilters): Promise<{
    entries: LeaderboardEntry[];
    total: number;
  }> {
    const { period, category, limit = 50, offset = 0 } = filters;

    // Check cache first
    const cacheKey = `leaderboard:${period}:${category || 'all'}`;
    const cached = await this.getFromCache(cacheKey);
    if (cached) {
      return {
        entries: cached.slice(offset, offset + limit),
        total: cached.length
      };
    }

    // Calculate date range
    const dateRange = this.getDateRange(period);

    // Get user performances
    const performances = await this.calculatePerformances(dateRange, category);

    // Rank users
    const rankedEntries = this.rankUsers(performances);

    // Get previous rankings for change calculation
    const previousRankings = await this.getPreviousRankings(period);

    // Add rank changes
    const entries = rankedEntries.map(entry => ({
      ...entry,
      rankChange: this.calculateRankChange(entry.userId, entry.rank, previousRankings)
    }));

    // Cache results
    await this.cacheResults(cacheKey, entries);

    return {
      entries: entries.slice(offset, offset + limit),
      total: entries.length
    };
  }

  async getUserRanking(userId: string, period: string): Promise<LeaderboardEntry | null> {
    const leaderboard = await this.getLeaderboard({ period: period as any, limit: 10000 });

    return leaderboard.entries.find(entry => entry.userId === userId) || null;
  }

  async getUserRankingWithContext(
    userId: string,
    period: string,
    contextSize: number = 5
  ): Promise<{
    myRank: LeaderboardEntry | null;
    above: LeaderboardEntry[];
    below: LeaderboardEntry[];
  }> {
    const leaderboard = await this.getLeaderboard({ period: period as any, limit: 10000 });

    const myIndex = leaderboard.entries.findIndex(e => e.userId === userId);
    if (myIndex === -1) {
      return { myRank: null, above: [], below: [] };
    }

    return {
      myRank: leaderboard.entries[myIndex],
      above: leaderboard.entries.slice(
        Math.max(0, myIndex - contextSize),
        myIndex
      ),
      below: leaderboard.entries.slice(
        myIndex + 1,
        Math.min(leaderboard.entries.length, myIndex + 1 + contextSize)
      )
    };
  }

  private async calculatePerformances(
    dateRange: { start: Date; end: Date },
    category?: string
  ): Promise<Array<{
    userId: string;
    totalReturn: number;
    sharpeRatio: number;
    strategyCount: number;
  }>> {
    const query: any = {
      createdAt: {
        gte: dateRange.start,
        lte: dateRange.end
      },
      isPublic: true,
      deleted: false
    };

    if (category) {
      query.category = category;
    }

    const strategies = await db.publishedStrategies.findMany({
      where: query,
      include: {
        user: {
          select: {
            id: true,
            username: true,
            displayName: true,
            avatarUrl: true,
            followerCount: true
          }
        },
        performance: {
          where: {
            date: {
              gte: dateRange.start,
              lte: dateRange.end
            }
          }
        }
      }
    });

    // Group by user and calculate metrics
    const userPerformances = new Map<string, {
      userId: string;
      username: string;
      displayName: string;
      avatarUrl: string;
      followerCount: number;
      returns: number[];
      strategyCount: number;
    }>();

    strategies.forEach(strategy => {
      const userId = strategy.user.id;
      if (!userPerformances.has(userId)) {
        userPerformances.set(userId, {
          userId,
          username: strategy.user.username,
          displayName: strategy.user.displayName,
          avatarUrl: strategy.user.avatarUrl,
          followerCount: strategy.user.followerCount,
          returns: [],
          strategyCount: 0
        });
      }

      const userPerf = userPerformances.get(userId)!;
      userPerf.strategyCount++;

      // Calculate strategy return
      if (strategy.performance.length > 0) {
        const totalReturn = strategy.performance[strategy.performance.length - 1].cumulativeReturn;
        userPerf.returns.push(totalReturn);
      }
    });

    // Calculate final metrics
    return Array.from(userPerformances.values()).map(userPerf => {
      const totalReturn = userPerf.returns.reduce((sum, r) => sum + r, 0) / userPerf.returns.length;
      const sharpeRatio = this.calculateSharpeRatio(userPerf.returns);

      return {
        userId: userPerf.userId,
        username: userPerf.username,
        displayName: userPerf.displayName,
        avatarUrl: userPerf.avatarUrl,
        followerCount: userPerf.followerCount,
        totalReturn,
        sharpeRatio,
        strategyCount: userPerf.strategyCount
      };
    });
  }

  private rankUsers(performances: any[]): LeaderboardEntry[] {
    // Sort by composite score (weighted combination of return and risk-adjusted return)
    const scored = performances.map(perf => ({
      ...perf,
      score: this.calculateCompositeScore(perf)
    }));

    scored.sort((a, b) => b.score - a.score);

    // Assign ranks
    return scored.map((entry, index) => ({
      rank: index + 1,
      userId: entry.userId,
      username: entry.username,
      displayName: entry.displayName,
      avatarUrl: entry.avatarUrl,
      totalReturn: entry.totalReturn,
      sharpeRatio: entry.sharpeRatio,
      strategyCount: entry.strategyCount,
      followerCount: entry.followerCount,
      rankChange: 0, // Will be calculated later
      badge: this.getBadge(index + 1)
    }));
  }

  private calculateCompositeScore(performance: any): number {
    // Weighted score: 60% return, 30% Sharpe ratio, 10% strategy count
    const returnScore = performance.totalReturn * 0.6;
    const sharpeScore = performance.sharpeRatio * 0.3;
    const volumeScore = Math.min(performance.strategyCount / 10, 1) * 0.1;

    return returnScore + sharpeScore + volumeScore;
  }

  private calculateSharpeRatio(returns: number[]): number {
    if (returns.length < 2) return 0;

    const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
    const variance = returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length;
    const stdDev = Math.sqrt(variance);

    // Assuming risk-free rate of 0.02 (2%)
    const riskFreeRate = 0.02;

    return stdDev === 0 ? 0 : (avgReturn - riskFreeRate) / stdDev;
  }

  private calculateRankChange(
    userId: string,
    currentRank: number,
    previousRankings: Map<string, number>
  ): number {
    const previousRank = previousRankings.get(userId);
    if (!previousRank) return 0;

    return previousRank - currentRank; // Positive means moved up
  }

  private async getPreviousRankings(period: string): Promise<Map<string, number>> {
    const previousPeriod = this.getPreviousPeriod(period);

    const rankings = await db.leaderboardHistory.findMany({
      where: {
        period,
        date: previousPeriod
      }
    });

    return new Map(rankings.map(r => [r.userId, r.rank]));
  }

  private getBadge(rank: number): string | undefined {
    if (rank === 1) return 'gold';
    if (rank === 2) return 'silver';
    if (rank === 3) return 'bronze';
    if (rank <= 10) return 'top10';
    return undefined;
  }

  private getDateRange(period: string): { start: Date; end: Date } {
    const now = new Date();
    const end = now;
    let start: Date;

    switch (period) {
      case 'weekly':
        start = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case 'monthly':
        start = new Date(now.getFullYear(), now.getMonth(), 1);
        break;
      case 'yearly':
        start = new Date(now.getFullYear(), 0, 1);
        break;
      case 'all-time':
      default:
        start = new Date(0);
    }

    return { start, end };
  }

  private getPreviousPeriod(period: string): Date {
    const now = new Date();

    switch (period) {
      case 'weekly':
        return new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);
      case 'monthly':
        return new Date(now.getFullYear(), now.getMonth() - 1, 1);
      case 'yearly':
        return new Date(now.getFullYear() - 1, 0, 1);
      default:
        return new Date(0);
    }
  }

  private async getFromCache(key: string): Promise<any> {
    // Redis cache implementation
    return null; // Placeholder
  }

  private async cacheResults(key: string, data: any): Promise<void> {
    // Cache for 1 hour
    // Redis implementation
  }
}
```

## Testing Strategy

### Unit Tests

```typescript
describe('LeaderboardService', () => {
  it('should calculate Sharpe ratio correctly', () => {
    const returns = [0.05, 0.03, 0.07, 0.02, 0.06];
    const sharpe = service['calculateSharpeRatio'](returns);
    expect(sharpe).toBeGreaterThan(0);
  });

  it('should rank users by composite score', () => {
    const performances = [
      { userId: '1', totalReturn: 0.15, sharpeRatio: 1.2, strategyCount: 5 },
      { userId: '2', totalReturn: 0.20, sharpeRatio: 0.8, strategyCount: 3 },
      { userId: '3', totalReturn: 0.12, sharpeRatio: 1.5, strategyCount: 7 }
    ];

    const ranked = service['rankUsers'](performances);
    expect(ranked[0].rank).toBe(1);
    expect(ranked.length).toBe(3);
  });

  it('should calculate rank changes correctly', () => {
    const previousRankings = new Map([['user-1', 5]]);
    const change = service['calculateRankChange']('user-1', 3, previousRankings);
    expect(change).toBe(2); // Moved up from 5 to 3
  });
});
```

### Integration Tests

```typescript
describe('Leaderboard Integration', () => {
  it('should get leaderboard with filters', async () => {
    const response = await request(app)
      .get('/api/leaderboard')
      .query({ period: 'monthly', category: 'growth' });

    expect(response.status).toBe(200);
    expect(response.body.entries).toBeInstanceOf(Array);
    expect(response.body.entries[0]).toHaveProperty('rank');
  });
});
```

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Unfair rankings due to manipulation | Medium | High | Require minimum strategy age (30 days), sample size (10+ trades), risk-adjust returns |
| Performance degradation with large user base | Medium | High | Aggressive caching (1-hour TTL), pre-compute daily, database indexes |
| Gaming the system with many low-quality strategies | Medium | Medium | Weight by strategy quality, follower count, limit strategies per user in calculation |
| Calculation accuracy issues | Low | Medium | Comprehensive unit tests, validate against known results, monitoring |
| Cache inconsistency | Low | Low | Clear cache on strategy updates, use short TTL, version cache keys |

## Performance Requirements

- **Leaderboard Load Time**: < 300ms for cached results
- **Ranking Calculation**: < 5 seconds for daily batch update
- **User Rank Lookup**: < 100ms
- **Cache Hit Rate**: > 95% for popular periods
- **Support**: 100,000+ users in rankings
- **API Rate Limits**: 60 requests per minute per user

## Security Considerations

- Only include public strategies in rankings
- Prevent enumeration of user performance data
- Rate limit leaderboard API access
- Validate all filter inputs
- Audit trail for ranking changes

## Error Handling

```typescript
app.get('/api/leaderboard', async (req, res) => {
  try {
    const filters = {
      period: req.query.period || 'monthly',
      category: req.query.category,
      limit: parseInt(req.query.limit as string) || 50,
      offset: parseInt(req.query.offset as string) || 0
    };

    const result = await leaderboardService.getLeaderboard(filters);
    res.json(result);

  } catch (error) {
    console.error('Leaderboard error:', error);
    res.status(500).json({
      error: 'LEADERBOARD_ERROR',
      message: 'Failed to load leaderboard'
    });
  }
});
```

## Database Schema

```sql
CREATE TABLE leaderboard_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    period VARCHAR(20) NOT NULL,
    date DATE NOT NULL,
    rank INTEGER NOT NULL,
    total_return DECIMAL(10, 4),
    sharpe_ratio DECIMAL(10, 4),
    strategy_count INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(user_id, period, date)
);

CREATE INDEX idx_leaderboard_history_period_date ON leaderboard_history(period, date, rank);
CREATE INDEX idx_leaderboard_history_user ON leaderboard_history(user_id, period, date DESC);
```

## Dependencies

- SOC-001: Strategy Publishing System (for performance data)
- Redis for caching
- Background job scheduler for daily rankings update

## References

- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 4: Social & Community Features
- [Performance Metrics](../../algorithms/performance-metrics.md) - Return and risk calculations

## Notes

### Implementation Tips

1. Pre-compute leaderboards daily via cron job
2. Cache heavily - leaderboards change slowly
3. Use database materialized views for complex aggregations
4. Show "last updated" timestamp to users
5. Implement pagination for large leaderboards
6. Consider separate leaderboards for verified vs. all users

### Future Enhancements

- Regional leaderboards
- Asset-class specific rankings
- Achievement system with badges
- Leaderboard challenges and competitions
- Historical rank progression charts
- Peer group comparisons
- Expert trader tier system

## Progress

**0% - Not started**
