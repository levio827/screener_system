# SOC-005: Copy Trading (MVP)

## Metadata

| Field | Value |
|-------|-------|
| **ID** | SOC-005 |
| **Title** | Implement Basic Copy Trading |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P3 (Low) |
| **Estimate** | 8 hours |
| **Sprint** | Sprint 9 |
| **Epic** | Social & Community Features |
| **Assignee** | TBD |
| **Depends On** | SOC-001, SOC-002 |
| **Created** | 2025-11-29 |
| **Tags** | social, copy-trading, notifications, strategy-sync, automation |
| **Blocks** | None |

## Description

Implement a minimum viable product (MVP) for copy trading that allows users to copy other users' strategies and receive notifications when those strategies are updated or rebalanced. This notification-based approach provides a lightweight introduction to copy trading without the complexity of automatic trade execution.

Users can copy successful strategies with a single click, receive timely notifications when the original strategy changes, and manually apply updates to their own portfolios. The system also tracks performance comparison between the original and copied strategies.

## Acceptance Criteria

- [ ] Strategy copy button on published strategies with confirmation dialog
- [ ] Copied strategy rebalancing notification system
- [ ] Original strategy change notification (when author updates filters or parameters)
- [ ] Copied strategy performance comparison vs. original
- [ ] List of strategies user has copied with status
- [ ] Ability to stop following a copied strategy
- [ ] Notification preferences for copy trading alerts
- [ ] Track copy count for strategies (already exists in SOC-001)
- [ ] Attribution to original strategy creator
- [ ] Privacy controls for copying (allow/disallow)

## Subtasks

- [ ] Backend Development
  - [ ] Create database schema for strategy_copies table
  - [ ] Implement copy strategy API endpoints
    - [ ] POST /api/strategies/:id/copy - Copy a strategy
    - [ ] DELETE /api/strategies/:id/copy - Stop copying
    - [ ] GET /api/strategies/copies - Get user's copied strategies
    - [ ] GET /api/strategies/:id/copies - Get who copied this strategy
  - [ ] Add notification service for strategy updates
  - [ ] Implement change detection for strategy modifications
  - [ ] Build performance comparison calculator
  - [ ] Add privacy settings for copy permissions
- [ ] Frontend Development
  - [ ] Create copy strategy button component
  - [ ] Build copied strategies dashboard
  - [ ] Implement notification display for updates
  - [ ] Add performance comparison chart
  - [ ] Create copy management interface
  - [ ] Build notification preferences UI
- [ ] Notification System
  - [ ] Design notification templates for strategy changes
  - [ ] Implement immediate notification delivery
  - [ ] Create digest notifications for multiple updates
  - [ ] Add notification preferences storage
- [ ] Testing
  - [ ] Write unit tests for copy logic
  - [ ] Add integration tests for notifications
  - [ ] Create E2E tests for copy workflow
  - [ ] Test performance comparison accuracy
  - [ ] Validate privacy controls

## Implementation Details

### Copy Trading Service (TypeScript)

```typescript
// services/CopyTradingService.ts
import { NotificationService } from './NotificationService';

export interface StrategyCopy {
  id: string;
  originalStrategyId: string;
  userId: string;
  copiedAt: Date;
  lastSyncedAt: Date;
  performanceDiff: number;
  status: 'active' | 'paused' | 'stopped';
}

export interface PerformanceComparison {
  originalReturn: number;
  copiedReturn: number;
  difference: number;
  lastUpdated: Date;
}

export class CopyTradingService {
  private notificationService: NotificationService;

  constructor() {
    this.notificationService = new NotificationService();
  }

  async copyStrategy(userId: string, strategyId: string): Promise<StrategyCopy> {
    // Get original strategy
    const originalStrategy = await db.publishedStrategies.findUnique({
      where: { id: strategyId },
      include: {
        user: {
          select: {
            id: true,
            username: true,
            privacySettings: true
          }
        }
      }
    });

    if (!originalStrategy) {
      throw new Error('Strategy not found');
    }

    if (!originalStrategy.isPublic) {
      throw new Error('Cannot copy private strategy');
    }

    // Check privacy settings
    if (originalStrategy.user.privacySettings?.disableCopying) {
      throw new Error('Strategy copying is disabled by the author');
    }

    // Check if already copied
    const existingCopy = await db.strategyCopies.findUnique({
      where: {
        userId_originalStrategyId: {
          userId,
          originalStrategyId: strategyId
        }
      }
    });

    if (existingCopy) {
      throw new Error('Strategy already copied');
    }

    // Create copy record
    const copy = await db.strategyCopies.create({
      data: {
        originalStrategyId: strategyId,
        userId,
        copiedAt: new Date(),
        lastSyncedAt: new Date(),
        status: 'active',
        originalFilters: originalStrategy.filters,
        currentFilters: originalStrategy.filters
      }
    });

    // Increment copy count on original strategy
    await db.publishedStrategies.update({
      where: { id: strategyId },
      data: { copyCount: { increment: 1 } }
    });

    // Notify strategy author
    if (originalStrategy.user.id !== userId) {
      await this.notificationService.sendStrategyCopiedNotification({
        authorId: originalStrategy.user.id,
        copierId: userId,
        strategyId
      });
    }

    // Log activity
    await db.activities.create({
      data: {
        userId,
        type: 'STRATEGY_COPIED',
        metadata: { strategyId, originalAuthor: originalStrategy.user.username },
        createdAt: new Date()
      }
    });

    return copy;
  }

  async stopCopying(userId: string, strategyId: string): Promise<void> {
    const copy = await db.strategyCopies.findUnique({
      where: {
        userId_originalStrategyId: {
          userId,
          originalStrategyId: strategyId
        }
      }
    });

    if (!copy) {
      throw new Error('Strategy copy not found');
    }

    // Update status instead of deleting (for analytics)
    await db.strategyCopies.update({
      where: { id: copy.id },
      data: {
        status: 'stopped',
        stoppedAt: new Date()
      }
    });

    // Decrement copy count
    await db.publishedStrategies.update({
      where: { id: strategyId },
      data: { copyCount: { decrement: 1 } }
    });
  }

  async getCopiedStrategies(userId: string): Promise<Array<{
    copy: StrategyCopy;
    originalStrategy: any;
    performanceComparison: PerformanceComparison;
  }>> {
    const copies = await db.strategyCopies.findMany({
      where: {
        userId,
        status: 'active'
      },
      include: {
        originalStrategy: {
          include: {
            user: {
              select: {
                id: true,
                username: true,
                displayName: true,
                avatarUrl: true
              }
            }
          }
        }
      },
      orderBy: { copiedAt: 'desc' }
    });

    // Add performance comparison for each
    const results = await Promise.all(
      copies.map(async copy => {
        const comparison = await this.getPerformanceComparison(
          copy.originalStrategyId,
          userId
        );

        return {
          copy,
          originalStrategy: copy.originalStrategy,
          performanceComparison: comparison
        };
      })
    );

    return results;
  }

  async detectStrategyChanges(strategyId: string): Promise<void> {
    // Get current strategy state
    const currentStrategy = await db.publishedStrategies.findUnique({
      where: { id: strategyId },
      select: {
        id: true,
        filters: true,
        updatedAt: true,
        user: {
          select: {
            id: true,
            username: true,
            displayName: true
          }
        }
      }
    });

    if (!currentStrategy) return;

    // Get all active copies
    const copies = await db.strategyCopies.findMany({
      where: {
        originalStrategyId: strategyId,
        status: 'active'
      },
      include: {
        user: {
          select: {
            id: true,
            username: true,
            email: true,
            notificationPreferences: true
          }
        }
      }
    });

    // Check if strategy filters changed
    for (const copy of copies) {
      const hasChanged = JSON.stringify(copy.originalFilters) !==
                        JSON.stringify(currentStrategy.filters);

      if (hasChanged) {
        // Update copy record
        await db.strategyCopies.update({
          where: { id: copy.id },
          data: {
            originalFilters: currentStrategy.filters,
            hasUnsynced Changes: true,
            lastChangedAt: new Date()
          }
        });

        // Send notification
        await this.notificationService.sendStrategyUpdateNotification({
          userId: copy.user.id,
          strategyId,
          strategyName: currentStrategy.user.displayName + "'s Strategy",
          changes: this.describeChanges(copy.originalFilters, currentStrategy.filters)
        });
      }
    }
  }

  async syncCopiedStrategy(userId: string, strategyId: string): Promise<void> {
    const copy = await db.strategyCopies.findUnique({
      where: {
        userId_originalStrategyId: {
          userId,
          originalStrategyId: strategyId
        }
      }
    });

    if (!copy) {
      throw new Error('Strategy copy not found');
    }

    // Update sync status
    await db.strategyCopies.update({
      where: { id: copy.id },
      data: {
        currentFilters: copy.originalFilters,
        hasUnsyncedChanges: false,
        lastSyncedAt: new Date()
      }
    });
  }

  async getPerformanceComparison(
    strategyId: string,
    userId: string
  ): Promise<PerformanceComparison> {
    // Get original strategy performance
    const originalPerformance = await db.strategyPerformance.findFirst({
      where: { strategyId },
      orderBy: { date: 'desc' }
    });

    // Get user's copy performance (from their portfolio that uses copied filters)
    // This is simplified - actual implementation would track user's specific results
    const copiedPerformance = await this.getUserStrategyPerformance(userId, strategyId);

    const originalReturn = originalPerformance?.cumulativeReturn || 0;
    const copiedReturn = copiedPerformance || 0;

    return {
      originalReturn,
      copiedReturn,
      difference: copiedReturn - originalReturn,
      lastUpdated: new Date()
    };
  }

  private async getUserStrategyPerformance(
    userId: string,
    strategyId: string
  ): Promise<number> {
    // Placeholder - would calculate based on user's actual portfolio performance
    // using the copied strategy filters
    return 0;
  }

  private describeChanges(oldFilters: any, newFilters: any): string {
    // Simple change description
    // In production, would provide detailed field-by-field comparison
    const changes: string[] = [];

    Object.keys(newFilters).forEach(key => {
      if (JSON.stringify(oldFilters[key]) !== JSON.stringify(newFilters[key])) {
        changes.push(`${key} updated`);
      }
    });

    return changes.join(', ') || 'Strategy parameters updated';
  }
}
```

### Notification Templates

```typescript
// services/notifications/StrategyNotifications.ts
export class StrategyNotificationTemplates {
  static strategyCopied(params: {
    copierId: string;
    copierName: string;
    strategyName: string;
  }): NotificationData {
    return {
      title: 'Your strategy was copied',
      message: `${params.copierName} copied your strategy "${params.strategyName}"`,
      type: 'STRATEGY_COPIED',
      actionUrl: `/strategies/${params.strategyName}`,
      icon: 'copy'
    };
  }

  static strategyUpdated(params: {
    authorName: string;
    strategyName: string;
    changes: string;
  }): NotificationData {
    return {
      title: 'Copied strategy updated',
      message: `${params.authorName} updated their strategy "${params.strategyName}". Changes: ${params.changes}`,
      type: 'STRATEGY_UPDATED',
      actionUrl: `/strategies/copies`,
      priority: 'high',
      actionButtons: [
        { label: 'View Changes', action: 'view' },
        { label: 'Sync Now', action: 'sync' }
      ]
    };
  }

  static strategyRebalanceRecommended(params: {
    strategyName: string;
    performanceDiff: number;
  }): NotificationData {
    return {
      title: 'Rebalance recommended',
      message: `Your copied strategy "${params.strategyName}" has diverged from the original. Performance difference: ${params.performanceDiff > 0 ? '+' : ''}${params.performanceDiff.toFixed(2)}%`,
      type: 'REBALANCE_RECOMMENDED',
      actionUrl: `/strategies/copies`,
      priority: 'medium'
    };
  }
}
```

## Testing Strategy

### Unit Tests

```typescript
describe('CopyTradingService', () => {
  let service: CopyTradingService;

  beforeEach(() => {
    service = new CopyTradingService();
  });

  describe('copyStrategy', () => {
    it('should create strategy copy successfully', async () => {
      const userId = 'user-1';
      const strategyId = 'strategy-1';

      mockDb.publishedStrategies.findUnique.mockResolvedValue({
        id: strategyId,
        isPublic: true,
        user: { id: 'author-1', privacySettings: {} },
        filters: { marketCap: { min: 1000000 } }
      });

      const result = await service.copyStrategy(userId, strategyId);

      expect(result).toHaveProperty('id');
      expect(result.status).toBe('active');
      expect(mockDb.strategyCopies.create).toHaveBeenCalled();
    });

    it('should reject copying private strategies', async () => {
      mockDb.publishedStrategies.findUnique.mockResolvedValue({
        id: 'strategy-1',
        isPublic: false,
        user: { id: 'author-1' }
      });

      await expect(
        service.copyStrategy('user-1', 'strategy-1')
      ).rejects.toThrow('Cannot copy private strategy');
    });

    it('should respect author copy permissions', async () => {
      mockDb.publishedStrategies.findUnique.mockResolvedValue({
        id: 'strategy-1',
        isPublic: true,
        user: {
          id: 'author-1',
          privacySettings: { disableCopying: true }
        }
      });

      await expect(
        service.copyStrategy('user-1', 'strategy-1')
      ).rejects.toThrow('Strategy copying is disabled');
    });
  });

  describe('detectStrategyChanges', () => {
    it('should detect filter changes and notify copiers', async () => {
      const strategyId = 'strategy-1';
      const oldFilters = { marketCap: { min: 1000000 } };
      const newFilters = { marketCap: { min: 5000000 } };

      mockDb.publishedStrategies.findUnique.mockResolvedValue({
        id: strategyId,
        filters: newFilters,
        user: { id: 'author-1', displayName: 'Author' }
      });

      mockDb.strategyCopies.findMany.mockResolvedValue([{
        id: 'copy-1',
        userId: 'user-1',
        originalFilters: oldFilters,
        user: { id: 'user-1', notificationPreferences: {} }
      }]);

      await service.detectStrategyChanges(strategyId);

      expect(mockDb.strategyCopies.update).toHaveBeenCalled();
    });
  });
});
```

### Integration Tests

```typescript
describe('Copy Trading Integration', () => {
  let app: Express;
  let user: User;
  let strategy: Strategy;

  beforeAll(async () => {
    app = await createTestApp();
    user = await createTestUser();
    strategy = await createTestStrategy();
  });

  it('should complete copy workflow', async () => {
    // Copy strategy
    const copyResponse = await request(app)
      .post(`/api/strategies/${strategy.id}/copy`)
      .set('Authorization', `Bearer ${user.token}`);

    expect(copyResponse.status).toBe(201);

    // Get copied strategies
    const copiesResponse = await request(app)
      .get('/api/strategies/copies')
      .set('Authorization', `Bearer ${user.token}`);

    expect(copiesResponse.body).toContainEqual(
      expect.objectContaining({
        originalStrategyId: strategy.id
      })
    );

    // Stop copying
    const stopResponse = await request(app)
      .delete(`/api/strategies/${strategy.id}/copy`)
      .set('Authorization', `Bearer ${user.token}`);

    expect(stopResponse.status).toBe(200);
  });
});
```

### E2E Tests

```typescript
describe('Copy Trading E2E', () => {
  it('should copy strategy and receive notifications', async () => {
    await page.goto(`/strategies/${strategyId}`);

    // Copy strategy
    await page.click('[data-testid="copy-strategy-button"]');
    await page.click('[data-testid="confirm-copy"]');

    // Verify success message
    await page.waitForSelector('[data-testid="copy-success"]');

    // Navigate to copied strategies
    await page.goto('/strategies/copies');

    // Verify strategy appears
    expect(await page.textContent('body')).toContain('Test Strategy');

    // Check for update notification (simulate strategy change)
    // This would require backend setup to trigger notification
  });
});
```

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Users confused by notification-only approach | Medium | Low | Clear UI messaging, tutorial on first copy, explain manual sync required |
| Notification fatigue from frequent updates | Medium | Medium | Batch notifications, allow digest mode, user preferences for frequency |
| Performance tracking inaccuracy | Low | Medium | Clear disclaimer, track user's actual execution, not theoretical |
| Privacy concerns about who copied strategies | Low | Low | Make copier list private by default, allow opt-in visibility |
| Strategy authors disabling copying | Low | Low | Make copying enabled by default, explain benefits of sharing |

## Performance Requirements

- **Copy Strategy Action**: < 200ms
- **Get Copied Strategies**: < 300ms
- **Performance Comparison Calculation**: < 500ms
- **Change Detection Job**: < 10 seconds for all strategies
- **Notification Delivery**: < 1 second
- **API Rate Limits**: 100 copy actions per user per day

## Security Considerations

### Privacy Controls

- Strategy authors can disable copying
- Copier lists can be made private
- Only public strategies can be copied
- Attribution always maintained to original author

### Data Protection

- Copied strategy filters stored separately
- User cannot claim copied strategy as original
- Clear indication of original author in UI
- Audit trail of all copy actions

## Error Handling

```typescript
app.post('/api/strategies/:id/copy', async (req, res) => {
  try {
    const userId = req.user.id;
    const strategyId = req.params.id;

    const copy = await copyTradingService.copyStrategy(userId, strategyId);
    res.status(201).json(copy);

  } catch (error) {
    if (error.message === 'Strategy not found') {
      return res.status(404).json({
        error: 'STRATEGY_NOT_FOUND',
        message: 'The strategy you are trying to copy does not exist'
      });
    }

    if (error.message.includes('private strategy')) {
      return res.status(403).json({
        error: 'PRIVATE_STRATEGY',
        message: 'This strategy is private and cannot be copied'
      });
    }

    if (error.message.includes('copying is disabled')) {
      return res.status(403).json({
        error: 'COPYING_DISABLED',
        message: 'The strategy author has disabled copying'
      });
    }

    if (error.message === 'Strategy already copied') {
      return res.status(409).json({
        error: 'ALREADY_COPIED',
        message: 'You have already copied this strategy'
      });
    }

    console.error('Copy strategy error:', error);
    res.status(500).json({
      error: 'INTERNAL_ERROR',
      message: 'Failed to copy strategy'
    });
  }
});
```

## Database Schema

```sql
CREATE TABLE strategy_copies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    original_strategy_id UUID REFERENCES published_strategies(id) ON DELETE CASCADE,
    original_filters JSONB NOT NULL,
    current_filters JSONB NOT NULL,
    status VARCHAR(20) DEFAULT 'active',
    has_unsynced_changes BOOLEAN DEFAULT false,
    copied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_synced_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_changed_at TIMESTAMP,
    stopped_at TIMESTAMP,

    UNIQUE(user_id, original_strategy_id)
);

CREATE INDEX idx_strategy_copies_user ON strategy_copies(user_id, status);
CREATE INDEX idx_strategy_copies_strategy ON strategy_copies(original_strategy_id, status);
CREATE INDEX idx_strategy_copies_unsynced ON strategy_copies(user_id) WHERE has_unsynced_changes = true;
```

## Dependencies

- SOC-001: Strategy Publishing System (for base strategy data)
- SOC-002: User Follow System (for suggested strategies to copy)
- Notification service (for update alerts)
- Performance tracking service

## References

- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 4: Social & Community Features
- [Notification System](../../services/notifications.md) - Notification delivery
- [Privacy Controls](../../security/privacy.md) - User privacy settings

## Notes

### Implementation Tips

1. Start with notification-only approach - no automatic execution
2. Clear messaging that users must manually apply updates
3. Track performance comparison to show value of following original
4. Make copying easy with one-click action
5. Provide clear attribution to original strategy creator
6. Consider weekly digest of all strategy updates

### Future Enhancements

- Automatic trade execution (full copy trading)
- Partial copying (copy with modifications)
- Copy with custom risk adjustment
- Portfolio allocation to multiple copied strategies
- Copy trading analytics dashboard
- Strategy marketplace with paid strategies
- Social proof (show how many people copied)
- Copy trader rankings and reviews

### Technical Debt

- Performance tracking is simplified in MVP
- Consider separate microservice for copy trading at scale
- Evaluate real-time sync vs. batch notifications
- Plan for automatic execution infrastructure

## Progress

**0% - Not started**
