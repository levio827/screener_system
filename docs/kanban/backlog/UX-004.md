# UX-004: Advanced Chart Features

## Metadata

| Field | Value |
|-------|-------|
| **ID** | UX-004 |
| **Title** | Enhance Chart with Drawing Tools |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P2 (Medium) |
| **Estimate** | 16 hours |
| **Sprint** | Sprint 7 |
| **Epic** | UX/UI Enhancements |
| **Assignee** | TBD |
| **Created** | 2025-11-29 |
| **Updated** | 2025-11-30 |
| **Tags** | `charts`, `trading-tools`, `technical-analysis`, `canvas`, `ui/ux` |
| **Blocks** | None |
| **Blocked By** | None |
| **Related** | UX-002 (Dark mode theme integration) |

## Description

Implement TradingView-style chart drawing tools and technical analysis features, allowing users to add trendlines, indicators, and annotations directly on stock charts. This will provide professional-grade technical analysis capabilities.

## Progress

**0% - Not started**

## Acceptance Criteria

- [ ] Trendline drawing
- [ ] Horizontal/vertical lines
- [ ] Fibonacci retracement
- [ ] Rectangle/circle area marking
- [ ] Text annotations
- [ ] Drawing save/load
- [ ] Indicator overlay customization

## Detailed Subtasks

### 1. Drawing Layer Architecture
- [ ] Set up Canvas-based drawing system
  - [ ] Create overlay canvas for drawings
  - [ ] Implement coordinate transformation (chart â†” canvas)
  - [ ] Handle retina display support
- [ ] Drawing state management
  - [ ] Define drawing object data structures
  - [ ] Implement undo/redo stack
  - [ ] Handle drawing serialization
- [ ] Event handling system
  - [ ] Mouse/touch event listeners
  - [ ] Drawing mode state machine
  - [ ] Hit detection for selection

### 2. Trendline Tool
- [ ] Implement trendline drawing
  - [ ] Click-and-drag to create line
  - [ ] Snap to candle high/low points
  - [ ] Extend line beyond visible range
- [ ] Trendline editing
  - [ ] Move endpoints by dragging
  - [ ] Adjust angle and length
  - [ ] Delete selected trendline
- [ ] Visual customization
  - [ ] Line color picker
  - [ ] Line style (solid, dashed, dotted)
  - [ ] Line width adjustment
  - [ ] Add extension rays

### 3. Horizontal & Vertical Lines
- [ ] Horizontal line (support/resistance)
  - [ ] Click to place at price level
  - [ ] Drag to adjust price
  - [ ] Show price label
  - [ ] Extend across entire chart
- [ ] Vertical line (time marker)
  - [ ] Click to place at timestamp
  - [ ] Drag to adjust time
  - [ ] Show date/time label
  - [ ] Extend across price range
- [ ] Interactive features
  - [ ] Hover to highlight
  - [ ] Right-click context menu
  - [ ] Clone/duplicate lines

### 4. Fibonacci Retracement
- [ ] Fibonacci drawing tool
  - [ ] Two-point placement (swing high/low)
  - [ ] Auto-calculate retracement levels
  - [ ] Display level percentages (0%, 23.6%, 38.2%, 50%, 61.8%, 100%)
- [ ] Level customization
  - [ ] Add/remove custom levels
  - [ ] Change level colors
  - [ ] Toggle level visibility
  - [ ] Reverse direction
- [ ] Additional Fibonacci tools
  - [ ] Fibonacci extension
  - [ ] Fibonacci fan
  - [ ] Fibonacci arcs (optional)

### 5. Shape Tools
- [ ] Rectangle tool
  - [ ] Drag to create rectangular area
  - [ ] Highlight price/time zones
  - [ ] Adjustable corners
  - [ ] Fill color and opacity
- [ ] Circle/Ellipse tool
  - [ ] Drag from center or corner
  - [ ] Proportional or free-form
  - [ ] Border and fill styling
- [ ] Shape editing
  - [ ] Resize handles
  - [ ] Rotation (for ellipse)
  - [ ] Layer ordering (bring to front/back)

### 6. Text Annotations
- [ ] Text tool implementation
  - [ ] Click to place text
  - [ ] Inline editing
  - [ ] Multi-line support
- [ ] Text formatting
  - [ ] Font size adjustment
  - [ ] Font family selection
  - [ ] Bold, italic, underline
  - [ ] Text color picker
  - [ ] Background color/padding
- [ ] Text positioning
  - [ ] Anchor to price/time
  - [ ] Drag to reposition
  - [ ] Auto-fit background box

### 7. Drawing Persistence
- [ ] Save drawings to storage
  - [ ] Serialize drawings to JSON
  - [ ] Store in localStorage per symbol
  - [ ] Optional cloud sync
- [ ] Load drawings on chart open
  - [ ] Deserialize from storage
  - [ ] Validate drawing data
  - [ ] Handle coordinate scaling
- [ ] Import/Export features
  - [ ] Export drawings as JSON file
  - [ ] Import drawings from file
  - [ ] Share drawings via URL

### 8. Indicator Overlays
- [ ] Moving averages
  - [ ] SMA (Simple Moving Average)
  - [ ] EMA (Exponential Moving Average)
  - [ ] WMA (Weighted Moving Average)
  - [ ] Customizable periods
- [ ] Bollinger Bands
  - [ ] Standard deviation bands
  - [ ] Customizable periods and multipliers
- [ ] Volume indicators
  - [ ] Volume bars
  - [ ] Volume MA overlay
  - [ ] OBV (On-Balance Volume)
- [ ] Indicator customization
  - [ ] Color and line style
  - [ ] Toggle visibility
  - [ ] Parameter adjustment UI

## Implementation Details

### Drawing Object Types

```typescript
// src/types/chart-drawings.ts

export type DrawingType =
  | 'trendline'
  | 'horizontal-line'
  | 'vertical-line'
  | 'fibonacci'
  | 'rectangle'
  | 'circle'
  | 'text';

export interface Point {
  x: number; // Canvas x coordinate
  y: number; // Canvas y coordinate
  time?: number; // Timestamp
  price?: number; // Price value
}

export interface DrawingStyle {
  color: string;
  lineWidth: number;
  lineStyle: 'solid' | 'dashed' | 'dotted';
  fillColor?: string;
  fillOpacity?: number;
}

export interface BaseDrawing {
  id: string;
  type: DrawingType;
  points: Point[];
  style: DrawingStyle;
  locked: boolean;
  visible: boolean;
  createdAt: number;
}

export interface TrendlineDrawing extends BaseDrawing {
  type: 'trendline';
  extendLeft: boolean;
  extendRight: boolean;
}

export interface HorizontalLineDrawing extends BaseDrawing {
  type: 'horizontal-line';
  price: number;
  showLabel: boolean;
}

export interface VerticalLineDrawing extends BaseDrawing {
  type: 'vertical-line';
  time: number;
  showLabel: boolean;
}

export interface FibonacciDrawing extends BaseDrawing {
  type: 'fibonacci';
  levels: Array<{
    value: number;
    label: string;
    color: string;
    visible: boolean;
  }>;
  reverse: boolean;
}

export interface RectangleDrawing extends BaseDrawing {
  type: 'rectangle';
}

export interface CircleDrawing extends BaseDrawing {
  type: 'circle';
  radius?: number;
}

export interface TextDrawing extends BaseDrawing {
  type: 'text';
  text: string;
  fontSize: number;
  fontFamily: string;
  bold: boolean;
  italic: boolean;
  backgroundColor?: string;
  padding: number;
}

export type Drawing =
  | TrendlineDrawing
  | HorizontalLineDrawing
  | VerticalLineDrawing
  | FibonacciDrawing
  | RectangleDrawing
  | CircleDrawing
  | TextDrawing;
```

### Drawing Manager

```typescript
// src/lib/chart/DrawingManager.ts

import { Drawing, Point, DrawingType } from '@/types/chart-drawings';
import { IChartApi, ISeriesApi } from 'lightweight-charts';

export class DrawingManager {
  private drawings: Map<string, Drawing> = new Map();
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private chart: IChartApi;
  private selectedDrawing: string | null = null;
  private currentTool: DrawingType | null = null;
  private isDrawing: boolean = false;
  private tempPoints: Point[] = [];

  constructor(canvas: HTMLCanvasElement, chart: IChartApi) {
    this.canvas = canvas;
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Failed to get canvas context');
    this.ctx = ctx;
    this.chart = chart;

    this.setupEventListeners();
  }

  private setupEventListeners(): void {
    this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
    this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
    this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
    this.canvas.addEventListener('dblclick', this.handleDoubleClick.bind(this));
  }

  setTool(tool: DrawingType | null): void {
    this.currentTool = tool;
    this.selectedDrawing = null;
    this.canvas.style.cursor = tool ? 'crosshair' : 'default';
  }

  private handleMouseDown(event: MouseEvent): void {
    if (!this.currentTool) {
      this.checkSelection(event);
      return;
    }

    this.isDrawing = true;
    const point = this.getPointFromEvent(event);
    this.tempPoints = [point];
  }

  private handleMouseMove(event: MouseEvent): void {
    if (!this.isDrawing) {
      this.updateCursor(event);
      return;
    }

    const point = this.getPointFromEvent(event);

    if (this.tempPoints.length === 1) {
      this.tempPoints[1] = point;
    }

    this.render();
  }

  private handleMouseUp(event: MouseEvent): void {
    if (!this.isDrawing || !this.currentTool) return;

    const point = this.getPointFromEvent(event);
    this.tempPoints.push(point);

    // Create drawing based on tool type
    const drawing = this.createDrawing(this.currentTool, this.tempPoints);
    this.addDrawing(drawing);

    this.isDrawing = false;
    this.tempPoints = [];
    this.render();
  }

  private handleDoubleClick(event: MouseEvent): void {
    // Used for multi-point drawings like polygons
  }

  private getPointFromEvent(event: MouseEvent): Point {
    const rect = this.canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    // Convert canvas coordinates to chart coordinates
    const timeScale = this.chart.timeScale();
    const priceScale = (this.chart as any).priceScale();

    const time = timeScale.coordinateToTime(x);
    const price = priceScale.coordinateToPrice(y);

    return { x, y, time: time as number, price };
  }

  private createDrawing(type: DrawingType, points: Point[]): Drawing {
    const id = `${type}_${Date.now()}`;
    const baseDrawing = {
      id,
      points,
      style: {
        color: '#2196f3',
        lineWidth: 2,
        lineStyle: 'solid' as const,
      },
      locked: false,
      visible: true,
      createdAt: Date.now(),
    };

    switch (type) {
      case 'trendline':
        return {
          ...baseDrawing,
          type: 'trendline',
          extendLeft: false,
          extendRight: true,
        };

      case 'horizontal-line':
        return {
          ...baseDrawing,
          type: 'horizontal-line',
          price: points[0].price!,
          showLabel: true,
        };

      case 'vertical-line':
        return {
          ...baseDrawing,
          type: 'vertical-line',
          time: points[0].time!,
          showLabel: true,
        };

      case 'fibonacci':
        return {
          ...baseDrawing,
          type: 'fibonacci',
          levels: [
            { value: 0, label: '0%', color: '#2196f3', visible: true },
            { value: 0.236, label: '23.6%', color: '#ff9800', visible: true },
            { value: 0.382, label: '38.2%', color: '#4caf50', visible: true },
            { value: 0.5, label: '50%', color: '#f44336', visible: true },
            { value: 0.618, label: '61.8%', color: '#9c27b0', visible: true },
            { value: 1, label: '100%', color: '#2196f3', visible: true },
          ],
          reverse: false,
        };

      case 'rectangle':
        return {
          ...baseDrawing,
          type: 'rectangle',
          style: {
            ...baseDrawing.style,
            fillColor: '#2196f3',
            fillOpacity: 0.1,
          },
        };

      case 'circle':
        return {
          ...baseDrawing,
          type: 'circle',
          style: {
            ...baseDrawing.style,
            fillColor: '#2196f3',
            fillOpacity: 0.1,
          },
        };

      case 'text':
        return {
          ...baseDrawing,
          type: 'text',
          text: 'Double-click to edit',
          fontSize: 14,
          fontFamily: 'Arial',
          bold: false,
          italic: false,
          padding: 4,
        };

      default:
        throw new Error(`Unknown drawing type: ${type}`);
    }
  }

  addDrawing(drawing: Drawing): void {
    this.drawings.set(drawing.id, drawing);
  }

  removeDrawing(id: string): void {
    this.drawings.delete(id);
    this.render();
  }

  getDrawing(id: string): Drawing | undefined {
    return this.drawings.get(id);
  }

  getAllDrawings(): Drawing[] {
    return Array.from(this.drawings.values());
  }

  clearAll(): void {
    this.drawings.clear();
    this.render();
  }

  render(): void {
    // Clear canvas
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    // Render all drawings
    for (const drawing of this.drawings.values()) {
      if (!drawing.visible) continue;
      this.renderDrawing(drawing);
    }

    // Render temp drawing
    if (this.isDrawing && this.tempPoints.length >= 2 && this.currentTool) {
      const tempDrawing = this.createDrawing(this.currentTool, this.tempPoints);
      this.renderDrawing(tempDrawing);
    }
  }

  private renderDrawing(drawing: Drawing): void {
    this.ctx.save();

    // Apply style
    this.ctx.strokeStyle = drawing.style.color;
    this.ctx.lineWidth = drawing.style.lineWidth;

    switch (drawing.style.lineStyle) {
      case 'dashed':
        this.ctx.setLineDash([5, 5]);
        break;
      case 'dotted':
        this.ctx.setLineDash([2, 2]);
        break;
      default:
        this.ctx.setLineDash([]);
    }

    // Render based on type
    switch (drawing.type) {
      case 'trendline':
        this.renderTrendline(drawing as TrendlineDrawing);
        break;
      case 'horizontal-line':
        this.renderHorizontalLine(drawing as HorizontalLineDrawing);
        break;
      case 'vertical-line':
        this.renderVerticalLine(drawing as VerticalLineDrawing);
        break;
      case 'fibonacci':
        this.renderFibonacci(drawing as FibonacciDrawing);
        break;
      case 'rectangle':
        this.renderRectangle(drawing as RectangleDrawing);
        break;
      case 'circle':
        this.renderCircle(drawing as CircleDrawing);
        break;
      case 'text':
        this.renderText(drawing as TextDrawing);
        break;
    }

    this.ctx.restore();
  }

  private renderTrendline(drawing: TrendlineDrawing): void {
    if (drawing.points.length < 2) return;

    const [p1, p2] = drawing.points;

    this.ctx.beginPath();
    this.ctx.moveTo(p1.x, p1.y);
    this.ctx.lineTo(p2.x, p2.y);
    this.ctx.stroke();

    // Draw selection handles if selected
    if (this.selectedDrawing === drawing.id) {
      this.drawHandle(p1.x, p1.y);
      this.drawHandle(p2.x, p2.y);
    }
  }

  private renderHorizontalLine(drawing: HorizontalLineDrawing): void {
    const y = drawing.points[0].y;

    this.ctx.beginPath();
    this.ctx.moveTo(0, y);
    this.ctx.lineTo(this.canvas.width, y);
    this.ctx.stroke();

    // Draw price label
    if (drawing.showLabel) {
      const price = drawing.price.toFixed(2);
      this.drawLabel(this.canvas.width - 60, y, price);
    }
  }

  private renderVerticalLine(drawing: VerticalLineDrawing): void {
    const x = drawing.points[0].x;

    this.ctx.beginPath();
    this.ctx.moveTo(x, 0);
    this.ctx.lineTo(x, this.canvas.height);
    this.ctx.stroke();

    // Draw time label
    if (drawing.showLabel) {
      const date = new Date(drawing.time * 1000);
      const label = date.toLocaleDateString();
      this.drawLabel(x, this.canvas.height - 20, label);
    }
  }

  private renderFibonacci(drawing: FibonacciDrawing): void {
    if (drawing.points.length < 2) return;

    const [p1, p2] = drawing.points;
    const diff = p2.y - p1.y;

    drawing.levels.forEach(level => {
      if (!level.visible) return;

      const y = p1.y + diff * level.value;

      this.ctx.save();
      this.ctx.strokeStyle = level.color;
      this.ctx.globalAlpha = 0.5;

      this.ctx.beginPath();
      this.ctx.moveTo(p1.x, y);
      this.ctx.lineTo(p2.x, y);
      this.ctx.stroke();

      this.ctx.restore();

      // Draw level label
      this.drawLabel(p2.x + 5, y, level.label);
    });
  }

  private renderRectangle(drawing: RectangleDrawing): void {
    if (drawing.points.length < 2) return;

    const [p1, p2] = drawing.points;
    const width = p2.x - p1.x;
    const height = p2.y - p1.y;

    // Fill
    if (drawing.style.fillColor) {
      this.ctx.globalAlpha = drawing.style.fillOpacity || 0.1;
      this.ctx.fillStyle = drawing.style.fillColor;
      this.ctx.fillRect(p1.x, p1.y, width, height);
      this.ctx.globalAlpha = 1;
    }

    // Stroke
    this.ctx.strokeRect(p1.x, p1.y, width, height);
  }

  private renderCircle(drawing: CircleDrawing): void {
    if (drawing.points.length < 2) return;

    const [center, edge] = drawing.points;
    const radius = Math.sqrt(
      Math.pow(edge.x - center.x, 2) + Math.pow(edge.y - center.y, 2)
    );

    this.ctx.beginPath();
    this.ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);

    // Fill
    if (drawing.style.fillColor) {
      this.ctx.globalAlpha = drawing.style.fillOpacity || 0.1;
      this.ctx.fillStyle = drawing.style.fillColor;
      this.ctx.fill();
      this.ctx.globalAlpha = 1;
    }

    this.ctx.stroke();
  }

  private renderText(drawing: TextDrawing): void {
    const point = drawing.points[0];

    this.ctx.font = `${drawing.bold ? 'bold ' : ''}${drawing.italic ? 'italic ' : ''}${drawing.fontSize}px ${drawing.fontFamily}`;

    // Measure text
    const metrics = this.ctx.measureText(drawing.text);
    const width = metrics.width + drawing.padding * 2;
    const height = drawing.fontSize + drawing.padding * 2;

    // Draw background
    if (drawing.backgroundColor) {
      this.ctx.fillStyle = drawing.backgroundColor;
      this.ctx.fillRect(
        point.x,
        point.y - height / 2,
        width,
        height
      );
    }

    // Draw text
    this.ctx.fillStyle = drawing.style.color;
    this.ctx.textBaseline = 'middle';
    this.ctx.fillText(
      drawing.text,
      point.x + drawing.padding,
      point.y
    );
  }

  private drawHandle(x: number, y: number): void {
    this.ctx.fillStyle = '#ffffff';
    this.ctx.strokeStyle = '#2196f3';
    this.ctx.lineWidth = 2;

    this.ctx.beginPath();
    this.ctx.arc(x, y, 5, 0, 2 * Math.PI);
    this.ctx.fill();
    this.ctx.stroke();
  }

  private drawLabel(x: number, y: number, text: string): void {
    this.ctx.save();

    this.ctx.fillStyle = 'rgba(33, 33, 33, 0.8)';
    this.ctx.fillRect(x - 2, y - 12, text.length * 7 + 4, 16);

    this.ctx.fillStyle = '#ffffff';
    this.ctx.font = '12px Arial';
    this.ctx.textBaseline = 'top';
    this.ctx.fillText(text, x, y - 10);

    this.ctx.restore();
  }

  private checkSelection(event: MouseEvent): void {
    const point = this.getPointFromEvent(event);

    for (const [id, drawing] of this.drawings.entries()) {
      if (this.isPointNearDrawing(point, drawing)) {
        this.selectedDrawing = id;
        this.render();
        return;
      }
    }

    this.selectedDrawing = null;
    this.render();
  }

  private isPointNearDrawing(point: Point, drawing: Drawing): boolean {
    const threshold = 10; // pixels

    switch (drawing.type) {
      case 'trendline':
        return this.isPointNearLine(point, drawing.points[0], drawing.points[1], threshold);

      case 'horizontal-line':
        return Math.abs(point.y - drawing.points[0].y) < threshold;

      case 'vertical-line':
        return Math.abs(point.x - drawing.points[0].x) < threshold;

      default:
        return false;
    }
  }

  private isPointNearLine(point: Point, p1: Point, p2: Point, threshold: number): boolean {
    // Calculate distance from point to line segment
    const A = point.x - p1.x;
    const B = point.y - p1.y;
    const C = p2.x - p1.x;
    const D = p2.y - p1.y;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;

    if (lenSq !== 0) param = dot / lenSq;

    let xx, yy;

    if (param < 0) {
      xx = p1.x;
      yy = p1.y;
    } else if (param > 1) {
      xx = p2.x;
      yy = p2.y;
    } else {
      xx = p1.x + param * C;
      yy = p1.y + param * D;
    }

    const dx = point.x - xx;
    const dy = point.y - yy;
    return Math.sqrt(dx * dx + dy * dy) < threshold;
  }

  private updateCursor(event: MouseEvent): void {
    const point = this.getPointFromEvent(event);
    let cursor = 'default';

    for (const drawing of this.drawings.values()) {
      if (this.isPointNearDrawing(point, drawing)) {
        cursor = 'pointer';
        break;
      }
    }

    this.canvas.style.cursor = cursor;
  }

  // Serialization methods
  serialize(): string {
    const data = {
      drawings: Array.from(this.drawings.values()),
      version: '1.0',
    };
    return JSON.stringify(data);
  }

  deserialize(json: string): void {
    try {
      const data = JSON.parse(json);
      this.drawings.clear();

      data.drawings.forEach((drawing: Drawing) => {
        this.drawings.set(drawing.id, drawing);
      });

      this.render();
    } catch (error) {
      console.error('Failed to deserialize drawings:', error);
    }
  }

  saveToStorage(symbol: string): void {
    const key = `chart_drawings_${symbol}`;
    const data = this.serialize();
    localStorage.setItem(key, data);
  }

  loadFromStorage(symbol: string): void {
    const key = `chart_drawings_${symbol}`;
    const data = localStorage.getItem(key);

    if (data) {
      this.deserialize(data);
    }
  }
}
```

### React Integration Component

```typescript
// src/components/StockChart/ChartWithDrawings.tsx

import React, { useRef, useEffect, useState } from 'react';
import { createChart, IChartApi } from 'lightweight-charts';
import { DrawingManager } from '@/lib/chart/DrawingManager';
import { DrawingType } from '@/types/chart-drawings';
import { DrawingToolbar } from './DrawingToolbar';
import { useTheme } from '@/contexts/ThemeContext';
import { getChartTheme } from '@/utils/chart-theme';

interface ChartWithDrawingsProps {
  symbol: string;
  data: any[];
}

export const ChartWithDrawings: React.FC<ChartWithDrawingsProps> = ({
  symbol,
  data
}) => {
  const chartContainerRef = useRef<HTMLDivElement>(null);
  const drawingCanvasRef = useRef<HTMLCanvasElement>(null);
  const chartRef = useRef<IChartApi | null>(null);
  const drawingManagerRef = useRef<DrawingManager | null>(null);
  const [selectedTool, setSelectedTool] = useState<DrawingType | null>(null);
  const { theme } = useTheme();

  // Initialize chart and drawing manager
  useEffect(() => {
    if (!chartContainerRef.current || !drawingCanvasRef.current) return;

    // Create chart
    const chart = createChart(chartContainerRef.current, {
      ...getChartTheme(theme),
      width: chartContainerRef.current.clientWidth,
      height: 600,
    });

    chartRef.current = chart;

    // Create drawing manager
    const drawingManager = new DrawingManager(drawingCanvasRef.current, chart);
    drawingManagerRef.current = drawingManager;

    // Load saved drawings
    drawingManager.loadFromStorage(symbol);

    // Cleanup
    return () => {
      chart.remove();
    };
  }, [symbol, theme]);

  // Update data
  useEffect(() => {
    if (!chartRef.current || !data) return;

    const candlestickSeries = chartRef.current.addCandlestickSeries();
    candlestickSeries.setData(data);
  }, [data]);

  // Handle tool selection
  const handleToolSelect = (tool: DrawingType | null) => {
    setSelectedTool(tool);
    drawingManagerRef.current?.setTool(tool);
  };

  // Save drawings
  const handleSave = () => {
    drawingManagerRef.current?.saveToStorage(symbol);
  };

  // Clear all drawings
  const handleClear = () => {
    if (confirm('Are you sure you want to clear all drawings?')) {
      drawingManagerRef.current?.clearAll();
      drawingManagerRef.current?.saveToStorage(symbol);
    }
  };

  return (
    <div className="chart-with-drawings">
      <DrawingToolbar
        selectedTool={selectedTool}
        onToolSelect={handleToolSelect}
        onSave={handleSave}
        onClear={handleClear}
      />

      <div className="chart-container" style={{ position: 'relative' }}>
        <div ref={chartContainerRef} />
        <canvas
          ref={drawingCanvasRef}
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            pointerEvents: 'auto',
          }}
        />
      </div>
    </div>
  );
};
```

## Testing Strategy

### Unit Tests

```typescript
// __tests__/lib/DrawingManager.test.ts

import { DrawingManager } from '@/lib/chart/DrawingManager';

describe('DrawingManager', () => {
  let canvas: HTMLCanvasElement;
  let chart: any; // Mock IChartApi
  let manager: DrawingManager;

  beforeEach(() => {
    canvas = document.createElement('canvas');
    chart = {
      timeScale: jest.fn(() => ({
        coordinateToTime: jest.fn(),
      })),
      priceScale: jest.fn(() => ({
        coordinateToPrice: jest.fn(),
      })),
    };

    manager = new DrawingManager(canvas, chart);
  });

  it('creates trendline drawing', () => {
    manager.setTool('trendline');

    const drawing = manager.createDrawing('trendline', [
      { x: 100, y: 100, time: 1234567890, price: 150.0 },
      { x: 200, y: 50, time: 1234567900, price: 155.0 },
    ]);

    expect(drawing.type).toBe('trendline');
    expect(drawing.points).toHaveLength(2);
  });

  it('serializes and deserializes drawings', () => {
    const drawing = manager.createDrawing('horizontal-line', [
      { x: 100, y: 100, time: 1234567890, price: 150.0 },
    ]);

    manager.addDrawing(drawing);

    const json = manager.serialize();
    expect(json).toContain('horizontal-line');

    manager.clearAll();
    expect(manager.getAllDrawings()).toHaveLength(0);

    manager.deserialize(json);
    expect(manager.getAllDrawings()).toHaveLength(1);
  });
});
```

### Integration Tests

```typescript
// __tests__/integration/chart-drawings.test.tsx

import { render, screen, fireEvent } from '@testing-library/react';
import { ChartWithDrawings } from '@/components/StockChart/ChartWithDrawings';

describe('Chart Drawings Integration', () => {
  const mockData = [
    { time: '2024-01-01', open: 100, high: 105, low: 98, close: 103 },
    { time: '2024-01-02', open: 103, high: 107, low: 101, close: 106 },
  ];

  it('renders drawing toolbar', () => {
    render(<ChartWithDrawings symbol="AAPL" data={mockData} />);

    expect(screen.getByText(/Trendline/i)).toBeInTheDocument();
    expect(screen.getByText(/Horizontal Line/i)).toBeInTheDocument();
  });

  it('activates drawing tool on click', () => {
    render(<ChartWithDrawings symbol="AAPL" data={mockData} />);

    const trendlineButton = screen.getByText(/Trendline/i);
    fireEvent.click(trendlineButton);

    // Verify tool is selected
    expect(trendlineButton).toHaveClass('selected');
  });
});
```

### E2E Tests

```typescript
// e2e/chart-drawings.spec.ts

import { test, expect } from '@playwright/test';

test.describe('Chart Drawing Tools', () => {
  test('draws trendline on chart', async ({ page }) => {
    await page.goto('/stocks/AAPL');

    // Select trendline tool
    await page.click('button:has-text("Trendline")');

    // Draw trendline
    const canvas = page.locator('canvas').first();
    await canvas.click({ position: { x: 100, y: 200 } });
    await canvas.click({ position: { x: 300, y: 100 } });

    // Verify drawing was created
    await page.click('button:has-text("Save")');

    // Reload and verify persistence
    await page.reload();
    // Drawing should still be visible (test via screenshot comparison)
  });

  test('adds Fibonacci retracement', async ({ page }) => {
    await page.goto('/stocks/AAPL');

    await page.click('button:has-text("Fibonacci")');

    const canvas = page.locator('canvas').first();
    await canvas.click({ position: { x: 100, y: 250 } });
    await canvas.click({ position: { x: 300, y: 50 } });

    // Verify Fibonacci levels are visible
    await expect(page.locator('text=61.8%')).toBeVisible();
  });
});
```

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation Strategy | Owner |
|------|------------|--------|-------------------|-------|
| **Performance degradation with many drawings** | High | Medium | Implement drawing culling, optimize render loop, use requestAnimationFrame | Dev Team |
| **Coordinate transformation errors** | Medium | High | Comprehensive unit tests for coordinate math, validation layer | Dev Team |
| **Touch device interaction issues** | High | Medium | Implement touch event handlers, test on multiple devices | QA Team |
| **Drawing data corruption** | Low | High | Validate JSON schema, implement migration system, regular backups | Dev Team |
| **Browser canvas limitations** | Low | Medium | Implement fallback rendering, optimize canvas usage | Dev Team |
| **Memory leaks from event listeners** | Medium | Medium | Proper cleanup in useEffect, monitor memory usage | Dev Team |

## Performance Requirements

| Metric | Target | Measurement Method | Acceptance Threshold |
|--------|--------|-------------------|---------------------|
| **Drawing Response Time** | < 16ms | requestAnimationFrame timing | < 33ms (30 FPS) |
| **Render 100 Drawings** | < 50ms | Performance.now() | < 100ms |
| **Tool Selection** | < 50ms | UI response time | < 100ms |
| **Save/Load Time** | < 100ms | localStorage timing | < 200ms |
| **Memory per Drawing** | < 1KB | Chrome DevTools | < 2KB |

## Security Considerations

- Validate drawing data before deserialization
- Sanitize text annotations for XSS prevention
- Limit number of drawings per symbol (max 100)
- Validate coordinate values are within bounds
- Implement rate limiting for save operations

## Error Handling

```typescript
// src/lib/chart/drawing-error-handler.ts

export class DrawingError extends Error {
  constructor(message: string, public code: string) {
    super(message);
    this.name = 'DrawingError';
  }
}

export function handleDrawingError(error: Error, context: string): void {
  console.error(`Drawing error in ${context}:`, error);

  // Show user-friendly message
  // (Implementation depends on notification system)
}
```

## Notes

### Design Considerations

- Use distinct colors for different drawing types
- Provide visual feedback during drawing creation
- Implement undo/redo with Ctrl+Z/Ctrl+Y
- Show drawing count in toolbar
- Add quick access to commonly used tools

### Future Enhancements

1. **Advanced Fibonacci Tools**: Fan, arcs, time zones
2. **Pattern Recognition**: Auto-detect chart patterns
3. **Drawing Templates**: Save/load drawing sets
4. **Collaborative Drawings**: Share drawings with other users
5. **AI Suggestions**: Suggest optimal trendline placement

### Dependencies

```json
{
  "dependencies": {
    "lightweight-charts": "^4.1.0",
    "react": "^18.2.0"
  }
}
```

## References

- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 7: UX/UI Enhancements
- [TradingView Charting Library](https://www.tradingview.com/HTML5-stock-forex-bitcoin-charting-library/)
- [Canvas API Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API)
