# UX-005: Drag-and-Drop Watchlist

## Metadata

| Field | Value |
|-------|-------|
| **ID** | UX-005 |
| **Title** | Implement Drag-and-Drop for Lists |
| **Type** | Feature |
| **Status** | BACKLOG |
| **Priority** | P3 (Low) |
| **Estimate** | 4 hours |
| **Sprint** | Sprint 8 |
| **Epic** | UX/UI Enhancements |
| **Assignee** | TBD |
| **Created** | 2025-11-29 |
| **Updated** | 2025-11-30 |
| **Tags** | `ux`, `drag-drop`, `react-beautiful-dnd`, `reordering`, `touch-support` |
| **Blocks** | None |
| **Blocked By** | None |
| **Related** | None |

## Description

Implement drag-and-drop functionality for reordering items in watchlists, portfolio holdings, and screening filters. This will provide an intuitive way for users to organize their lists according to personal preferences, with persistence across sessions.

## Progress

**0% - Not started**

## Acceptance Criteria

- [ ] Watchlist item drag sorting
- [ ] Portfolio holdings sorting
- [ ] Screening filter order change
- [ ] Mobile touch support
- [ ] Sort order server persistence

## Detailed Subtasks

### 1. Library Integration
- [ ] Install and configure react-beautiful-dnd
  - [ ] Install `@hello-pangea/dnd` (maintained fork)
  - [ ] Set up TypeScript definitions
  - [ ] Configure SSR support for Next.js
- [ ] Alternative: Implement with dnd-kit
  - [ ] Evaluate dnd-kit for better accessibility
  - [ ] Compare performance characteristics
  - [ ] Choose final library based on requirements
- [ ] Set up drag context providers
  - [ ] Wrap application with DragDropContext
  - [ ] Handle drag lifecycle events
  - [ ] Implement custom styling hooks

### 2. Watchlist Drag-and-Drop
- [ ] Implement watchlist reordering
  - [ ] Create draggable watchlist item component
  - [ ] Add visual drag indicators
  - [ ] Handle drop zone highlighting
- [ ] Persist watchlist order
  - [ ] Save order to localStorage
  - [ ] Update API to store order
  - [ ] Load saved order on mount
- [ ] Visual feedback
  - [ ] Drag handle icon
  - [ ] Opacity change during drag
  - [ ] Drop zone preview
  - [ ] Smooth animations

### 3. Portfolio Holdings Reordering
- [ ] Implement holdings drag-and-drop
  - [ ] Create draggable holding row
  - [ ] Maintain table layout during drag
  - [ ] Update position calculations
- [ ] Custom sort preservation
  - [ ] Override default sorting
  - [ ] Show custom order indicator
  - [ ] Reset to default option
- [ ] Multi-select drag (optional)
  - [ ] Select multiple holdings
  - [ ] Drag selected group
  - [ ] Bulk reorder

### 4. Screening Filter Reordering
- [ ] Filter criteria drag-and-drop
  - [ ] Draggable filter chips/cards
  - [ ] Reorder AND/OR logic groups
  - [ ] Visual grouping during drag
- [ ] Filter priority indication
  - [ ] Number badges for order
  - [ ] Performance impact indicators
  - [ ] Suggested optimal order
- [ ] Filter presets
  - [ ] Save filter arrangements
  - [ ] Quick load saved orders
  - [ ] Share filter configurations

### 5. Mobile Touch Support
- [ ] Touch event handlers
  - [ ] Long-press to initiate drag
  - [ ] Touch feedback (haptic)
  - [ ] Scroll while dragging
- [ ] Mobile-optimized UI
  - [ ] Larger drag handles
  - [ ] Touch-friendly spacing
  - [ ] Prevent accidental drags
- [ ] Platform detection
  - [ ] Detect touch vs mouse
  - [ ] Adjust interaction delays
  - [ ] Platform-specific instructions

### 6. Server Persistence
- [ ] API endpoint for order storage
  - [ ] POST /api/watchlist/:id/order
  - [ ] POST /api/portfolio/:id/order
  - [ ] POST /api/filters/:id/order
- [ ] Database schema updates
  - [ ] Add `display_order` column
  - [ ] Create order mapping table
  - [ ] Migration scripts
- [ ] Sync logic
  - [ ] Debounce save operations (1 second)
  - [ ] Optimistic UI updates
  - [ ] Conflict resolution

### 7. Accessibility
- [ ] Keyboard navigation
  - [ ] Alt/Ctrl + Arrow keys to reorder
  - [ ] Announce position changes
  - [ ] Focus management
- [ ] Screen reader support
  - [ ] ARIA live regions
  - [ ] Descriptive labels
  - [ ] Alternative reorder UI
- [ ] Reduced motion
  - [ ] Respect prefers-reduced-motion
  - [ ] Instant position updates
  - [ ] Skip animations

## Implementation Details

### React Beautiful DND Setup

```typescript
// src/components/DraggableList/DraggableWatchlist.tsx

import React, { useState, useEffect } from 'react';
import {
  DragDropContext,
  Droppable,
  Draggable,
  DropResult,
  DraggableProvided,
  DraggableStateSnapshot,
  DroppableProvided,
} from '@hello-pangea/dnd';

interface WatchlistItem {
  id: string;
  symbol: string;
  name: string;
  price: number;
  change: number;
  displayOrder: number;
}

interface DraggableWatchlistProps {
  watchlistId: string;
  items: WatchlistItem[];
  onReorder: (items: WatchlistItem[]) => void;
}

export const DraggableWatchlist: React.FC<DraggableWatchlistProps> = ({
  watchlistId,
  items: initialItems,
  onReorder,
}) => {
  const [items, setItems] = useState(initialItems);

  useEffect(() => {
    setItems(initialItems);
  }, [initialItems]);

  const handleDragEnd = (result: DropResult) => {
    // Dropped outside the list
    if (!result.destination) {
      return;
    }

    // No position change
    if (result.destination.index === result.source.index) {
      return;
    }

    const reorderedItems = reorder(
      items,
      result.source.index,
      result.destination.index
    );

    setItems(reorderedItems);
    onReorder(reorderedItems);
  };

  return (
    <DragDropContext onDragEnd={handleDragEnd}>
      <Droppable droppableId={`watchlist-${watchlistId}`}>
        {(provided: DroppableProvided) => (
          <div
            ref={provided.innerRef}
            {...provided.droppableProps}
            className="watchlist-container"
          >
            {items.map((item, index) => (
              <Draggable
                key={item.id}
                draggableId={item.id}
                index={index}
              >
                {(
                  provided: DraggableProvided,
                  snapshot: DraggableStateSnapshot
                ) => (
                  <WatchlistItemRow
                    item={item}
                    provided={provided}
                    snapshot={snapshot}
                  />
                )}
              </Draggable>
            ))}
            {provided.placeholder}
          </div>
        )}
      </Droppable>
    </DragDropContext>
  );
};

// Reorder helper function
function reorder<T>(list: T[], startIndex: number, endIndex: number): T[] {
  const result = Array.from(list);
  const [removed] = result.splice(startIndex, 1);
  result.splice(endIndex, 0, removed);

  // Update display order
  return result.map((item, index) => ({
    ...item,
    displayOrder: index,
  }));
}
```

### Draggable Item Component

```typescript
// src/components/DraggableList/WatchlistItemRow.tsx

import React from 'react';
import { DraggableProvided, DraggableStateSnapshot } from '@hello-pangea/dnd';
import { GripVertical } from 'lucide-react';
import styles from './WatchlistItemRow.module.css';

interface WatchlistItemRowProps {
  item: WatchlistItem;
  provided: DraggableProvided;
  snapshot: DraggableStateSnapshot;
}

export const WatchlistItemRow: React.FC<WatchlistItemRowProps> = ({
  item,
  provided,
  snapshot,
}) => {
  return (
    <div
      ref={provided.innerRef}
      {...provided.draggableProps}
      className={`${styles.item} ${snapshot.isDragging ? styles.dragging : ''}`}
      style={provided.draggableProps.style}
    >
      {/* Drag Handle */}
      <div {...provided.dragHandleProps} className={styles.dragHandle}>
        <GripVertical size={16} className={styles.gripIcon} />
      </div>

      {/* Item Content */}
      <div className={styles.content}>
        <div className={styles.symbolName}>
          <span className={styles.symbol}>{item.symbol}</span>
          <span className={styles.name}>{item.name}</span>
        </div>

        <div className={styles.priceInfo}>
          <span className={styles.price}>${item.price.toFixed(2)}</span>
          <span
            className={`${styles.change} ${
              item.change >= 0 ? styles.positive : styles.negative
            }`}
          >
            {item.change >= 0 ? '+' : ''}
            {item.change.toFixed(2)}%
          </span>
        </div>
      </div>
    </div>
  );
};
```

### Styling

```css
/* src/components/DraggableList/WatchlistItemRow.module.css */

.item {
  display: flex;
  align-items: center;
  padding: 12px;
  background: var(--bg-primary);
  border: 1px solid var(--border-default);
  border-radius: 8px;
  margin-bottom: 8px;
  transition: all 200ms ease;
}

.item:hover {
  background: var(--bg-secondary);
  box-shadow: var(--shadow-sm);
}

.dragging {
  opacity: 0.5;
  box-shadow: var(--shadow-lg);
  transform: rotate(2deg);
}

.dragHandle {
  display: flex;
  align-items: center;
  padding: 4px 8px;
  margin-right: 12px;
  cursor: grab;
  color: var(--text-tertiary);
  transition: color 150ms ease;
}

.dragHandle:hover {
  color: var(--text-primary);
}

.dragHandle:active {
  cursor: grabbing;
}

.gripIcon {
  opacity: 0.6;
}

.item:hover .gripIcon {
  opacity: 1;
}

.content {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex: 1;
}

.symbolName {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.symbol {
  font-weight: 600;
  font-size: 14px;
  color: var(--text-primary);
}

.name {
  font-size: 12px;
  color: var(--text-secondary);
}

.priceInfo {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 4px;
}

.price {
  font-weight: 500;
  font-size: 14px;
  color: var(--text-primary);
}

.change {
  font-size: 12px;
  font-weight: 500;
}

.positive {
  color: var(--semantic-success);
}

.negative {
  color: var(--semantic-error);
}

/* Mobile optimizations */
@media (max-width: 768px) {
  .dragHandle {
    padding: 8px 12px;
    margin-right: 16px;
  }

  .gripIcon {
    width: 20px;
    height: 20px;
  }

  .item {
    padding: 16px 12px;
  }
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
  .item,
  .dragHandle,
  .gripIcon {
    transition: none;
  }

  .dragging {
    transform: none;
  }
}
```

### Persistence Hook

```typescript
// src/hooks/useWatchlistOrder.ts

import { useState, useEffect, useCallback, useRef } from 'react';
import { WatchlistItem } from '@/types/watchlist';

interface UseWatchlistOrderOptions {
  watchlistId: string;
  initialItems: WatchlistItem[];
  enableServerSync?: boolean;
}

export const useWatchlistOrder = ({
  watchlistId,
  initialItems,
  enableServerSync = true,
}: UseWatchlistOrderOptions) => {
  const [items, setItems] = useState<WatchlistItem[]>(initialItems);
  const [isSaving, setIsSaving] = useState(false);
  const saveTimeoutRef = useRef<NodeJS.Timeout>();

  // Load order from localStorage on mount
  useEffect(() => {
    const storedOrder = loadOrderFromStorage(watchlistId);
    if (storedOrder) {
      const orderedItems = applyOrder(initialItems, storedOrder);
      setItems(orderedItems);
    } else {
      setItems(initialItems);
    }
  }, [watchlistId, initialItems]);

  // Save order with debouncing
  const saveOrder = useCallback(
    async (newItems: WatchlistItem[]) => {
      setItems(newItems);

      // Save to localStorage immediately
      const order = newItems.map(item => item.id);
      saveOrderToStorage(watchlistId, order);

      // Debounce server sync
      if (enableServerSync) {
        if (saveTimeoutRef.current) {
          clearTimeout(saveTimeoutRef.current);
        }

        saveTimeoutRef.current = setTimeout(async () => {
          setIsSaving(true);
          try {
            await syncOrderToServer(watchlistId, order);
          } catch (error) {
            console.error('Failed to sync order to server:', error);
          } finally {
            setIsSaving(false);
          }
        }, 1000); // 1 second debounce
      }
    },
    [watchlistId, enableServerSync]
  );

  return {
    items,
    saveOrder,
    isSaving,
  };
};

// Helper functions
function loadOrderFromStorage(watchlistId: string): string[] | null {
  try {
    const key = `watchlist_order_${watchlistId}`;
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : null;
  } catch (error) {
    console.error('Failed to load order from storage:', error);
    return null;
  }
}

function saveOrderToStorage(watchlistId: string, order: string[]): void {
  try {
    const key = `watchlist_order_${watchlistId}`;
    localStorage.setItem(key, JSON.stringify(order));
  } catch (error) {
    console.error('Failed to save order to storage:', error);
  }
}

function applyOrder<T extends { id: string }>(
  items: T[],
  order: string[]
): T[] {
  const itemMap = new Map(items.map(item => [item.id, item]));
  const orderedItems: T[] = [];

  // Add items in specified order
  order.forEach(id => {
    const item = itemMap.get(id);
    if (item) {
      orderedItems.push(item);
      itemMap.delete(id);
    }
  });

  // Add any remaining items (new items not in order)
  itemMap.forEach(item => orderedItems.push(item));

  return orderedItems;
}

async function syncOrderToServer(
  watchlistId: string,
  order: string[]
): Promise<void> {
  const response = await fetch(`/api/watchlist/${watchlistId}/order`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ order }),
  });

  if (!response.ok) {
    throw new Error(`Server sync failed: ${response.statusText}`);
  }
}
```

### API Endpoint

```typescript
// src/pages/api/watchlist/[id]/order.ts

import type { NextApiRequest, NextApiResponse } from 'next';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/pages/api/auth/[...nextauth]';
import { prisma } from '@/lib/prisma';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const session = await getServerSession(req, res, authOptions);
  if (!session) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { id } = req.query;
  const { order } = req.body;

  if (!Array.isArray(order)) {
    return res.status(400).json({ error: 'Invalid order format' });
  }

  try {
    // Verify watchlist ownership
    const watchlist = await prisma.watchlist.findFirst({
      where: {
        id: id as string,
        userId: session.user.id,
      },
    });

    if (!watchlist) {
      return res.status(404).json({ error: 'Watchlist not found' });
    }

    // Update display order for each item
    await Promise.all(
      order.map((itemId, index) =>
        prisma.watchlistItem.update({
          where: { id: itemId },
          data: { displayOrder: index },
        })
      )
    );

    return res.status(200).json({ success: true });
  } catch (error) {
    console.error('Failed to update watchlist order:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
}
```

### Keyboard Reordering

```typescript
// src/hooks/useKeyboardReorder.ts

import { useEffect } from 'react';

interface UseKeyboardReorderOptions<T> {
  items: T[];
  selectedIndex: number;
  onReorder: (items: T[]) => void;
  enabled?: boolean;
}

export const useKeyboardReorder = <T>({
  items,
  selectedIndex,
  onReorder,
  enabled = true,
}: UseKeyboardReorderOptions<T>) => {
  useEffect(() => {
    if (!enabled || selectedIndex < 0) return;

    const handleKeyDown = (event: KeyboardEvent) => {
      const isAltPressed = event.altKey || event.ctrlKey;

      if (isAltPressed && event.key === 'ArrowUp') {
        event.preventDefault();
        moveUp();
      } else if (isAltPressed && event.key === 'ArrowDown') {
        event.preventDefault();
        moveDown();
      }
    };

    const moveUp = () => {
      if (selectedIndex > 0) {
        const newItems = [...items];
        [newItems[selectedIndex - 1], newItems[selectedIndex]] = [
          newItems[selectedIndex],
          newItems[selectedIndex - 1],
        ];
        onReorder(newItems);
      }
    };

    const moveDown = () => {
      if (selectedIndex < items.length - 1) {
        const newItems = [...items];
        [newItems[selectedIndex], newItems[selectedIndex + 1]] = [
          newItems[selectedIndex + 1],
          newItems[selectedIndex],
        ];
        onReorder(newItems);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [items, selectedIndex, enabled, onReorder]);
};
```

## Testing Strategy

### Unit Tests

```typescript
// __tests__/hooks/useWatchlistOrder.test.ts

import { renderHook, act } from '@testing-library/react';
import { useWatchlistOrder } from '@/hooks/useWatchlistOrder';

describe('useWatchlistOrder', () => {
  const mockItems = [
    { id: '1', symbol: 'AAPL', name: 'Apple', price: 150, change: 1.5, displayOrder: 0 },
    { id: '2', symbol: 'GOOGL', name: 'Google', price: 2800, change: -0.5, displayOrder: 1 },
    { id: '3', symbol: 'MSFT', name: 'Microsoft', price: 300, change: 2.0, displayOrder: 2 },
  ];

  beforeEach(() => {
    localStorage.clear();
  });

  it('initializes with provided items', () => {
    const { result } = renderHook(() =>
      useWatchlistOrder({
        watchlistId: 'test-watchlist',
        initialItems: mockItems,
        enableServerSync: false,
      })
    );

    expect(result.current.items).toEqual(mockItems);
  });

  it('saves order to localStorage', () => {
    const { result } = renderHook(() =>
      useWatchlistOrder({
        watchlistId: 'test-watchlist',
        initialItems: mockItems,
        enableServerSync: false,
      })
    );

    const reordered = [mockItems[1], mockItems[0], mockItems[2]];

    act(() => {
      result.current.saveOrder(reordered);
    });

    const stored = localStorage.getItem('watchlist_order_test-watchlist');
    expect(JSON.parse(stored!)).toEqual(['2', '1', '3']);
  });

  it('loads saved order from localStorage', () => {
    localStorage.setItem(
      'watchlist_order_test-watchlist',
      JSON.stringify(['3', '1', '2'])
    );

    const { result } = renderHook(() =>
      useWatchlistOrder({
        watchlistId: 'test-watchlist',
        initialItems: mockItems,
        enableServerSync: false,
      })
    );

    expect(result.current.items[0].id).toBe('3');
    expect(result.current.items[1].id).toBe('1');
    expect(result.current.items[2].id).toBe('2');
  });
});
```

### Integration Tests

```typescript
// __tests__/integration/drag-drop.test.tsx

import { render, screen, fireEvent } from '@testing-library/react';
import { DragDropContext } from '@hello-pangea/dnd';
import { DraggableWatchlist } from '@/components/DraggableList/DraggableWatchlist';

describe('Drag and Drop Integration', () => {
  const mockItems = [
    { id: '1', symbol: 'AAPL', name: 'Apple', price: 150, change: 1.5, displayOrder: 0 },
    { id: '2', symbol: 'GOOGL', name: 'Google', price: 2800, change: -0.5, displayOrder: 1 },
  ];

  it('renders all items', () => {
    const handleReorder = jest.fn();

    render(
      <DraggableWatchlist
        watchlistId="test"
        items={mockItems}
        onReorder={handleReorder}
      />
    );

    expect(screen.getByText('AAPL')).toBeInTheDocument();
    expect(screen.getByText('GOOGL')).toBeInTheDocument();
  });

  it('calls onReorder when drag completes', () => {
    const handleReorder = jest.fn();

    render(
      <DraggableWatchlist
        watchlistId="test"
        items={mockItems}
        onReorder={handleReorder}
      />
    );

    // Simulate drag (requires react-beautiful-dnd test utils)
    // This is a simplified example
    expect(handleReorder).not.toHaveBeenCalled();
  });
});
```

### E2E Tests

```typescript
// e2e/drag-drop.spec.ts

import { test, expect } from '@playwright/test';

test.describe('Drag and Drop', () => {
  test('reorders watchlist items', async ({ page }) => {
    await page.goto('/watchlist/my-stocks');

    // Get initial order
    const firstItem = page.locator('[data-watchlist-item]').first();
    const firstSymbol = await firstItem.getAttribute('data-symbol');

    // Drag first item to second position
    await firstItem.hover();
    await page.mouse.down();
    await page.mouse.move(0, 100); // Move down
    await page.mouse.up();

    // Wait for animation
    await page.waitForTimeout(500);

    // Verify order changed
    const newFirstItem = page.locator('[data-watchlist-item]').first();
    const newFirstSymbol = await newFirstItem.getAttribute('data-symbol');

    expect(newFirstSymbol).not.toBe(firstSymbol);
  });

  test('persists order after page reload', async ({ page }) => {
    await page.goto('/watchlist/my-stocks');

    // Drag and reorder
    const firstItem = page.locator('[data-watchlist-item]').first();
    await firstItem.hover();
    await page.mouse.down();
    await page.mouse.move(0, 100);
    await page.mouse.up();

    await page.waitForTimeout(500);

    const reorderedSymbol = await page
      .locator('[data-watchlist-item]')
      .first()
      .getAttribute('data-symbol');

    // Reload page
    await page.reload();

    // Verify order persisted
    const symbolAfterReload = await page
      .locator('[data-watchlist-item]')
      .first()
      .getAttribute('data-symbol');

    expect(symbolAfterReload).toBe(reorderedSymbol);
  });
});
```

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation Strategy | Owner |
|------|------------|--------|-------------------|-------|
| **Touch device drag issues** | High | Medium | Implement long-press delay, larger touch targets, extensive mobile testing | Dev/QA Team |
| **Performance with large lists (>100 items)** | Medium | Medium | Implement virtual scrolling, optimize render cycles, lazy loading | Dev Team |
| **Order sync conflicts (multiple devices)** | Medium | Low | Implement conflict resolution, last-write-wins strategy, user notifications | Backend Team |
| **Accidental reordering** | Medium | Low | Require intentional drag, undo functionality, confirmation for major changes | UX Team |
| **Accessibility for keyboard users** | Medium | High | Implement full keyboard support, screen reader announcements, focus management | A11y Team |
| **localStorage quota exceeded** | Low | Low | Limit stored data, cleanup old entries, fallback to server-only storage | Dev Team |
| **Animation jank on low-end devices** | Medium | Low | Detect device capability, reduce animations, use CSS transforms | Dev Team |

## Performance Requirements

| Metric | Target | Measurement Method | Acceptance Threshold |
|--------|--------|-------------------|---------------------|
| **Drag Start Response** | < 50ms | Performance.now() | < 100ms |
| **Drop Animation** | < 200ms | CSS transition timing | < 300ms |
| **List with 100 items** | 60 FPS | Chrome DevTools FPS meter | > 55 FPS |
| **Save to localStorage** | < 10ms | Performance.now() | < 20ms |
| **API Sync Time** | < 500ms | Network timing | < 1s |
| **Memory Overhead** | < 10MB | Chrome DevTools Memory | < 20MB |

## Security Considerations

### Input Validation

```typescript
// src/lib/validators/order.ts

import { z } from 'zod';

export const OrderUpdateSchema = z.object({
  order: z.array(z.string().uuid()).min(1).max(1000),
});

export function validateOrderUpdate(data: unknown) {
  return OrderUpdateSchema.parse(data);
}
```

### Authorization

- Verify user owns the watchlist/portfolio before allowing reorder
- Rate limit order update API (max 10 requests per minute)
- Validate all item IDs exist in the target list
- Prevent unauthorized access to other users' lists

## Error Handling

```typescript
// src/utils/drag-drop-error-handler.ts

export class DragDropError extends Error {
  constructor(message: string, public code: string) {
    super(message);
    this.name = 'DragDropError';
  }
}

export function handleDragDropError(error: Error, context: string): void {
  console.error(`Drag-drop error in ${context}:`, error);

  // Show user-friendly toast notification
  // (Implementation depends on notification system)

  // Log to error tracking
  if (typeof window !== 'undefined' && (window as any).Sentry) {
    (window as any).Sentry.captureException(error, {
      tags: { component: 'drag-drop', context },
    });
  }
}
```

## Notes

### Design Considerations

- Use visual feedback (opacity, shadow, transform) during drag
- Provide clear drag handles on desktop
- Implement haptic feedback on mobile devices
- Show "Save" indicator when syncing to server
- Add undo/redo for accidental reorders

### Future Enhancements

1. **Multi-List Drag**: Drag items between different watchlists
2. **Bulk Operations**: Select and reorder multiple items at once
3. **Smart Sorting**: AI-suggested optimal ordering
4. **Gesture Shortcuts**: Swipe gestures for quick reorder on mobile
5. **Collaborative Reorder**: Real-time sync for shared watchlists

### Dependencies

```json
{
  "dependencies": {
    "@hello-pangea/dnd": "^16.5.0",
    "react": "^18.2.0",
    "lucide-react": "^0.294.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@testing-library/react": "^14.1.2",
    "playwright": "^1.40.0"
  }
}
```

### Browser Support

- Chrome 90+ (recommended for best performance)
- Firefox 88+
- Safari 14+
- Edge 90+
- Mobile: iOS Safari 14+, Chrome Mobile 90+

### Accessibility Compliance

- **WCAG 2.1 Level AA**: Full keyboard navigation
- **Screen Reader**: Announce position changes
- **Reduced Motion**: Respect prefers-reduced-motion
- **Focus Management**: Maintain focus during reorder
- **Alternative UI**: Button-based reorder for accessibility

## References

- [IMPROVEMENT_TICKETS.md](../../IMPROVEMENT_TICKETS.md) - Epic 7: UX/UI Enhancements
- [React Beautiful DND Documentation](https://github.com/hello-pangea/dnd)
- [ARIA Authoring Practices - Sortable Lists](https://www.w3.org/WAI/ARIA/apg/patterns/listbox/)
- [Touch Events Reference](https://developer.mozilla.org/en-US/docs/Web/API/Touch_events)
