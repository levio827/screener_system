# [BE-007] User Portfolio API Implementation

## Metadata
- **Status**: DONE
- **Priority**: High
- **Assignee**: Backend Team
- **Estimated Time**: 14 hours
- **Actual Time**: 3 hours (tests only, core implementation already existed)
- **Sprint**: Phase 2 Enhancement
- **Completed**: 2025-11-14
- **Tags**: #backend #api #portfolio #user-data
- **Dependencies**: BE-002 (User Authentication API) ✅
- **Blocks**: FE-007 (User Dashboard)

## Description
Implement RESTful API endpoints to support user dashboard functionality, including watchlist management, recent activity tracking, and dashboard summary data. This API enables users to save favorite stocks, track screening history, and view personalized market insights.

## Problem Statement
- No backend support for user watchlists (save/load/manage favorite stocks)
- No tracking of user screening activity for recent history
- No API to aggregate dashboard summary data
- Missing CRUD operations for user-specific data

## Proposed Solution
Build comprehensive User Portfolio API with:
1. **Watchlist Management**: Create, read, update, delete watchlists
2. **Recent Activity Tracking**: Log and retrieve screening queries
3. **Dashboard Summary**: Aggregate user data for dashboard view
4. **Stock Subscription**: Manage user's favorite stocks

## API Endpoints

### 1. Dashboard Summary
```http
GET /api/v1/users/dashboard
Authorization: Bearer <JWT>

Response 200 OK:
{
  "watchlist_count": 3,
  "total_stocks": 25,
  "recent_activity_count": 15,
  "last_login": "2025-11-14T10:30:00Z",
  "subscription_tier": "free",
  "screening_quota": {
    "used": 45,
    "limit": 100,
    "reset_at": "2025-11-15T00:00:00Z"
  }
}
```

### 2. Watchlist Management

#### List Watchlists
```http
GET /api/v1/users/watchlists
Authorization: Bearer <JWT>
Query Params:
  - page: int (default: 1)
  - limit: int (default: 10)

Response 200 OK:
{
  "total": 3,
  "page": 1,
  "limit": 10,
  "watchlists": [
    {
      "id": "uuid",
      "name": "Tech Stocks",
      "description": "High-growth technology companies",
      "stock_count": 12,
      "created_at": "2025-11-01T10:00:00Z",
      "updated_at": "2025-11-14T08:30:00Z",
      "stocks": [
        {
          "code": "005930",
          "name": "Samsung Electronics",
          "current_price": 75000,
          "change_percent": 1.2,
          "added_at": "2025-11-01T10:00:00Z"
        }
      ]
    }
  ]
}
```

#### Get Single Watchlist
```http
GET /api/v1/users/watchlists/{watchlist_id}
Authorization: Bearer <JWT>

Response 200 OK:
{
  "id": "uuid",
  "name": "Tech Stocks",
  "description": "High-growth technology companies",
  "stock_count": 12,
  "created_at": "2025-11-01T10:00:00Z",
  "updated_at": "2025-11-14T08:30:00Z",
  "stocks": [...]
}

Response 404 Not Found:
{
  "detail": "Watchlist not found"
}
```

#### Create Watchlist
```http
POST /api/v1/users/watchlists
Authorization: Bearer <JWT>
Content-Type: application/json

Request Body:
{
  "name": "New Watchlist",
  "description": "Optional description",
  "stock_codes": ["005930", "000660"]  // Optional initial stocks
}

Response 201 Created:
{
  "id": "uuid",
  "name": "New Watchlist",
  "description": "Optional description",
  "stock_count": 2,
  "created_at": "2025-11-14T10:30:00Z",
  "updated_at": "2025-11-14T10:30:00Z",
  "stocks": [...]
}

Response 400 Bad Request:
{
  "detail": "Watchlist limit reached (max 10)"
}
```

#### Update Watchlist
```http
PUT /api/v1/users/watchlists/{watchlist_id}
Authorization: Bearer <JWT>
Content-Type: application/json

Request Body:
{
  "name": "Updated Name",  // Optional
  "description": "Updated description",  // Optional
  "add_stocks": ["035420"],  // Optional
  "remove_stocks": ["000660"]  // Optional
}

Response 200 OK:
{
  "id": "uuid",
  "name": "Updated Name",
  "stock_count": 2,
  "updated_at": "2025-11-14T10:35:00Z"
}
```

#### Delete Watchlist
```http
DELETE /api/v1/users/watchlists/{watchlist_id}
Authorization: Bearer <JWT>

Response 204 No Content

Response 404 Not Found:
{
  "detail": "Watchlist not found"
}
```

### 3. Recent Activity Tracking

#### Get Recent Activity
```http
GET /api/v1/users/recent-activity
Authorization: Bearer <JWT>
Query Params:
  - limit: int (default: 10, max: 50)
  - type: string (optional: "screening", "watchlist", "all")

Response 200 OK:
{
  "total": 25,
  "activities": [
    {
      "id": "uuid",
      "type": "screening",
      "description": "Screened stocks: PER < 10, ROE > 15%",
      "result_count": 45,
      "filter_criteria": {...},  // Original filter object
      "created_at": "2025-11-14T09:30:00Z"
    },
    {
      "id": "uuid",
      "type": "watchlist_update",
      "description": "Added Samsung Electronics to Tech Stocks",
      "watchlist_id": "uuid",
      "created_at": "2025-11-14T08:15:00Z"
    }
  ]
}
```

#### Re-run Screening Query
```http
POST /api/v1/users/recent-activity/{activity_id}/rerun
Authorization: Bearer <JWT>

Response 200 OK:
{
  "screening_id": "uuid",
  "result_count": 48,
  "results": [...]
}
```

## Subtasks

### Phase 1: Database Schema (3 hours)
- [ ] Design watchlists table schema
  - Columns: id, user_id, name, description, created_at, updated_at
  - Indexes: user_id, created_at
  - Constraints: unique(user_id, name)
- [ ] Design watchlist_stocks junction table
  - Columns: watchlist_id, stock_code, added_at
  - Indexes: watchlist_id, stock_code, added_at
  - Constraints: unique(watchlist_id, stock_code)
- [ ] Design user_activities table
  - Columns: id, user_id, type, description, metadata (JSON), created_at
  - Indexes: user_id, type, created_at
- [ ] Create Alembic migration
- [ ] Apply migration and verify

### Phase 2: Pydantic Schemas (2 hours)
- [ ] Create WatchlistBase, WatchlistCreate, WatchlistUpdate schemas
- [ ] Create WatchlistInDB, WatchlistResponse schemas
- [ ] Create WatchlistStockResponse schema
- [ ] Create UserActivityResponse schema
- [ ] Create DashboardSummaryResponse schema
- [ ] Add comprehensive field validation

### Phase 3: Database Models (2 hours)
- [ ] Create Watchlist SQLAlchemy model
- [ ] Create WatchlistStock association model
- [ ] Create UserActivity model
- [ ] Implement relationships (user -> watchlists -> stocks)
- [ ] Add model methods (add_stock, remove_stock)

### Phase 4: CRUD Operations (3 hours)
- [ ] Implement watchlist CRUD functions
  - create_watchlist(user_id, data)
  - get_user_watchlists(user_id, skip, limit)
  - get_watchlist_by_id(watchlist_id, user_id)
  - update_watchlist(watchlist_id, user_id, data)
  - delete_watchlist(watchlist_id, user_id)
- [ ] Implement stock operations
  - add_stocks_to_watchlist(watchlist_id, stock_codes)
  - remove_stocks_from_watchlist(watchlist_id, stock_codes)
  - get_watchlist_stocks(watchlist_id)
- [ ] Implement activity tracking
  - log_activity(user_id, type, description, metadata)
  - get_user_activities(user_id, limit, type_filter)

### Phase 5: API Endpoints (3 hours)
- [ ] Create /api/v1/users/watchlists router
- [ ] Implement GET /watchlists (list all)
- [ ] Implement POST /watchlists (create)
- [ ] Implement GET /watchlists/{id} (get one)
- [ ] Implement PUT /watchlists/{id} (update)
- [ ] Implement DELETE /watchlists/{id} (delete)
- [ ] Implement GET /recent-activity
- [ ] Implement GET /dashboard (summary)
- [ ] Add proper error handling and status codes

### Phase 6: Testing (3 hours)
- [ ] Unit tests for CRUD operations (15+ tests)
- [ ] Integration tests for API endpoints (20+ tests)
- [ ] Test authentication/authorization
- [ ] Test watchlist limits (max 10 per user)
- [ ] Test stock validation (codes exist in DB)
- [ ] Test concurrent updates (optimistic locking)
- [ ] Test activity logging
- [ ] Test pagination
- [ ] Performance test (large watchlists)

## Acceptance Criteria
- [ ] All 8 API endpoints implemented and documented
- [ ] Database schema created with proper indexes
- [ ] User can create up to 10 watchlists
- [ ] Watchlist can contain unlimited stocks
- [ ] Stock codes validated against stocks table
- [ ] Only watchlist owner can modify/delete
- [ ] Activity log captures all user actions
- [ ] Recent activity limited to last 50 entries
- [ ] All endpoints protected with JWT authentication
- [ ] 35+ tests passing (unit + integration)
- [ ] API response time <200ms (p95)
- [ ] OpenAPI/Swagger documentation complete
- [ ] Error handling comprehensive

## Technical Implementation

### Database Schema (Alembic Migration)
```python
# Migration: add_user_portfolio_tables

def upgrade():
    # Watchlists table
    op.create_table(
        'watchlists',
        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True),
        sa.Column('user_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('name', sa.String(100), nullable=False),
        sa.Column('description', sa.Text, nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.Column('updated_at', sa.DateTime(timezone=True), onupdate=sa.func.now()),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
        sa.UniqueConstraint('user_id', 'name', name='uq_user_watchlist_name')
    )
    op.create_index('idx_watchlists_user_id', 'watchlists', ['user_id'])

    # Watchlist stocks junction table
    op.create_table(
        'watchlist_stocks',
        sa.Column('watchlist_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('stock_code', sa.String(6), nullable=False),
        sa.Column('added_at', sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.ForeignKeyConstraint(['watchlist_id'], ['watchlists.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['stock_code'], ['stocks.code'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('watchlist_id', 'stock_code')
    )
    op.create_index('idx_watchlist_stocks_watchlist', 'watchlist_stocks', ['watchlist_id'])

    # User activities table
    op.create_table(
        'user_activities',
        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True),
        sa.Column('user_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('type', sa.String(50), nullable=False),
        sa.Column('description', sa.Text, nullable=False),
        sa.Column('metadata', postgresql.JSONB, nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE')
    )
    op.create_index('idx_user_activities_user_id', 'user_activities', ['user_id'])
    op.create_index('idx_user_activities_type', 'user_activities', ['type'])
```

### SQLAlchemy Models
```python
# backend/app/db/models/watchlist.py
from sqlalchemy import Column, String, Text, DateTime, ForeignKey
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
from app.db.base import Base

class Watchlist(Base):
    __tablename__ = "watchlists"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"))
    name = Column(String(100), nullable=False)
    description = Column(Text, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    # Relationships
    user = relationship("User", back_populates="watchlists")
    stocks = relationship("WatchlistStock", back_populates="watchlist", cascade="all, delete-orphan")

class WatchlistStock(Base):
    __tablename__ = "watchlist_stocks"

    watchlist_id = Column(UUID(as_uuid=True), ForeignKey("watchlists.id", ondelete="CASCADE"), primary_key=True)
    stock_code = Column(String(6), ForeignKey("stocks.code", ondelete="CASCADE"), primary_key=True)
    added_at = Column(DateTime(timezone=True), server_default=func.now())

    # Relationships
    watchlist = relationship("Watchlist", back_populates="stocks")
    stock = relationship("Stock")
```

### API Router
```python
# backend/app/api/v1/endpoints/users.py
from fastapi import APIRouter, Depends, HTTPException, status
from app.api.dependencies import get_current_user
from app.schemas.watchlist import WatchlistCreate, WatchlistUpdate, WatchlistResponse
from app.services import watchlist_service

router = APIRouter(prefix="/users", tags=["users"])

@router.get("/watchlists", response_model=list[WatchlistResponse])
async def list_watchlists(
    current_user: User = Depends(get_current_user),
    skip: int = 0,
    limit: int = 10
):
    """Get all watchlists for the current user"""
    return await watchlist_service.get_user_watchlists(current_user.id, skip, limit)

@router.post("/watchlists", response_model=WatchlistResponse, status_code=status.HTTP_201_CREATED)
async def create_watchlist(
    watchlist_data: WatchlistCreate,
    current_user: User = Depends(get_current_user)
):
    """Create a new watchlist"""
    return await watchlist_service.create_watchlist(current_user.id, watchlist_data)
```

## Dependencies
- **Database**: PostgreSQL (existing)
- **Authentication**: JWT (BE-002, already implemented)
- **Backend**: FastAPI, SQLAlchemy, Alembic (existing)

## References
- **FE-007**: User Dashboard (dependent on this API)
- **BE-002**: User Authentication API (provides JWT middleware)
- **Database Schema**: database/migrations/
- **API Standards**: api/README.md

## Progress
- **100%** - Completed
  - ✅ Database schema (Watchlist, WatchlistStock, UserActivity, UserPreferences)
  - ✅ Pydantic schemas for validation
  - ✅ SQLAlchemy models with relationships
  - ✅ Repository layer (CRUD operations)
  - ✅ Service layer (business logic)
  - ✅ API endpoints (8 endpoints implemented)
  - ✅ Comprehensive tests (51 tests: 23 unit + 28 integration)

## Notes
- Implement rate limiting per user tier (reuse existing middleware)
- Cache watchlist data with 5-minute TTL to reduce DB load
- Log all watchlist modifications for audit trail
- Validate stock codes exist before adding to watchlist
- Implement soft delete for watchlists (add deleted_at column in future)
- Consider adding watchlist sharing feature in future
- Activity log should be pruned after 90 days (background job)
- Implement pagination for large watchlists (>100 stocks)

## Performance Targets
- GET /watchlists: <150ms (p95)
- POST /watchlists: <200ms (p95)
- PUT /watchlists: <200ms (p95)
- DELETE /watchlists: <100ms (p95)
- GET /recent-activity: <100ms (p95)
- Database query optimization with proper indexes

## Security Considerations
- Enforce user ownership check on all operations
- Sanitize watchlist names (prevent XSS)
- Limit watchlist name length (100 chars)
- Limit stocks per watchlist (1000 max)
- Limit watchlists per user (10 max for free tier)
- Rate limit watchlist creation (10/hour)

## Future Enhancements (Post-MVP)
- [ ] Watchlist sharing (public/private/shared with users)
- [ ] Watchlist templates (pre-built watchlists)
- [ ] Stock alerts within watchlist
- [ ] Watchlist performance tracking
- [ ] Export watchlist to CSV
- [ ] Import stocks from CSV
- [ ] Watchlist analytics (most popular stocks)
- [ ] Collaborative watchlists (multi-user)

## Impact
- **User Retention**: Personalized data increases stickiness
- **Engagement**: Watchlists encourage repeat visits
- **Feature Foundation**: Enables dashboard, alerts, portfolio tracking
- **Premium Conversion**: Premium tier can offer more watchlists

## Next Steps
After completion:
- **FE-007**: Implement User Dashboard UI
- **BE-008**: Implement price alert API
- Monitor API usage patterns for optimization
- Gather user feedback on watchlist UX
