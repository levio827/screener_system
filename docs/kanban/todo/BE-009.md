# [BE-009] Market Overview API Implementation

## Metadata
- **Status**: TODO
- **Priority**: High
- **Assignee**: Backend Team
- **Estimated Time**: 16 hours
- **Sprint**: Phase 2 Enhancement
- **Tags**: #backend #api #market-data #analytics
- **Dependencies**: DB-002 (Database Schema) ✅, DP-002 (Daily Price Ingestion) ✅
- **Blocks**: FE-009 (Market Overview Page)

## Description
Implement RESTful API endpoints to provide comprehensive market overview data for Korean stock markets (KOSPI/KOSDAQ). These endpoints aggregate and expose real-time market indices, sector performance, market breadth indicators, top movers, and trading volume leaders. This data powers the Market Overview dashboard (FE-009).

## Problem Statement
- No backend API for aggregated market statistics
- No sector-level performance calculation endpoints
- No API for market breadth indicators (advancing/declining stocks)
- Missing endpoints for top gainers/losers and volume leaders
- No historical market trend data endpoints

## Proposed Solution
Build comprehensive Market Overview API with 6 main endpoints:
1. **Market Indices**: Real-time KOSPI, KOSDAQ, KRX100 with sparklines
2. **Market Breadth**: Advancing/declining/unchanged counts with A/D ratio
3. **Sector Performance**: Aggregated sector performance with change percentages
4. **Market Movers**: Top gainers and losers across markets
5. **Most Active**: Stocks with highest trading volume
6. **Market Trend**: Historical index data for charting

## API Endpoints

### 1. Market Indices
```http
GET /api/v1/market/indices
Query Params:
  - None

Response 200 OK:
{
  "indices": [
    {
      "code": "KOSPI",
      "name": "코스피",
      "current": 2500.12,
      "change": 15.30,
      "change_percent": 0.62,
      "high": 2520.50,
      "low": 2485.00,
      "volume": 450000000,
      "value": 12500000000000,
      "timestamp": "2025-11-14T15:30:00+09:00",
      "sparkline": [2485.0, 2490.2, ..., 2500.12]  // Last 30 data points
    },
    {
      "code": "KOSDAQ",
      "name": "코스닥",
      "current": 850.45,
      "change": -4.20,
      "change_percent": -0.49,
      ...
    },
    {
      "code": "KRX100",
      "name": "KRX 100",
      "current": 5234.67,
      "change": 25.12,
      "change_percent": 0.48,
      ...
    }
  ],
  "updated_at": "2025-11-14T15:30:00+09:00"
}
```

### 2. Market Breadth
```http
GET /api/v1/market/breadth
Query Params:
  - market: string (optional: "KOSPI", "KOSDAQ", "ALL", default: "ALL")

Response 200 OK:
{
  "advancing": 1234,
  "declining": 856,
  "unchanged": 310,
  "total": 2400,
  "ad_ratio": 1.44,
  "sentiment": "bullish",  // "bullish" | "neutral" | "bearish"
  "market": "ALL",
  "timestamp": "2025-11-14T15:30:00+09:00"
}
```

**Sentiment Calculation**:
- `bullish`: A/D ratio > 1.2
- `neutral`: 0.8 <= A/D ratio <= 1.2
- `bearish`: A/D ratio < 0.8

### 3. Sector Performance
```http
GET /api/v1/market/sectors
Query Params:
  - timeframe: string (optional: "1D", "1W", "1M", "3M", default: "1D")
  - market: string (optional: "KOSPI", "KOSDAQ", "ALL", default: "ALL")

Response 200 OK:
{
  "sectors": [
    {
      "code": "technology",
      "name": "기술",
      "change_percent": 2.1,
      "stock_count": 245,
      "market_cap": 450000000000000,
      "volume": 125000000,
      "top_stock": {
        "code": "005930",
        "name": "삼성전자",
        "change_percent": 1.5
      }
    },
    {
      "code": "finance",
      "name": "금융",
      "change_percent": -0.5,
      ...
    },
    ...
  ],
  "timeframe": "1D",
  "market": "ALL",
  "updated_at": "2025-11-14T15:30:00+09:00"
}
```

**Sector Codes**:
- `technology`: 기술
- `finance`: 금융
- `healthcare`: 헬스케어
- `consumer`: 소비재
- `materials`: 소재
- `industrial`: 산업재
- `energy`: 에너지
- `utilities`: 유틸리티
- `telecom`: 통신
- `real_estate`: 부동산

### 4. Market Movers
```http
GET /api/v1/market/movers
Query Params:
  - type: string (required: "gainers" | "losers")
  - market: string (optional: "KOSPI", "KOSDAQ", "ALL", default: "ALL")
  - limit: int (optional, default: 20, max: 100)

Response 200 OK:
{
  "type": "gainers",
  "market": "ALL",
  "stocks": [
    {
      "code": "123456",
      "name": "ABC Corp",
      "market": "KOSPI",
      "current_price": 50000,
      "change": 4750,
      "change_percent": 10.5,
      "volume": 1250000,
      "value": 62500000000,
      "sector": "technology"
    },
    ...
  ],
  "total": 20,
  "updated_at": "2025-11-14T15:30:00+09:00"
}
```

### 5. Most Active Stocks
```http
GET /api/v1/market/active
Query Params:
  - metric: string (optional: "volume" | "value", default: "volume")
  - market: string (optional: "KOSPI", "KOSDAQ", "ALL", default: "ALL")
  - limit: int (optional, default: 20, max: 100)

Response 200 OK:
{
  "metric": "volume",
  "market": "ALL",
  "stocks": [
    {
      "code": "005930",
      "name": "삼성전자",
      "market": "KOSPI",
      "current_price": 75000,
      "change_percent": 1.2,
      "volume": 15234567,
      "value": 1142592525000,
      "sector": "technology"
    },
    ...
  ],
  "total": 20,
  "updated_at": "2025-11-14T15:30:00+09:00"
}
```

### 6. Market Trend
```http
GET /api/v1/market/trend
Query Params:
  - index: string (optional: "KOSPI", "KOSDAQ", "KRX100", default: "KOSPI")
  - timeframe: string (optional: "1D", "5D", "1M", "3M", "6M", "1Y", default: "1M")
  - interval: string (optional: "1m", "5m", "1h", "1d", default: auto-selected)

Response 200 OK:
{
  "index": "KOSPI",
  "timeframe": "1M",
  "interval": "1d",
  "data": [
    {
      "timestamp": "2025-10-14T00:00:00+09:00",
      "open": 2450.00,
      "high": 2465.30,
      "low": 2442.50,
      "close": 2460.10,
      "volume": 420000000
    },
    ...
  ],
  "count": 21,  // Trading days
  "updated_at": "2025-11-14T15:30:00+09:00"
}
```

**Interval Auto-Selection**:
- `1D`: 1-minute intervals
- `5D`: 5-minute intervals
- `1M`, `3M`: 1-hour intervals
- `6M`, `1Y`: 1-day intervals

## Subtasks

### Phase 1: Database Schema & Models (3 hours)
- [ ] Review existing `stocks` and `daily_prices` tables
- [ ] Create/update sector classification (add `sector` column to `stocks` if missing)
- [ ] Create `market_indices` table for KOSPI/KOSDAQ/KRX100 historical data
- [ ] Create Alembic migration for schema changes
- [ ] Create SQLAlchemy models for new tables
- [ ] Apply migration and verify

### Phase 2: Repository Layer (4 hours)
- [ ] Create `market_repository.py` with query functions:
  - `get_current_indices()` - Latest index values
  - `get_market_breadth(market)` - Advancing/declining counts
  - `get_sector_performance(timeframe, market)` - Sector aggregation
  - `get_top_movers(type, market, limit)` - Top gainers/losers
  - `get_most_active(metric, market, limit)` - Volume/value leaders
  - `get_index_history(index, timeframe, interval)` - Historical data
- [ ] Implement efficient SQL queries with proper indexing
- [ ] Add caching layer (Redis) for expensive aggregations

### Phase 3: Service Layer (3 hours)
- [ ] Create `market_service.py` with business logic:
  - Sparkline generation (last 30 data points)
  - A/D ratio calculation and sentiment determination
  - Sector aggregation and top stock identification
  - Cache key generation and invalidation
- [ ] Implement data transformation for API responses
- [ ] Add error handling and validation

### Phase 4: API Endpoints (4 hours)
- [ ] Create `/api/v1/market` router
- [ ] Implement `GET /market/indices` endpoint
- [ ] Implement `GET /market/breadth` endpoint
- [ ] Implement `GET /market/sectors` endpoint
- [ ] Implement `GET /market/movers` endpoint
- [ ] Implement `GET /market/active` endpoint
- [ ] Implement `GET /market/trend` endpoint
- [ ] Add proper error handling and status codes
- [ ] Add OpenAPI/Swagger documentation

### Phase 5: Testing (2 hours)
- [ ] Unit tests for repository queries (10+ tests)
- [ ] Unit tests for service logic (10+ tests)
- [ ] Integration tests for API endpoints (15+ tests)
- [ ] Test market filter validation
- [ ] Test timeframe validation
- [ ] Test pagination limits
- [ ] Test caching behavior
- [ ] Performance test for aggregation queries

## Acceptance Criteria
- [ ] All 6 API endpoints implemented and documented
- [ ] Sector classification added to stocks table
- [ ] Market indices data populated (seed data or from existing sources)
- [ ] All query parameters validated correctly
- [ ] Proper error messages for invalid inputs (400 Bad Request)
- [ ] 404 for missing data (e.g., invalid sector code)
- [ ] Caching implemented with appropriate TTL (5 minutes for real-time data)
- [ ] 35+ tests passing (unit + integration)
- [ ] API response time <500ms (p95) for all endpoints
- [ ] Sector aggregation query <1s for full market
- [ ] OpenAPI/Swagger documentation complete
- [ ] No N+1 query issues

## Technical Implementation

### Database Schema Updates

#### Add Sector Classification
```sql
-- Migration: add_sector_classification
ALTER TABLE stocks ADD COLUMN sector VARCHAR(50);
CREATE INDEX idx_stocks_sector ON stocks(sector);

-- Populate sectors based on industry mapping
UPDATE stocks
SET sector = CASE
  WHEN industry IN (...) THEN 'technology'
  WHEN industry IN (...) THEN 'finance'
  -- ... mapping logic
END;
```

#### Create Market Indices Table
```sql
-- Migration: create_market_indices
CREATE TABLE market_indices (
  id SERIAL PRIMARY KEY,
  code VARCHAR(20) NOT NULL,  -- 'KOSPI', 'KOSDAQ', 'KRX100'
  timestamp TIMESTAMPTZ NOT NULL,
  open NUMERIC(10, 2),
  high NUMERIC(10, 2),
  low NUMERIC(10, 2),
  close NUMERIC(10, 2),
  volume BIGINT,
  value BIGINT,
  UNIQUE(code, timestamp)
);

CREATE INDEX idx_market_indices_code_timestamp ON market_indices(code, timestamp DESC);

-- Convert to TimescaleDB hypertable
SELECT create_hypertable('market_indices', 'timestamp');
```

### Repository Implementation
```python
# backend/app/repositories/market_repository.py
from sqlalchemy import select, func, case
from app.db.models import Stock, DailyPrice, MarketIndex

class MarketRepository:
    async def get_market_breadth(self, db: AsyncSession, market: str = "ALL") -> dict:
        """Get advancing/declining/unchanged stock counts"""
        query = select(
            func.count(case((Stock.change_percent > 0, 1))).label("advancing"),
            func.count(case((Stock.change_percent < 0, 1))).label("declining"),
            func.count(case((Stock.change_percent == 0, 1))).label("unchanged"),
        )

        if market != "ALL":
            query = query.where(Stock.market == market)

        result = await db.execute(query)
        data = result.one()

        ad_ratio = data.advancing / data.declining if data.declining > 0 else 0

        return {
            "advancing": data.advancing,
            "declining": data.declining,
            "unchanged": data.unchanged,
            "total": data.advancing + data.declining + data.unchanged,
            "ad_ratio": round(ad_ratio, 2),
            "sentiment": self._calculate_sentiment(ad_ratio),
        }

    def _calculate_sentiment(self, ad_ratio: float) -> str:
        if ad_ratio > 1.2:
            return "bullish"
        elif ad_ratio < 0.8:
            return "bearish"
        return "neutral"

    async def get_sector_performance(
        self, db: AsyncSession, timeframe: str = "1D", market: str = "ALL"
    ) -> list:
        """Get aggregated sector performance"""
        query = select(
            Stock.sector,
            func.avg(Stock.change_percent).label("avg_change"),
            func.count(Stock.code).label("stock_count"),
            func.sum(Stock.market_cap).label("total_market_cap"),
            func.sum(Stock.volume).label("total_volume"),
        ).group_by(Stock.sector)

        if market != "ALL":
            query = query.where(Stock.market == market)

        result = await db.execute(query)
        sectors = result.all()

        # Additional query to get top stock per sector
        # ... implementation

        return sectors
```

### Service Layer
```python
# backend/app/services/market_service.py
from app.repositories.market_repository import MarketRepository
from app.core.cache import cache

class MarketService:
    def __init__(self, repository: MarketRepository):
        self.repository = repository

    @cache(ttl=300)  # 5 minutes
    async def get_market_breadth(self, market: str = "ALL") -> dict:
        """Get market breadth with caching"""
        data = await self.repository.get_market_breadth(market)
        return data

    @cache(ttl=300)
    async def get_sector_performance(
        self, timeframe: str = "1D", market: str = "ALL"
    ) -> list:
        """Get sector performance with caching"""
        sectors = await self.repository.get_sector_performance(timeframe, market)
        return [self._transform_sector(s) for s in sectors]

    def _transform_sector(self, sector_data) -> dict:
        """Transform database result to API response format"""
        return {
            "code": sector_data.sector,
            "name": self._get_sector_name(sector_data.sector),
            "change_percent": round(sector_data.avg_change, 2),
            "stock_count": sector_data.stock_count,
            # ... additional fields
        }
```

### API Router
```python
# backend/app/api/v1/endpoints/market.py
from fastapi import APIRouter, Depends, Query
from app.services.market_service import MarketService
from app.schemas.market import MarketBreadthResponse, SectorPerformanceResponse

router = APIRouter(prefix="/market", tags=["market"])

@router.get("/breadth", response_model=MarketBreadthResponse)
async def get_market_breadth(
    market: str = Query("ALL", regex="^(KOSPI|KOSDAQ|ALL)$"),
    service: MarketService = Depends(get_market_service),
):
    """
    Get market breadth indicators.

    Returns advancing, declining, and unchanged stock counts with A/D ratio.
    """
    return await service.get_market_breadth(market)

@router.get("/sectors", response_model=list[SectorPerformanceResponse])
async def get_sector_performance(
    timeframe: str = Query("1D", regex="^(1D|1W|1M|3M)$"),
    market: str = Query("ALL", regex="^(KOSPI|KOSDAQ|ALL)$"),
    service: MarketService = Depends(get_market_service),
):
    """
    Get sector performance aggregated by sector.

    Returns sector-level statistics including average change percentage,
    market cap, and top performing stock.
    """
    return await service.get_sector_performance(timeframe, market)
```

## Dependencies
- **Database**: PostgreSQL + TimescaleDB (existing)
- **Backend**: FastAPI, SQLAlchemy, Redis (existing)
- **Data**: Existing stocks and daily_prices tables
- **External**: KIS API for market indices (optional, or calculate from stock data)

## References
- **FE-009**: Market Overview Page (dependent on this API)
- **DB-002**: Database Schema (stocks, daily_prices tables)
- **DP-002**: Daily Price Ingestion (provides stock price data)

## Progress
- **0%** - Not started

## Notes
- Market indices (KOSPI, KOSDAQ, KRX100) can be:
  1. Fetched from external API (e.g., KIS API)
  2. Calculated from constituent stocks (more complex but possible)
  3. Stored in separate `market_indices` table (recommended)
- Sector classification should follow KRX standard sectors
- Consider creating materialized views for expensive aggregations
- Cache invalidation strategy: On new price data ingestion (via DAG)
- Implement rate limiting (reuse existing middleware)
- Add background job to pre-warm cache during market hours

## Performance Targets
- GET /market/indices: <200ms (p95)
- GET /market/breadth: <300ms (p95) - requires full table scan
- GET /market/sectors: <500ms (p95) - aggregation query
- GET /market/movers: <300ms (p95) - sorting query
- GET /market/active: <300ms (p95) - sorting query
- GET /market/trend: <400ms (p95) - time-series query
- Database query optimization with proper indexes
- Materialized view for sector aggregation (optional)

## Security Considerations
- No authentication required (public market data)
- Rate limiting: 100 requests/minute for anonymous users
- Input validation for all query parameters
- SQL injection prevention (parameterized queries)
- No sensitive data exposure

## Future Enhancements (Post-MVP)
- [ ] Real-time WebSocket streaming for market indices
- [ ] Correlation analysis between sectors
- [ ] Global market indices (S&P 500, NASDAQ, Nikkei)
- [ ] Intraday market breadth charts
- [ ] Market sentiment indicators (VIX equivalent)
- [ ] Options market data integration
- [ ] Futures and derivatives data
- [ ] Economic calendar integration

## Impact
- **User Value**: Comprehensive market overview for informed decisions
- **Feature Enabler**: Powers Market Overview dashboard (FE-009)
- **Engagement**: Attracts users seeking market-wide insights
- **SEO**: "Korean stock market overview" keyword ranking
- **Premium Potential**: Advanced analytics for premium tiers

## Next Steps
After completion:
- **FE-009**: Implement Market Overview Page UI
- Monitor API usage patterns for optimization
- Gather user feedback on most valuable metrics
- Consider adding more sophisticated market indicators
